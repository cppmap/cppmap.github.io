


<!doctype html>
<html lang="ja" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="C++20 の新しい言語機能と標準ライブラリ機能の解説">
      
      
        <link rel="canonical" href="https://cppmap.github.io/standardization/cpp20/">
      
      
        <meta name="author" content="Ryo Suzuki">
      
      <link rel="shortcut icon" href="../../assets/images/logo.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.4.0">
    
    
      
        <title>C++20 の新機能 - C++ の歩き方 | CppMap</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.fe0cca5b.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
      <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="../../cppmap_styles.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="teal" data-md-color-accent="teal">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#c20" class="md-skip">
          コンテンツにスキップ
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="https://cppmap.github.io/" title="C++ の歩き方 | CppMap" class="md-header-nav__button md-logo" aria-label="C++ の歩き方 | CppMap">
      
  <img src="../../images/donut_small-white-24dp.svg" alt="logo">

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            C++ の歩き方 | CppMap
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              C++20 の新機能
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="検索" placeholder="検索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/cppmap/cppmap.docs" title="リポジトリへ" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    cppmap/cppmap.docs
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="./" class="md-tabs__link md-tabs__link--active">
          C++ 規格
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../articles/comment-tricks/" class="md-tabs__link">
          記事
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../learn/books/" class="md-tabs__link">
          学習
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../libraries/boost/" class="md-tabs__link">
          ライブラリ
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../tools/onlinecompilers/" class="md-tabs__link">
          ツール
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../contribution/contributors/" class="md-tabs__link">
          貢献
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://cppmap.github.io/" title="C++ の歩き方 | CppMap" class="md-nav__button md-logo" aria-label="C++ の歩き方 | CppMap">
      
  <img src="../../images/donut_small-white-24dp.svg" alt="logo">

    </a>
    C++ の歩き方 | CppMap
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/cppmap/cppmap.docs" title="リポジトリへ" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    cppmap/cppmap.docs
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      C++ 規格
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="C++ 規格" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        C++ 規格
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        C++20 の新機能
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 9h14V7H3v2m0 4h14v-2H3v2m0 4h14v-2H3v2m16 0h2v-2h-2v2m0-10v2h2V7h-2m0 6h2v-2h-2v2z"/></svg>
        </span>
      </label>
    
    <a href="./" title="C++20 の新機能" class="md-nav__link md-nav__link--active">
      C++20 の新機能
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="目次">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      目次
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    言語機能
  </a>
  
    <nav class="md-nav" aria-label="言語機能">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0683r1" class="md-nav__link">
    ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0704r1" class="md-nav__link">
    メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p1236r1" class="md-nav__link">
    符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)
  </a>
  
    <nav class="md-nav" aria-label="符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8-bit-2" class="md-nav__link">
    （参考）符号付き 8-bit 整数の 2 進表現
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-no_unique_address-p0840r2" class="md-nav__link">
    メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename-p0634r3" class="md-nav__link">
    型名であることが明らかな文脈で typename を省略可能に (P0634R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1064r0" class="md-nav__link">
    定数式での仮想関数呼び出しが可能に (P1064R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_id-dynamic_cast-constexpr-p1327r1" class="md-nav__link">
    type_id と dynamic_cast が constexpr に (P1327R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1330r0" class="md-nav__link">
    定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try-catch-p1002r1" class="md-nav__link">
    定数式の文脈では try-catch を無視するように (P1002R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deprecated-p1161r3" class="md-nav__link">
    添字式にかかるコンマ演算子の使用を deprecated に (P1161R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-p1099r5" class="md-nav__link">
    スコープ付き列挙型に対する using 宣言ができるように (P1099R5)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1771r1" class="md-nav__link">
    コンストラクタに [[nodiscard]] が使えるように (P1771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inline-namespace-p1094r2" class="md-nav__link">
    ネストした名前空間定義で inline namespace を使えるように (P1094R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#private-p0969r0" class="md-nav__link">
    本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった仕様を修正 (P0969R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1008r1" class="md-nav__link">
    ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 (P1008R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#throw-p0619r4" class="md-nav__link">
    throw() による動的例外指定を削除 (P0619R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1301r4" class="md-nav__link">
    メッセージ付きの [[nodiscard]] 属性 (P1301R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0329r4" class="md-nav__link">
    指示付き初期化子による集成体の初期化 (P0329R4)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    標準ライブラリ
  </a>
  
    <nav class="md-nav" aria-label="標準ライブラリ">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0457r2" class="md-nav__link">
    文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operatorbasic_istream-chart-chartn-p0487r1" class="md-nav__link">
    operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p0600r1" class="md-nav__link">
    戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-constexpr-p1023r0-p1032r1" class="md-nav__link">
    &lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chrono-zero-min-max-noexcept-p0972r0" class="md-nav__link">
    &lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointer_traits-constexpr-p1006r1" class="md-nav__link">
    pointer_traits が constexpr に (P1006R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assume_aligned-p1007r3" class="md-nav__link">
    ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make-p1020r1" class="md-nav__link">
    スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_type-p0919r3-p1690r1" class="md-nav__link">
    非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3), (P1690R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdmidpoint-p0811r3" class="md-nav__link">
    2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdlerp-p0811r3" class="md-nav__link">
    2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-p0754r2" class="md-nav__link">
    実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_nothrow_convertible-p0758r1" class="md-nav__link">
    例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdto_address-p0653r2" class="md-nav__link">
    ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-constexpr-p0415r1" class="md-nav__link">
    &lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_constant_evaluated-p0595r2" class="md-nav__link">
    コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0020r6" class="md-nav__link">
    浮動小数点数型のアトミック操作を拡張 (P0020R6)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmemory_order-enum-class-p0439r0" class="md-nav__link">
    std::memory_order を enum class に変更 (P0439R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-p0809r0" class="md-nav__link">
    Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0463r1" class="md-nav__link">
    実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cv-stdremove_cvref-trait-p0550r2" class="md-nav__link">
    型から cv 修飾と参照を除去する std::remove_cvref trait (P0550R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddecay-p0777r1" class="md-nav__link">
    標準ライブラリでの不必要な std::decay の使用を回避 (P0777R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numbers-p0631r8" class="md-nav__link">
    数学定数を提供する &lt;numbers&gt; ヘッダ (P0631R8)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basic_stringreserve-capacity-p0966r1" class="md-nav__link">
    basic_string::reserve() が capacity を縮小しないように (P0966R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constains-p0458r2" class="md-nav__link">
    連想コンテナに constains() メンバ関数を追加 (P0458R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stderase-stderase_if-p1209r0" class="md-nav__link">
    コンテナから指定した要素を削除する操作に一貫して使える std::erase(), std::erase_if() 関数 (P1209R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdbit_cast-p0476r2" class="md-nav__link">
    バイト列の再解釈キャストを補助する std::bit_cast() 関数 (P0476R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numeric-p0616r0" class="md-nav__link">
    &lt;numeric&gt; の関数の非効率な実装を改善 (P0616R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p0556r3-p1355r2-p1956r1" class="md-nav__link">
    2 の累乗数に関するユーティリティ関数を追加 (P0556R3), (P1355R2), (P1956R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdlist-stdforward_list-p0646r1" class="md-nav__link">
    std::list と std::forward_list の要素削除メンバ関数が、削除した要素数を返すように (P0646R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_bounded_array-stdis_unbounded_array-p1357r1" class="md-nav__link">
    要素数が決まっている配列型かどうかを調べる型特性 std::is_bounded_array, std::is_unbounded_array (P1357R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfunction-noexcept-p0771r1" class="md-nav__link">
    std::function のムーブコンストラクタが noexcept に (P0771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utility-algorithm-constexpr-p0202r3-p0879r0" class="md-nav__link">
    &lt;utility&gt;, &lt;algorithm&gt; の多くの関数が constexpr に (P0202R3), (P0879R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete-p0722r3" class="md-nav__link">
    デストラクタを自動で呼ばない delete 演算子オーバーロード (P0722R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0553r4" class="md-nav__link">
    ビット循環シフト・ビットカウント関数 (P0553R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdarray-stdto_array-p0325r4" class="md-nav__link">
    組み込み配列から std::array を作成する std::to_array() (P0325R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfilesystemcreate_directory-p1164r1" class="md-nav__link">
    std::filesystem::create_directory() の挙動を直感的に (P1164R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmake_shared-stdallocate_shared-p0674r1" class="md-nav__link">
    std::make_shared() と std::allocate_shared() が配列をサポート (P0674R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdshift_left-stdshift_right-p0769r2" class="md-nav__link">
    範囲の要素を左右にシフトする std::shift_left(), std::shift_right() 関数 (P0769R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdstring_view-p1391r4" class="md-nav__link">
    std::string_view のコンストラクタに、範囲のイテレータペアを受け取るオーバーロードを追加 (P1391R4)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../cppx/" title="C++23 以降に向けた提案" class="md-nav__link">
      C++23 以降に向けた提案
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../meetings/" title="標準化会議" class="md-nav__link">
      標準化会議
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../status/" title="処理系の対応状況" class="md-nav__link">
      処理系の対応状況
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../working-drafts/" title="C++ 規格書" class="md-nav__link">
      C++ 規格書
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../header/" title="C++ 標準ライブラリ" class="md-nav__link">
      C++ 標準ライブラリ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../npaperbot/" title="C++ 文書検索 bot" class="md-nav__link">
      C++ 文書検索 bot
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      記事
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="記事" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        記事
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/comment-tricks/" title="コメントアウトのトリック" class="md-nav__link">
      コメントアウトのトリック
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/it-compiles/" title="なぜかコンパイルできる" class="md-nav__link">
      なぜかコンパイルできる
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/it-does-not-compile/" title="なぜかコンパイルできない" class="md-nav__link">
      なぜかコンパイルできない
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/how-to-read-keywords/" title="予約語の読みと名前の由来" class="md-nav__link">
      予約語の読みと名前の由来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/how-to-read-libraries/" title="標準ライブラリの読みと名前の由来" class="md-nav__link">
      標準ライブラリの読みと名前の由来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/ieee754-arithmetic/" title="IEEE 754 演算のルール" class="md-nav__link">
      IEEE 754 演算のルール
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/acronyms/" title="C++ 関連の略語" class="md-nav__link">
      C++ 関連の略語
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/type-traits/" title="C++ 型特性 早見表" class="md-nav__link">
      C++ 型特性 早見表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/member-access/" title="C++ アクセス指定子の効果" class="md-nav__link">
      C++ アクセス指定子の効果
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      学習
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="学習" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        学習
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/books/" title="C++ 書籍" class="md-nav__link">
      C++ 書籍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/online-resources/" title="C++ オンライン資料" class="md-nav__link">
      C++ オンライン資料
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/blogs/" title="C++ ブログ集" class="md-nav__link">
      C++ ブログ集
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/studymeetings/" title="国内の C++ 勉強会" class="md-nav__link">
      国内の C++ 勉強会
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/communities/" title="C++ コミュニティ" class="md-nav__link">
      C++ コミュニティ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/conferences/" title="C++ カンファレンス" class="md-nav__link">
      C++ カンファレンス
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      ライブラリ
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="ライブラリ" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        ライブラリ
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/boost/" title="Boost" class="md-nav__link">
      Boost
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/containers/" title="コンテナ" class="md-nav__link">
      コンテナ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/text-data/" title="テキストデータ" class="md-nav__link">
      テキストデータ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/concurrency/" title="並行・並列" class="md-nav__link">
      並行・並列
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/testing/" title="テストフレームワーク" class="md-nav__link">
      テストフレームワーク
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/math/" title="数学" class="md-nav__link">
      数学
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      ツール
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="ツール" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        ツール
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/onlinecompilers/" title="C++ オンラインコンパイラ" class="md-nav__link">
      C++ オンラインコンパイラ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/compilers/" title="C++ コンパイラ" class="md-nav__link">
      C++ コンパイラ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/package-manager/" title="C++ パッケージマネージャ" class="md-nav__link">
      C++ パッケージマネージャ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/code-formatter/" title="C++ コードフォーマッタ" class="md-nav__link">
      C++ コードフォーマッタ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/project-template/" title="C++ プロジェクトテンプレート" class="md-nav__link">
      C++ プロジェクトテンプレート
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      貢献
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="貢献" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        貢献
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../contribution/contributors/" title="コントリビュータ" class="md-nav__link">
      コントリビュータ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目次">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      目次
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    言語機能
  </a>
  
    <nav class="md-nav" aria-label="言語機能">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0683r1" class="md-nav__link">
    ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0704r1" class="md-nav__link">
    メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p1236r1" class="md-nav__link">
    符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)
  </a>
  
    <nav class="md-nav" aria-label="符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8-bit-2" class="md-nav__link">
    （参考）符号付き 8-bit 整数の 2 進表現
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-no_unique_address-p0840r2" class="md-nav__link">
    メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename-p0634r3" class="md-nav__link">
    型名であることが明らかな文脈で typename を省略可能に (P0634R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1064r0" class="md-nav__link">
    定数式での仮想関数呼び出しが可能に (P1064R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_id-dynamic_cast-constexpr-p1327r1" class="md-nav__link">
    type_id と dynamic_cast が constexpr に (P1327R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1330r0" class="md-nav__link">
    定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try-catch-p1002r1" class="md-nav__link">
    定数式の文脈では try-catch を無視するように (P1002R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deprecated-p1161r3" class="md-nav__link">
    添字式にかかるコンマ演算子の使用を deprecated に (P1161R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-p1099r5" class="md-nav__link">
    スコープ付き列挙型に対する using 宣言ができるように (P1099R5)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1771r1" class="md-nav__link">
    コンストラクタに [[nodiscard]] が使えるように (P1771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inline-namespace-p1094r2" class="md-nav__link">
    ネストした名前空間定義で inline namespace を使えるように (P1094R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#private-p0969r0" class="md-nav__link">
    本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった仕様を修正 (P0969R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1008r1" class="md-nav__link">
    ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 (P1008R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#throw-p0619r4" class="md-nav__link">
    throw() による動的例外指定を削除 (P0619R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1301r4" class="md-nav__link">
    メッセージ付きの [[nodiscard]] 属性 (P1301R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0329r4" class="md-nav__link">
    指示付き初期化子による集成体の初期化 (P0329R4)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    標準ライブラリ
  </a>
  
    <nav class="md-nav" aria-label="標準ライブラリ">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0457r2" class="md-nav__link">
    文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operatorbasic_istream-chart-chartn-p0487r1" class="md-nav__link">
    operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p0600r1" class="md-nav__link">
    戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-constexpr-p1023r0-p1032r1" class="md-nav__link">
    &lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chrono-zero-min-max-noexcept-p0972r0" class="md-nav__link">
    &lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointer_traits-constexpr-p1006r1" class="md-nav__link">
    pointer_traits が constexpr に (P1006R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assume_aligned-p1007r3" class="md-nav__link">
    ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make-p1020r1" class="md-nav__link">
    スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_type-p0919r3-p1690r1" class="md-nav__link">
    非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3), (P1690R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdmidpoint-p0811r3" class="md-nav__link">
    2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdlerp-p0811r3" class="md-nav__link">
    2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-p0754r2" class="md-nav__link">
    実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_nothrow_convertible-p0758r1" class="md-nav__link">
    例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdto_address-p0653r2" class="md-nav__link">
    ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-constexpr-p0415r1" class="md-nav__link">
    &lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_constant_evaluated-p0595r2" class="md-nav__link">
    コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0020r6" class="md-nav__link">
    浮動小数点数型のアトミック操作を拡張 (P0020R6)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmemory_order-enum-class-p0439r0" class="md-nav__link">
    std::memory_order を enum class に変更 (P0439R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-p0809r0" class="md-nav__link">
    Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0463r1" class="md-nav__link">
    実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cv-stdremove_cvref-trait-p0550r2" class="md-nav__link">
    型から cv 修飾と参照を除去する std::remove_cvref trait (P0550R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddecay-p0777r1" class="md-nav__link">
    標準ライブラリでの不必要な std::decay の使用を回避 (P0777R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numbers-p0631r8" class="md-nav__link">
    数学定数を提供する &lt;numbers&gt; ヘッダ (P0631R8)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basic_stringreserve-capacity-p0966r1" class="md-nav__link">
    basic_string::reserve() が capacity を縮小しないように (P0966R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constains-p0458r2" class="md-nav__link">
    連想コンテナに constains() メンバ関数を追加 (P0458R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stderase-stderase_if-p1209r0" class="md-nav__link">
    コンテナから指定した要素を削除する操作に一貫して使える std::erase(), std::erase_if() 関数 (P1209R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdbit_cast-p0476r2" class="md-nav__link">
    バイト列の再解釈キャストを補助する std::bit_cast() 関数 (P0476R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numeric-p0616r0" class="md-nav__link">
    &lt;numeric&gt; の関数の非効率な実装を改善 (P0616R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p0556r3-p1355r2-p1956r1" class="md-nav__link">
    2 の累乗数に関するユーティリティ関数を追加 (P0556R3), (P1355R2), (P1956R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdlist-stdforward_list-p0646r1" class="md-nav__link">
    std::list と std::forward_list の要素削除メンバ関数が、削除した要素数を返すように (P0646R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_bounded_array-stdis_unbounded_array-p1357r1" class="md-nav__link">
    要素数が決まっている配列型かどうかを調べる型特性 std::is_bounded_array, std::is_unbounded_array (P1357R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfunction-noexcept-p0771r1" class="md-nav__link">
    std::function のムーブコンストラクタが noexcept に (P0771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utility-algorithm-constexpr-p0202r3-p0879r0" class="md-nav__link">
    &lt;utility&gt;, &lt;algorithm&gt; の多くの関数が constexpr に (P0202R3), (P0879R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete-p0722r3" class="md-nav__link">
    デストラクタを自動で呼ばない delete 演算子オーバーロード (P0722R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0553r4" class="md-nav__link">
    ビット循環シフト・ビットカウント関数 (P0553R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdarray-stdto_array-p0325r4" class="md-nav__link">
    組み込み配列から std::array を作成する std::to_array() (P0325R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfilesystemcreate_directory-p1164r1" class="md-nav__link">
    std::filesystem::create_directory() の挙動を直感的に (P1164R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmake_shared-stdallocate_shared-p0674r1" class="md-nav__link">
    std::make_shared() と std::allocate_shared() が配列をサポート (P0674R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdshift_left-stdshift_right-p0769r2" class="md-nav__link">
    範囲の要素を左右にシフトする std::shift_left(), std::shift_right() 関数 (P0769R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdstring_view-p1391r4" class="md-nav__link">
    std::string_view のコンストラクタに、範囲のイテレータペアを受け取るオーバーロードを追加 (P1391R4)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <h1 id="c20">C++20 の新機能<a class="headerlink" href="#c20" title="Permanent link">&para;</a></h1>
<p>C++20 の変更すべてをカバーするために、項目追加・執筆作業中です（完成度 約 30%）</p>
<h2 id="_1">言語機能<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h3 id="p0683r1">ビットフィールドにデフォルトの初期値を設定可能に <a href="http://wg21.link/p0683r1">(P0683R1)</a><a class="headerlink" href="#p0683r1" title="Permanent link">&para;</a></h3>
<p>ビットフィールドにおけるビット幅の指定に続いて、<code>=</code> 演算子または <code>{}</code> 初期化子を使って初期化式を記述できるようになります。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">char</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Forest</span><span class="p">,</span> <span class="n">Hill</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">Desert</span><span class="p">,</span> <span class="n">Tundra</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Tile</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">height</span> <span class="p">:</span> <span class="mi">4</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// デフォルト値を 1 に</span>
    <span class="n">Terrain</span> <span class="nl">terrain</span> <span class="p">:</span> <span class="mi">3</span> <span class="o">=</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Open</span><span class="p">;</span> <span class="c1">// デフォルト値を明示的に Terrain::Open に</span>
    <span class="kt">bool</span> <span class="nl">passable</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// デフォルト値を true に</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="n">Tile</span> <span class="n">tile1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile1</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile1</span><span class="p">.</span><span class="n">terrain</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tile1</span><span class="p">.</span><span class="n">passable</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">Tile</span> <span class="n">tile2</span><span class="p">{</span> <span class="mi">15</span><span class="p">,</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">,</span> <span class="nb">false</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile2</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile2</span><span class="p">.</span><span class="n">terrain</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tile2</span><span class="p">.</span><span class="n">passable</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>1, 0, true
15, 3, false
</code></pre></div></p>
<h3 id="p0704r1">メンバポインタ演算子の仕様を一貫性のために修正 <a href="http://wg21.link/p0704r1">(P0704R1)</a><a class="headerlink" href="#p0704r1" title="Permanent link">&para;</a></h3>
<p>C++17 までのメンバポインタ演算子 <code>.*</code> は「右辺値オブジェクトから、左辺値参照修飾されたメンバ関数ポインタに使うことは不適格」という規格文面になっていました。そのため、同じ意味をもつ次の 2 つのプログラムで後者だけ不適格とされ、一貫性がありませんでした。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Text</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_data</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Text</span><span class="p">{</span> <span class="s">&quot;Hello&quot;</span> <span class="p">}.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">Text</span><span class="p">{</span> <span class="s">&quot;Hello&quot;</span> <span class="p">}.</span><span class="o">*&amp;</span><span class="n">Text</span><span class="o">::</span><span class="n">get</span><span class="p">)()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// C++17 までは不適格、C++20 から OK</span>
<span class="p">}</span>
</code></pre></div>
C++20 では「右辺値オブジェクトから、左辺値参照修飾された "非 const" メンバ関数ポインタに使うことは不適格」と文面を修正し、後者もコンパイルできるようになります。</p>
<h3 id="2-p1236r1">符号付き整数型の負数表現を 2 の補数と規定 <a href="http://wg21.link/p1236r1">(P1236R1)</a><a class="headerlink" href="#2-p1236r1" title="Permanent link">&para;</a></h3>
<p>ほぼすべての現代的なコンピュータで、符号付き整数型の負数は 2 の補数で表現されます。しかし、C++ では負数の表現方法について規格で定めていなかったため、（現実的ではありませんが）2 の補数以外で負数表現を実装する余地も残されていました。C++20 からは 2 の補数のみを許可するよう規格文言が修正されました。<br />
近年のアーキテクチャで 2 の補数以外を使う例は、1 の補数を使う Unisys 2200 があります。また過去には符号と絶対値で表現するアーキテクチャもありました。これらはモダンな C++ を開発環境として使用しないので、この規格変更による影響は無いと考えられます。</p>
<h4 id="8-bit-2">（参考）符号付き 8-bit 整数の 2 進表現<a class="headerlink" href="#8-bit-2" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>10 進表現</th>
<th>2 の補数</th>
<th>1 の補数</th>
<th>符号と絶対値</th>
</tr>
</thead>
<tbody>
<tr>
<td>127</td>
<td>01111111</td>
<td>01111111</td>
<td>01111111</td>
</tr>
<tr>
<td>126</td>
<td>01111110</td>
<td>01111110</td>
<td>01111110</td>
</tr>
<tr>
<td>125</td>
<td>01111101</td>
<td>01111101</td>
<td>01111101</td>
</tr>
<tr>
<td>2</td>
<td>00000010</td>
<td>00000010</td>
<td>00000010</td>
</tr>
<tr>
<td>1</td>
<td>00000001</td>
<td>00000001</td>
<td>00000001</td>
</tr>
<tr>
<td>0</td>
<td>00000000</td>
<td>00000000</td>
<td>00000000</td>
</tr>
<tr>
<td>-0</td>
<td></td>
<td>11111111</td>
<td>10000000</td>
</tr>
<tr>
<td>-1</td>
<td>11111111</td>
<td>11111110</td>
<td>10000001</td>
</tr>
<tr>
<td>-2</td>
<td>11111110</td>
<td>11111101</td>
<td>10000010</td>
</tr>
<tr>
<td>-126</td>
<td>10000010</td>
<td>10000001</td>
<td>11111110</td>
</tr>
<tr>
<td>-127</td>
<td>10000001</td>
<td>10000000</td>
<td>11111111</td>
</tr>
<tr>
<td>-128</td>
<td>10000000</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="0-no_unique_address-p0840r2">メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる <code>[[no_unique_address]]</code> 属性を追加 <a href="http://wg21.link/p0840r2">(P0840R2)</a><a class="headerlink" href="#0-no_unique_address-p0840r2" title="Permanent link">&para;</a></h3>
<p>アロケータなどをクラスのメンバとして保持するとき、それがステートレスな空のクラスであってもオブジェクトのアドレスを一意に用意しないといけないため、サイズを 0 にできずメモリ消費が無駄に増えてしまう問題がありました。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4 より大きい</span>
<span class="p">}</span>
</code></pre></div>
これを回避するために「空の基底クラスは最適化によってサイズ 0 にしてよい」という仕様を利用した Empty Base Optimization (EBO) というテクニックがあり、標準ライブラリでも　<code>std::unique_ptr</code> や <code>std::shared_ptr</code>, <code>std::vector</code> などに使われています。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">X</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Empty</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div>
しかし、これらのクラスで継承による EBO を実装するとコードが複雑になるという欠点がありました。C++20 ではメンバの宣言に <code>[[no_unique_address]]</code> 属性を付けることで、継承を使わなくてもコンパイラが EBO と同じような最適化をできるようになり、従来の継承による EBO を使っていたコードを、より単純なコードに置き換えられます。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span> <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="typename-p0634r3">型名であることが明らかな文脈で <code>typename</code> を省略可能に <a href="https://wg21.link/P0634R3">(P0634R3)</a><a class="headerlink" href="#typename-p0634r3" title="Permanent link">&para;</a></h3>
<p>C++17 で依存名が型である場合に <code>typename</code> を付けないのは、派生クラス定義時の基底クラスの指定と、初期化子リストでの基底クラスの指定のみでした（厳密にはこの 2 つには <code>typename</code> を付けられません）。C++20 では、型名しか使えないさらにいくつかの文脈で <code>typename</code> が省略可能になります。次のサンプルコードの左右タブで比較できます。</p>
<div class="tabbed-set" data-tabs="1:2">
<input name="__tabbed_1" type="radio" id="__tabbed_1_1" checked="checked" /><label for="__tabbed_1_1">C++17</label><div class="tabbed-content"><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">S</span> <span class="p">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="c1">// 派生クラス定義時の基底クラスの指定</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>

    <span class="n">S</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 初期化子リストでの基底クラスの指定</span>

    <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">pointer</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">min_size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">MaxSize</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<input name="__tabbed_1" type="radio" id="__tabbed_1_2" /><label for="__tabbed_1_2">C++20</label><div class="tabbed-content"><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;</span> <span class="c1">// OK</span>
<span class="k">struct</span> <span class="nl">S</span> <span class="p">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="c1">// 派生クラス定義時の基底クラスの指定</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="n">S</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 初期化子リストでの基底クラスの指定</span>

    <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">T</span><span class="o">::</span><span class="n">pointer</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="nf">min_size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// OK</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">MaxSize</span><span class="p">();</span> <span class="c1">// OK</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
</div>
<h3 id="p1064r0">定数式での仮想関数呼び出しが可能に <a href="https://wg21.link/P1064">(P1064R0)</a><a class="headerlink" href="#p1064r0" title="Permanent link">&para;</a></h3>
<p>コンパイル時に決定可能であれば、参照やポインタを通した仮想関数の呼び出しを <code>constexpr</code> にできるようになります。<code>constexpr</code> 修飾された仮想関数を非 <code>constexpr</code> 関数でオーバーライドすることや、その逆も可能です。</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">GetVersion</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">version</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">Cpp20</span> <span class="n">cpp20</span><span class="p">;</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetVersion</span><span class="p">(</span><span class="n">cpp17</span><span class="p">)</span> <span class="o">==</span> <span class="mi">17</span><span class="p">);</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetVersion</span><span class="p">(</span><span class="n">cpp20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="type_id-dynamic_cast-constexpr-p1327r1"><code>type_id</code> と <code>dynamic_cast</code> が constexpr に <a href="https://wg21.link/P1327">(P1327R1)</a><a class="headerlink" href="#type_id-dynamic_cast-constexpr-p1327r1" title="Permanent link">&para;</a></h3>
<p><code>dynamic_cast</code> と <code>type_id</code> が、例外を投げるケースを除いて <code>constexpr</code> になります。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">*</span> <span class="n">pCpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cpptype</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">pCpp</span><span class="p">);</span>

    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">refCpp</span> <span class="o">=</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp17</span><span class="o">&amp;</span> <span class="n">redCpp2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpp17</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">refCpp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>次のように例外を投げるケースでは <code>constexpr</code> にできずコンパイルエラーになります。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Cpp</span><span class="o">*</span> <span class="n">pCpp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cpptype</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">pCpp</span><span class="p">);</span> <span class="c1">//コンパイルエラー: 例外 std::bad_typeid を投げるため constexpr 不可</span>

    <span class="k">constexpr</span> <span class="k">static</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">refCpp</span> <span class="o">=</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp20</span><span class="o">&amp;</span> <span class="n">redCpp2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpp20</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">refCpp</span><span class="p">);</span> <span class="c1">// コンパイルエラー: 例外 std::bad_cast を投げるため constexpr 不可</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="p1330r0">定数式において共用体のアクティブメンバの切り替えが可能に <a href="https://wg21.link/P1330">(P1330R0)</a><a class="headerlink" href="#p1330r0" title="Permanent link">&para;</a></h3>
<p>共用体のアクティブメンバとは、最後に初期化または値を代入したメンバのことです。C++17 では共用体の初期化やアクティブメンバへのアクセスを定数式で行えましたが、アクティブメンバの切り替えはできませんでした。定数式でのアクティブメンバの切り替えが可能になると、共用体によって実装される <code>std::string</code> や <code>std::optional</code> などの標準ライブラリクラスのメンバ関数の <code>constexpr</code> 対応を拡充できます。非アクティブメンバへのアクセスは未定義動作なので、定数式で行うとコンパイルエラーになります。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>

<span class="k">union</span> <span class="n">Value</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">Value</span> <span class="nf">GetFloat</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Value</span><span class="p">{</span> <span class="n">x</span> <span class="p">};</span> <span class="c1">// value.f がアクティブメンバ</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">Value</span> <span class="nf">GetUint</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Value</span> <span class="n">value</span> <span class="o">=</span> <span class="n">GetFloat</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span> <span class="c1">// value.f がアクティブメンバ</span>
    <span class="n">value</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// value.i がアクティブメンバに</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetUint</span><span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="n">i</span> <span class="o">==</span> <span class="mi">123</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="try-catch-p1002r1">定数式の文脈では <code>try-catch</code> を無視するように <a href="https://wg21.link/P1002">(P1002R1)</a><a class="headerlink" href="#try-catch-p1002r1" title="Permanent link">&para;</a></h3>
<p>これまで <code>constexpr</code> 関数の中には <code>try-catch</code> ブロックを書くことができませんでした。しかし、<code>std::vector</code> 等のコンテナを <code>constexpr</code> 対応するにあたっては、この制限が障壁となるため、C++20 では <code>constexpr</code> 関数の中の <code>try-catch</code> は、定数式として評価されるときには無視するよう仕様が改められます。定数式の評価中に例外を投げるようであればコンパイルエラーになります。<code>std::vector</code> などを <code>constexpr</code> 対応させるための措置であり、将来の C++ におけるコンパイル時例外処理の実現を否定するものではありません。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt; </span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt; </span><span class="cp"></span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">AddU8</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">{};</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">DoubleU8</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">AddU8</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">except</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">DoubleU8</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span> <span class="o">==</span> <span class="mi">246</span><span class="p">);</span> <span class="c1">// OK: 例外を投げずに定数式として評価可能</span>

    <span class="c1">//static_assert(DoubleU8(200) &gt; 0); // コンパイルエラー: 定数式として評価される constexpr 関数内で例外を投げるため</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;result: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">DoubleU8</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// OK: 実行時に評価される関数で例外が発生する</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="deprecated-p1161r3">添字式にかかるコンマ演算子の使用を deprecated に <a href="https://wg21.link/P1161R3">(P1161R3)</a><a class="headerlink" href="#deprecated-p1161r3" title="Permanent link">&para;</a></h3>
<p>これまで <code>array[x, y]</code> というコードでは、コンマ演算子の作用で <code>y</code> が添字演算の引数として渡されました。しかし、この挙動は紛らわしく、将来の C++ 標準ライブラリに多次元配列クラスが実装されたとき、添字演算子を複数の引数に対応させるような規格を追加するうえでの障壁にもなります。そのため、C++20 から、<code>array[(x, y)]</code> のように括弧を使用する場合をのぞき、添字式にかかるコンマ演算子の使用が deprecated になります。古いコードで deprecated な書き方をしていた場合、前述のように <code>()</code> を付けることで、コードの挙動に影響を与えずに移植が可能です。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">v</span><span class="p">[</span><span class="o">++</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// C++17 まで OK, C++20 から deprecated</span>

    <span class="n">v</span><span class="p">[(</span><span class="o">++</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="using-p1099r5">スコープ付き列挙型に対する using 宣言ができるように <a href="http://wg21.link/p1099r5">(P1099R5)</a><a class="headerlink" href="#using-p1099r5" title="Permanent link">&para;</a></h3>
<p>これまでは、enum class のスコープ解決を省略する方法が無く、次のような <code>switch</code> で、列挙型の名前が何度も登場するようなコードを書く必要があり、読みにくく、長い列挙型の名前が避けられる原因になっていました。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span> <span class="n">terrain</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view_literals</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">terrain</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Open</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;Open&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Mountain</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;Mountain&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">River</span><span class="p">:</span>    <span class="k">return</span> <span class="s">&quot;River&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Ocean</span><span class="p">:</span>    <span class="k">return</span> <span class="s">&quot;Ocean&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>                <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
C++20 では <code>using</code> 宣言を拡張し、<code>using Terrain::Open;</code> で <code>Open</code> をエイリアスとして使えるようになります。また <code>using enum</code> 宣言という新しい仕組みにより、<code>using enum Terrain;</code> で <code>Terrain</code> がローカルスコープに導入され、スコープ解決演算子を使わずにその列挙子を使えるようになります。
<div class="highlight"><pre><span></span><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span> <span class="n">terrain</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view_literals</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">terrain</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">Terrain</span><span class="p">;</span> <span class="c1">// using enum 宣言で、列挙型の名前 Terrain をローカルスコープに導入</span>
    <span class="k">case</span> <span class="nl">Open</span><span class="p">:</span>      <span class="k">return</span> <span class="s">&quot;Open&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Mountain</span><span class="p">:</span>  <span class="k">return</span> <span class="s">&quot;Mountain&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">River</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;River&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Ocean</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;Ocean&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">;</span> <span class="c1">// using 宣言で、列挙子 Mountain をローカルスコープに導入</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Mountain</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
なお、次のように複数の <code>using</code> 宣言によって名前の衝突が起こる場合はコンパイルエラーになります。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">State</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Closed</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">Terrain</span><span class="p">;</span> <span class="c1">// OK</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">State</span><span class="p">;</span>   <span class="c1">// コンパイルエラー: Terrain::Open と State::Open の名前が衝突</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="nodiscard-p1771r1">コンストラクタに <code>[[nodiscard]]</code> が使えるように <a href="http://wg21.link/p1771r1">(P1771R1)</a><a class="headerlink" href="#nodiscard-p1771r1" title="Permanent link">&para;</a></h3>
<p>C++17 で <code>[[nodiscard]]</code> が導入された際、仕様ではコンストラクタを対象としていませんでした（ただし、GCC では警告を出しつつもコンストラクタに付けた <code>[[nodiscard]]</code> をチェックしていました）。コンストラクタの呼び出しによって作成された一時オブジェクトが意図せず無視されたときに警告を出せると、ユーザの間違いを減らせます。そこで、コンストラクタにも <code>[[nodiscard]]</code> 属性を付けられるよう、C++17 向けの規格にさかのぼって仕様が修正され、C++20 および、この変更に対応した C++17 コンパイラで新仕様を利用できるようになります。なお、デストラクタを定義していた場合でも警告は消えません。
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="n">Circle</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

    <span class="n">Circle</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_r</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">),</span> <span class="n">r</span><span class="p">(</span><span class="n">_r</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Circle</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span> <span class="c1">// warning: nodiscard 属性のコンストラクタで作成された一時オブジェクトを無視</span>

    <span class="n">Circle</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">50</span><span class="p">).</span><span class="n">draw</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="inline-namespace-p1094r2">ネストした名前空間定義で <code>inline namespace</code> を使えるように <a href="http://wg21.link/p1094r2">(P1094R2)</a><a class="headerlink" href="#inline-namespace-p1094r2" title="Permanent link">&para;</a></h3>
<p>C++17 でネストした名前空間定義が導入されましたが、その中では <code>inline namespace</code> を使うことができず、<code>inline namespace</code> が <code>namespace</code> 内にある次のようなケースで恩恵を受けられませんでした。C++20 からはネストした名前空間定義の中で <code>inline</code> を使えるようになります。</p>
<div class="tabbed-set" data-tabs="2:2">
<input name="__tabbed_2" type="radio" id="__tabbed_2_1" checked="checked" /><label for="__tabbed_2_1">C++17</label><div class="tabbed-content"><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">mylib</span>
<span class="p">{</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">v2</span>
    <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">util</span>
        <span class="p">{</span>
            <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v2</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// v2</span>
<span class="p">}</span>
</code></pre></div></div>
<input name="__tabbed_2" type="radio" id="__tabbed_2_2" /><label for="__tabbed_2_2">C++20</label><div class="tabbed-content"><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="kr">inline</span> <span class="n">v2</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v2</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// v2</span>
<span class="p">}</span>
</code></pre></div></div>
</div>
<h3 id="private-p0969r0">本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった仕様を修正 <a href="https://wg21.link/P0969R0">(P0969R0)</a><a class="headerlink" href="#private-p0969r0" title="Permanent link">&para;</a></h3>
<p>メンバ関数内で自身の <code>private</code> メンバにアクセスすることや、<code>friend</code> 指定された関数で該当クラスの <code>private</code> メンバ変数にアクセスすることは通常可能ですが、C++17 の構造化束縛はクラスの <code>public</code> メンバにしかバインドできないという規格文面の制約があり、次のようなケースで一貫性がありませんでした。この制約を課す合理的な理由は無かったため、C++17 向けの規格にさかのぼって仕様が修正され、アクセス可能であれば <code>private</code> メンバ変数をバインドできるようになります。C++20 および、この変更に対応した C++17 コンパイラで新仕様を利用できます。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Date</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>

    <span class="kt">int</span> <span class="n">m_year</span><span class="p">,</span> <span class="n">m_month</span><span class="p">,</span> <span class="n">m_day</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

    <span class="k">friend</span> <span class="kt">void</span> <span class="n">Work</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">date</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="c1">// OK</span>
        <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_year</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_month</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_day</span><span class="p">;</span>

        <span class="c1">// これまではコンパイルエラー, C++20 以降 OK</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// friend 指定されている関数</span>
<span class="kt">void</span> <span class="nf">Work</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">date</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// OK</span>
    <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_year</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_month</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_day</span><span class="p">;</span>

    <span class="c1">// これまではコンパイルエラー, C++20 以降 OK</span>
    <span class="k">auto</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">date</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre></div>

<h3 id="p1008r1">ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 <a href="https://wg21.link/P1008R1">(P1008R1)</a><a class="headerlink" href="#p1008r1" title="Permanent link">&para;</a></h3>
<p>C++17 までは集成体の要件が緩かったため、コンストラクタについては、デフォルトコンストラクタが <code>= delete</code> または <code>private</code> であっても、集成体初期化によって初期化できる抜け道がありました。これはメンバ変数が意図しない値で初期化されるといった問題を引き起こします。C++20 からは集成体の要件が厳しくなり、ユーザ宣言されたコンストラクタがあるクラスは集成体にはなりません。</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">B</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">C</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">;</span> <span class="c1">// コンパイルエラー</span>
    <span class="n">A</span> <span class="n">a2</span><span class="p">{};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>

    <span class="n">B</span> <span class="n">b1</span><span class="p">;</span> <span class="c1">// コンパイルエラー</span>
    <span class="n">B</span> <span class="n">b2</span><span class="p">{};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>

    <span class="n">C</span> <span class="n">c1</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">//コンパイルエラー</span>
    <span class="n">C</span> <span class="n">c2</span><span class="p">{</span> <span class="mi">123</span> <span class="p">};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="throw-p0619r4"><code>throw()</code> による動的例外指定を削除 <a href="https://wg21.link/P0619R4">(P0619R4)</a><a class="headerlink" href="#throw-p0619r4" title="Permanent link">&para;</a></h3>
<p>C++11 では、<code>noexcept</code> の追加に合わせ、<code>throw(typeid, ...)</code> や <code>throw()</code> による動的例外指定が非推奨化されました。C++17 では前者が削除されましたが、古いコードにおいて広く使われていた後者は、移行猶予のために <code>noexcept(true)</code> のエイリアスとして改められつつ保持されていました。C++20 では後者も削除されます。</p>
<h3 id="nodiscard-p1301r4">メッセージ付きの <code>[[nodiscard]]</code> 属性 <a href="https://wg21.link/P1301R4">(P1301R4)</a><a class="headerlink" href="#nodiscard-p1301r4" title="Permanent link">&para;</a></h3>
<p>C++17 で追加された <code>[[nodiscard]]</code> 属性は、ライブラリなどが提供する関数の誤用を防ぐ助けになりますが、関数がなぜ <code>[[nodiscard]]</code> 属性を持っているのかについて、利用者に十分な情報が伝わらない場合がありました。C++20 では <code>[[nodiscard("....")]]</code> のような形式でメッセージを追加できるようになります。戻り値の無視があった場合、コンパイラは警告に加えてこのメッセージを補足情報として出力できます。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Data</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_data</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_data</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">(</span><span class="s">&quot;Did you mean &#39;clear&#39;?&quot;</span><span class="p">)]]</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Data</span> <span class="n">data</span><span class="p">;</span>

    <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>コンパイラの出力例</p>
<div class="highlight"><pre><span></span><code>prog.cc:27:2: warning: ignoring return value of function declared with &#39;nodiscard&#39; attribute:
        Did you mean &#39;clear&#39;? [-Wunused-result]
        data.empty();
        ^~~~~~~~~~
1 warning generated.
</code></pre></div>

<h3 id="p0329r4">指示付き初期化子による集成体の初期化 <a href="https://wg21.link/P0329R4">(P0329R4)</a><a class="headerlink" href="#p0329r4" title="Permanent link">&para;</a></h3>
<p>C++20 から、集成体において、メンバ変数名を指定した初期化（指示付き初期化子を用いた初期化: "Designated Initialization" ）ができるようになります。C 言語 (C99) にも同様の機能がありますが、C++20 では C99 の指示付き初期化子と比較して以下のような制約が追加されています。</p>
<ul>
<li>(a) 指示子の順番はメンバの宣言順と同じである必要がある</li>
<li>(b) 指示付き初期化子と通常の初期化子の混在はできない</li>
<li>(c) 同一メンバの指示付き初期化子は複数回使えない</li>
<li>(d) 指示付き初期化子はネストできない</li>
<li>(e) 配列の指示付き初期化はできない</li>
</ul>
<p>また、初期化子の評価順序が左から右であることが保証されます。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Item</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">Point</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">};</span> <span class="c1">// OK</span>
    <span class="n">Point</span> <span class="n">p2</span><span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">};</span> <span class="c1">// OK</span>
    <span class="n">Point</span> <span class="n">p3</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">};</span> <span class="c1">// OK: y は 0 に初期化される</span>
    <span class="n">Point</span> <span class="n">p4</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">};</span> <span class="c1">// OK: x は 0 に初期化される</span>
    <span class="n">F</span><span class="p">({</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">});</span> <span class="c1">// OK</span>

    <span class="n">Point</span> <span class="n">p4</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">30</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (a) 指示子の順番がメンバの宣言順と異なる</span>
    <span class="n">Point</span> <span class="n">p5</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (b) 指示付き初期化子と通常の初期化子は混在できない</span>
    <span class="n">Point</span> <span class="n">p6</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">30</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (c) 同一メンバの指示付き初期化子は複数回登場できない</span>

    <span class="n">Item</span> <span class="n">i1</span><span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;shield&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span> <span class="c1">// OK</span>
    <span class="n">Item</span> <span class="n">i2</span><span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span> <span class="c1">// OK: name は {} で初期化、pos は { -1, -1 } で初期化</span>

    <span class="n">Item</span> <span class="n">i3</span><span class="p">{</span> <span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">40</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (d) 指示付き初期化子はネストできない</span>

    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (e) 配列の指示付き初期化はできない</span>
<span class="p">}</span>
</code></pre></div>

<p>従来までの <code>Point p{}</code>, <code>Item i{}</code> のような集成体初期化を「指示付き初期化子が 0 個の初期化」と考えると、新しい挙動も理解しやすくなります。なお、次のように集成体ではないクラスの初期化には、指示付き初期化子は使えません。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_y</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// コンパイルエラー:</span>
    <span class="c1">// ユーザ宣言されたコンストラクタを持つため集成体ではない</span>
    <span class="c1">// 集成体でないため指示付き初期化子を使えない</span>
    <span class="n">Point</span> <span class="n">p</span><span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">};</span> 
<span class="p">}</span>
</code></pre></div>

<h2 id="_2">標準ライブラリ<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="p0457r2">文字列の先頭や末尾が、ある文字列と一致するか判定 <a href="https://wg21.link/P0457R2">(P0457R2)</a><a class="headerlink" href="#p0457r2" title="Permanent link">&para;</a></h3>
<p><code>std::basic_string</code> と <code>std::basic_string_view</code> に、<code>starts_with()</code> と <code>ends_with()</code> メンバ関数が追加されます。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">HasPNGExtension</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">filePath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 文字列が &quot;.png&quot; で終わるなら true, それ以外は false を返す</span>
    <span class="k">return</span> <span class="n">filePath</span><span class="p">.</span><span class="n">ends_with</span><span class="p">(</span><span class="s">&quot;.png&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;picture.png&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;photo.jpg&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;music.mp3&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>true
false
false
</code></pre></div></p>
<h3 id="operatorbasic_istream-chart-chartn-p0487r1"><code>operator&gt;&gt;(basic_istream&amp;, charT*)</code> の第二引数を <code>charT(&amp;)[N]</code> に変更して安全に <a href="https://wg21.link/P0487R1">(P0487R1)</a><a class="headerlink" href="#operatorbasic_istream-chart-chartn-p0487r1" title="Permanent link">&para;</a></h3>
<p>C++17 までの <code>operator&gt;&gt;(basic_istream&amp;, charT*)</code> は、関数にバッファのサイズが渡されないため、次のようなプログラムでバッファオーバーフローへの対策が必要でした。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="c1">// std::cin &gt;&gt; buffer; // 危険: バッファオーバーフローの可能性</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// OK: バッファオーバーフロー対策</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
C++20 では引数を次のように変更し、関数がバッファオーバーフローの対策を実装するようになります。
<div class="highlight"><pre><span></span><code><span class="c1">// C++17 まで</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span><span class="o">&gt;</span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">charT</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>

<span class="c1">// C++20 から</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">charT</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)[</span><span class="n">N</span><span class="p">]);</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// OK: C++20 ではバッファオーバーフローを防げる</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
この変更に伴い、C++17 までは有効だった次のようなプログラムが、C++20 からコンパイルエラーになります。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// C++20 からはコンパイルエラー</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="nodiscard-p0600r1">戻り値の無視が不具合をもたらす関数に <code>[[nodiscard]]</code> を付与 <a href="https://wg21.link/P0600R1">(P0600R1)</a><a class="headerlink" href="#nodiscard-p0600r1" title="Permanent link">&para;</a></h3>
<p>C++17 で導入された <code>[[nodiscard]]</code> 属性を標準ライブラリで活用するようになります。C++20 では付与基準を「戻り値の無視がトラブルやメモリリークなどの重大なエラーを引き起こす C++ の関数」とし、<code>async()</code>, <code>launder()</code>, <code>allocate()</code>, <code>empty()</code>, <code>operator new()</code> が対象となっています。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>

    <span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// C++20 では警告</span>

    <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// C++20 では警告</span>
<span class="p">}</span>
</code></pre></div>
MSVC の標準ライブラリでは Visual Studio 2017 15.6 以降、規格の範囲を超えてより多くの関数（<a href="https://devblogs.microsoft.com/cppblog/c17-progress-in-vs-2017-15-5-and-15-6/">2,500 個以上</a>）に <code>[[nodiscard]]</code> 属性を使っています。その結果、<a href="https://bugs.chromium.org/p/webrtc/issues/detail?id=8463">Chromium のソースに無意味な std::move() が見つかる</a>など、既存のコードベースのバグの発見に役立っています。</p>
<h3 id="array-constexpr-p1023r0-p1032r1"><code>&lt;array&gt;</code> ヘッダのすべての関数が constexpr に <a href="https://wg21.link/P1023R0">(P1023R0)</a>, <a href="https://wg21.link/P1032R1">(P1032R1)</a><a class="headerlink" href="#array-constexpr-p1023r0-p1032r1" title="Permanent link">&para;</a></h3>
<p>C++17 の <code>&lt;array&gt;</code> ヘッダでは、比較演算子、<code>swap()</code>, <code>fill()</code> 以外のすべての関数が constexpr でした。C++20 ではさらに、array の比較演算の実装に使われている <code>std::equal()</code> と <code>std::lexicographical_compare()</code> が <a href="https://wg21.link/P0202R3">constexpr になった (P0202R3)</a> ことにともない、array の比較演算子を constexpr とし、また <code>swap()</code> と <code>fill()</code> についても constexpr にすることを決め、array ヘッダのすべての関数が constexpr で提供されます。</p>
<h3 id="chrono-zero-min-max-noexcept-p0972r0"><code>&lt;chrono&gt;</code> ヘッダの <code>zero()</code>, <code>min()</code>, <code>max()</code> 関数が noexcept に <a href="https://wg21.link/P0972R0">(P0972R0)</a><a class="headerlink" href="#chrono-zero-min-max-noexcept-p0972r0" title="Permanent link">&para;</a></h3>
<p><code>std::chrono::duration_values</code>, <code>std::chrono::duration</code>, <code>std::chrono::time_point</code> などの <code>zero()</code>, <code>min()</code>, <code>max()</code> 関数に noexcept が付きます。</p>
<h3 id="pointer_traits-constexpr-p1006r1"><code>pointer_traits</code> が constexpr に <a href="https://wg21.link/P1006R1">(P1006R1)</a><a class="headerlink" href="#pointer_traits-constexpr-p1006r1" title="Permanent link">&para;</a></h3>
<p><code>std::vector</code> を constexpr にするのに必要なため、<code>std::pointer_traits::pointer_to()</code> 関数が constrexpr になります。</p>
<h3 id="assume_aligned-p1007r3">ポインタのアライメントを最適化ヒントとしてコンパイラに伝える <code>assume_aligned()</code> 関数 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1007r3.pdf">(P1007R3)</a><a class="headerlink" href="#assume_aligned-p1007r3" title="Permanent link">&para;</a></h3>
<p>データのアドレスが 16 バイトなどのサイズにアライメントされている場合、コンパイラが SIMD を使った最適なコードを生成できる可能性があります。あるポインタの指すデータがアライメントされていることをコンパイラに伝える方法として、GCC や Clang では <code>__builtin_assume_aligned()</code> や <code>__attribute__((assume_aligned(alignment)))</code>, ICC では <code>__assume_aligned()</code> などの独自拡張がありますが、標準化された方法はありませんでした。C++20 では、これらの差異を吸収する次のような関数テンプレートが提供されます。
<div class="highlight"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span><span class="o">*</span> <span class="n">assume_aligned</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</code></pre></div>
実際には次のように使います。
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">Multiply</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">factor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">assume_aligned</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x が 64 バイトアライメントであることを伝える</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// ループが適宜最適化される</span>
    <span class="p">{</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="make-p1020r1">スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 <a href="https://wg21.link/P1020R1">(P1020R1)</a><a class="headerlink" href="#make-p1020r1" title="Permanent link">&para;</a></h3>
<p>実行時性能のために、<code>float</code> や <code>unsigned char</code> など組み込み型の配列の値をデフォルト初期化させたい（ゼロ初期化しない）ケースがあります。しかし、<code>make_unique</code> や <code>make_shared</code>, <code>allocate_shared</code> でスマートポインタを作成した場合には値初期化が実行されます。C++20 では、値初期化をせずにデフォルト初期化でスマートポインタを作成する関数 <code>make_unique_default_init</code>, <code>make_shared_default_init</code>, <code>allocate_shared_default_init</code> が追加されました。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="c1">// 未初期化の変数を使う実験的なコード</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// デフォルト初期化</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">pv</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 値初期化 (0 初期化) </span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique_default_init</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// デフォルト初期化</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
出力例
<div class="highlight"><pre><span></span><code>2.20325e-38
4.11052e+32
1.3013e-45
2.48626e-38
0
0
0
0
2.30415e-38
2.51341e-38
4.63281e+30
2.32703e+17
</code></pre></div></p>
<h3 id="key_type-p0919r3-p1690r1">非順序連想コンテナのルックアップ操作で、<code>key_type</code> と比較可能な型を変換せずに使えるように <a href="http://wg21.link/P0919r3">(P0919R3)</a>, <a href="http://wg21.link/P1690R1">(P1690R1)</a><a class="headerlink" href="#key_type-p0919r3-p1690r1" title="Permanent link">&para;</a></h3>
<p>C++17 までの <code>unorderd_map</code> や <code>unordered_set</code> など非順序連想コンテナでは、<code>find()</code>, <code>count()</code>, <code>equal_range()</code> などルックアップを行うメンバ関数は引数に <code>key_type</code> をとり、例えば次のようなケースで <code>std::string</code> 型の一時オブジェクトが作成されて非効率でした。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトが作成される</span>
<span class="p">}</span>
</code></pre></div>

<p>C++20 では、非順序連想コンテナのテンプレートパラメータについて <code>Hash::is_transparent</code> と <code>Pred::is_transparent</code> が存在するときに、<code>key_type</code> 以外の型を引数にとるメンバ関数テンプレートのオーバーロードが使用可能になり、一時オブジェクトの作成を回避できるようになります。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">string_compare</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">is_transparent</span> <span class="o">=</span> <span class="kt">void</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">key</span> <span class="o">==</span> <span class="n">txt</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">string_hash</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">is_transparent</span> <span class="o">=</span> <span class="kt">void</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">transparent_key_equal</span> <span class="o">=</span> <span class="n">string_compare</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">hash_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// helper local type</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">string_hash</span><span class="p">,</span> <span class="n">string_compare</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトは作成されない</span>

    <span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="n">sv</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトは作成されない</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="2-stdmidpoint-p0811r3">2 つの値の中点を計算する <code>std::midpoint()</code> 関数 <a href="https://wg21.link/P0811R3">(P0811R3)</a><a class="headerlink" href="#2-stdmidpoint-p0811r3" title="Permanent link">&para;</a></h3>
<p>2 つの値 <code>a</code>, <code>b</code> の中点を計算する際に、単純な <code>(a + b) / 2</code> という式ではオーバーフローを起こす可能性があります。C++20 で追加される <code>std::midpoint()</code> 関数では、整数に対して
<div class="highlight"><pre><span></span><code><span class="k">constexpr</span> <span class="n">Integer</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">Integer</span> <span class="n">a</span><span class="p">,</span> <span class="n">Integer</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">U</span> <span class="o">=</span> <span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span> <span class="o">?</span> <span class="n">a</span><span class="o">-</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">:</span> <span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
のような実装が使われ、オーバーフローを回避できます。<code>(a + b)</code> が奇数になるケースの結果は <code>a</code> の方向に丸められます。<br />
浮動小数点数に対しては次のような実装が使われます。
<div class="highlight"><pre><span></span><code><span class="n">Float</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">Float</span> <span class="n">a</span><span class="p">,</span> <span class="n">Float</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">isnormal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isnormal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span> <span class="o">+</span> <span class="mi">1</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// オーバーフロー</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">2</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">,</span> <span class="mi">1</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 1500000000</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 2</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 3</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="2-stdlerp-p0811r3">2 つの値の線形補間を計算する <code>std::lerp()</code> 関数 <a href="https://wg21.link/P0811R3">(P0811R3)</a><a class="headerlink" href="#2-stdlerp-p0811r3" title="Permanent link">&para;</a></h3>
<p>2 点 <code>a</code>, <code>b</code> の間をパラメータ <code>t</code> によって線形補間する関数が提供されます。計算結果 <code>r</code> は <code>a + t * (b - a)</code> によって求められますが、実装により <code>isfinite(a) &amp;&amp; isfinite(b)</code> のとき</p>
<ul>
<li><code>lerp(a, b, 0) == a &amp;&amp; lerp(a, b, 1) == b</code></li>
<li><code>0 &lt;= t &amp;&amp; t &lt;= 1</code> のとき <code>isfinite(r)</code></li>
<li><code>isfinite(t) &amp;&amp; a == b</code> のとき <code>r == a</code></li>
<li><code>isfinite(t) || !isnan(t) &amp;&amp; (b - a) != 0</code> のとき <code>!isnan(r)</code></li>
</ul>
<p>また、<code>cmp(lerp(a,b,t2), lerp(a,b,t1)) * cmp(t2,t1) * cmp(b,a) &gt;= 0</code> (cmp は -1, 0, 1 を返す三方比較関数とする)<br />
であることが保証されます。
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 3</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 10</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 12</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="version-p0754r2">実装固有の情報をまとめる <code>&lt;version&gt;</code> ヘッダを追加 <a href="https://wg21.link/P0754R2">(P0754R2)</a><a class="headerlink" href="#version-p0754r2" title="Permanent link">&para;</a></h3>
<p><code>__cpp_lib_byte</code>, <code>__cpp_lib_void_t</code> のような標準ライブラリの機能テストマクロ、その他ライブラリのバージョンや実装固有の情報をまとめる目的の <code>&lt;version&gt;</code> ヘッダが追加されました。
例えば C++20 以前の MSVC の標準ライブラリでは、<code>&lt;yvals_core.h&gt;</code> という独自ヘッダに標準ライブラリの機能テストマクロがまとめられていましたが、C++20 以降ではあらゆる実装において、<code>&lt;version&gt;</code> ヘッダを見ることで、こうした実装固有の情報にアクセスできるため利便性が高まります。</p>
<h3 id="is_nothrow_convertible-p0758r1">例外を投げない暗黙の変換が可能か調べる <code>is_nothrow_convertible</code> <a href="https://wg21.link/P0758R1">(P0758R1)</a><a class="headerlink" href="#is_nothrow_convertible-p0758r1" title="Permanent link">&para;</a></h3>
<p>型 <code>From</code> から型 <code>To</code> への暗黙の変換が可能であるかを調べる型特性クラス <code>std::is_convertible&lt;class From, class To&gt;</code> が C++11 から導入されましたが、その変換が <code>noexcept</code> でもあるかを調べられるバージョンは実装されていませんでした。
このことが原因で、<code>std::decay_copy</code> の提案 (<a href="http://wg21.link/n3255">N3255</a>) において、適切な <code>noexcept</code> 例外仕様を移植性のある方法で定義できない問題 (<a href="http://wg21.link/lwg2040">LWG 2040</a>) が指摘されていました。
<div class="highlight"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> 
<span class="k">typename</span> <span class="n">decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">decay_copy</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="o">???</span> <span class="cm">/* is_nothrow_convertible&lt;T, T&gt;::value */</span><span class="p">);</span>
</code></pre></div>
C++20 からは、<code>noexcept</code> な暗黙の変換が可能であることを調べる新しい型特性クラス <code>std::is_nothrow_convertible&lt;class From, class To&gt;</code> が実装されることで問題を解消できます。
既存の標準ライブラリ関数においても、<code>std::basic_string</code> のメンバ関数テンプレートに、より適切な <code>noexcept</code> 例外仕様を定義するために活用されます。</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">size_type</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">is_nothrow_convertible_v</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">basic_string_view</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span> <span class="n">Traits</span><span class="o">&gt;&gt;</span><span class="p">);</span>
</code></pre></div>

<h3 id="stdto_address-p0653r2">ポインタライクなオブジェクトからアドレスを取得する <code>std::to_address()</code> 関数 <a href="https://wg21.link/P0653R2">(P0653R2)</a><a class="headerlink" href="#stdto_address-p0653r2" title="Permanent link">&para;</a></h3>
<p>ポインタライクなオブジェクトを引数にとり、それが表すのと同じアドレスを生ポインタで返す関数 <code>std::to_address(p)</code> が追加されます。オブジェクトがポインタ型の場合はその値を返し、それ以外の場合、<code>std::pointer_traits&lt;Ptr&gt;::to_address(p)</code> の特殊化が定義されていて使えればその戻り値を、そうでない場合は <code>std::to_address(p.operator-&gt;())</code> の戻り値を返します。</p>
<h3 id="complex-constexpr-p0415r1"><code>&lt;complex&gt;</code> ヘッダの関数の <code>constexpr</code> 対応を強化 <a href="https://wg21.link/P0415R1">(P0415R1)</a><a class="headerlink" href="#complex-constexpr-p0415r1" title="Permanent link">&para;</a></h3>
<p><code>&lt;complex&gt;</code> ヘッダが提供する関数のうち、複素数の四則演算、ノルムの取得、共役複素数の取得など、<code>constexpr</code> 非対応の数学関数 (sqrt など) を使わずに実装できるものが <code>constexpr</code> 化されます。</p>
<h3 id="stdis_constant_evaluated-p0595r2">コンパイル時評価の文脈か実行時評価の文脈かを判別できる <code>std::is_constant_evaluated()</code> 関数 <a href="https://wg21.link/P0595">(P0595R2)</a><a class="headerlink" href="#stdis_constant_evaluated-p0595r2" title="Permanent link">&para;</a></h3>
<p>C++17 までは、実行するコードを、コンパイル時評価か実行時評価かに応じて使い分ける方法はありませんでした。C++20 では、コンパイル時評価されている文脈では <code>true</code> を、それ以外の場合では <code>false</code> を返す <code>std::is_constant_evaluated()</code> 関数が <code>&lt;type_traits&gt;</code> ヘッダに追加されます。例えば標準ライブラリで <code>constexpr</code> 対応していないような数学関数を提供する際、コンパイル時評価では <code>constexpr</code> 版の実装を、実行時には非 <code>constexpr</code> の標準ライブラリの実装を提供するよう選択させることができます。なお、<code>std::is_constant_evaluated()</code> を <code>if constexpr</code> の <code>( )</code> 内や <code>static_assert</code> 内で使うと常に <code>true</code> に評価されてしまうので注意が必要です。基本的には <code>if (std::is_constant_evaluated())</code> と書きます。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">float</span> <span class="nf">Sin_impl</span><span class="p">(</span><span class="kt">float</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">float</span> <span class="n">xn</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">?</span> <span class="mf">0.0f</span> <span class="o">:</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">xn</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">+</span> <span class="n">Sin_impl</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">xn</span> <span class="o">*</span> <span class="n">x2</span><span class="p">,</span> <span class="n">nf</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="kt">float</span> <span class="nf">Sin</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_constant_evaluated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Sin_impl</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">Pi</span> <span class="o">=</span> <span class="mf">3.14159265f</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span> <span class="c1">// コンパイル時計算    </span>
    <span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>  <span class="c1">// 実行時計算</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>0.7071068286895752
0.7071067690849304
</code></pre></div></p>
<h3 id="p0020r6">浮動小数点数型のアトミック操作を拡張 <a href="https://wg21.link/P0020R6">(P0020R6)</a><a class="headerlink" href="#p0020r6" title="Permanent link">&para;</a></h3>
<p><code>std::atomic&lt;T&gt;</code> の <code>float</code>, <code>double</code>, <code>long double</code> 型の特殊化に、メンバ関数 <code>fetch_add()</code>, <code>fetch_sub()</code>, <code>operator+=()</code>, <code>operator-=()</code> が追加されます。</p>
<h3 id="stdmemory_order-enum-class-p0439r0"><code>std::memory_order</code> を <code>enum class</code> に変更 <a href="https://wg21.link/P0439R0">(P0439R0)</a><a class="headerlink" href="#stdmemory_order-enum-class-p0439r0" title="Permanent link">&para;</a></h3>
<p>C++17 まで <code>enum</code> で定義されていた <code>std::memory_order</code> を、モダンな C++ 文法と型安全のために、<code>enum class</code> で定義する仕様に変更されます。これまでの表記は定数で提供されるようになるため、既存のソースコードは影響を受けません。また、バイナリ互換性のために、<code>enum class</code> の基底型の選択は実装に任せられています。</p>
<div class="tabbed-set" data-tabs="3:2">
<input name="__tabbed_3" type="radio" id="__tabbed_3_1" checked="checked" /><label for="__tabbed_3_1">C++17</label><div class="tabbed-content"><div class="highlight"><pre><span></span><code><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="k">enum</span> <span class="n">memory_order</span>
    <span class="p">{</span>
        <span class="n">memory_order_relaxed</span><span class="p">,</span>
        <span class="n">memory_order_consume</span><span class="p">,</span>
        <span class="n">memory_order_acquire</span><span class="p">,</span>
        <span class="n">memory_order_release</span><span class="p">,</span>
        <span class="n">memory_order_acq_rel</span><span class="p">,</span>
        <span class="n">memory_order_seq_cst</span>
    <span class="p">}</span> <span class="n">memory_order</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<input name="__tabbed_3" type="radio" id="__tabbed_3_2" /><label for="__tabbed_3_2">C++20</label><div class="tabbed-content"><div class="highlight"><pre><span></span><code><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">memory_order</span> <span class="cm">/* : unspecified */</span>
    <span class="p">{</span>
        <span class="n">relaxed</span><span class="p">,</span>
        <span class="n">consume</span><span class="p">,</span>
        <span class="n">acquire</span><span class="p">,</span>
        <span class="n">release</span><span class="p">,</span>
        <span class="n">acq_rel</span><span class="p">,</span>
        <span class="n">seq_cst</span>
    <span class="p">};</span>

    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_relaxed</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_consume</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">consume</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_acquire</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">acquire</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_release</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">release</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_acq_rel</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">acq_rel</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_seq_cst</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">seq_cst</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
</div>
<h3 id="hash-p0809r0"><code>Hash</code> が同一の挙動をしない非順序連想コンテナどうしの比較が可能に <a href="https://wg21.link/P0809R0">(P0809R0)</a><a class="headerlink" href="#hash-p0809r0" title="Permanent link">&para;</a></h3>
<p>C++17 までは、非順序連想コンテナの <code>operator==</code>, <code>operator!=</code> について、「両者の <code>Hash</code> と <code>Pred</code> がそれぞれ同一の挙動をしない場合は未定義動作」と規格に記されていました。しかし、ランダムなソルトを使うハッシュ関数を持つコンテナ同士の比較もユースケースとして想定され、また、対応するための実装も難しくなかったことから、C++20 からはこのうち <code>Hash</code> に関する記述が削除されました。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">RandomizedHash</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">rnd</span><span class="p">;</span>

    <span class="n">RandomizedHash</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
        <span class="n">rnd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">rd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">s</span><span class="p">)</span> <span class="o">^</span> <span class="n">rnd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">RandomizedHash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">u1</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Three&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">RandomizedHash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">u2</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Three&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="c1">// それぞれ異なるハッシュ値を返す</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;abcde&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;u1: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">u1</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;u2: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">u2</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="c1">// C++17 までは未定義動作、C++20 から OK</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="p0463r1">実行環境のエンディアンを判別するための列挙定数を追加 <a href="https://wg21.link/P0463R1">(P0463R1)</a><a class="headerlink" href="#p0463r1" title="Permanent link">&para;</a></h3>
<p>これまでの C++ プログラムでは、ターゲットアーキテクチャのバイトオーダを判別する際にトリッキーなコードを書く必要がありました。C++20 からは、リトルエンディアンを表す <code>endian::little</code>, ビッグエンディアンを表す <code>endian::big</code>, 実行環境のエンディアンを表す <code>endian::native</code> の 3 つの <code>endian</code> 型の列挙定数（値は実装に依存）が <code>&lt;type_traits&gt;</code> に定義され、<code>endian::native</code> をそれ以外の値と比較することで、実行環境のバイトオーダを判別できるようになります。現在の C++ コンパイラで、リトルエンディアンでもビッグエンディアンでもないミドルエンディアン（PDP エンディアンなど）をサポートしているものはありませんが、ミドルエンディアンの環境においては、<code>endian::native</code> は <code>endian::big</code> でも <code>endian::little</code> でもない値を持つことになっています。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">little</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Little-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">big</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Big-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Middle-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="cv-stdremove_cvref-trait-p0550r2">型から cv 修飾と参照を除去する <code>std::remove_cvref</code> trait <a href="https://wg21.link/P0550R2">(P0550R2)</a><a class="headerlink" href="#cv-stdremove_cvref-trait-p0550r2" title="Permanent link">&para;</a></h3>
<p>型から <code>const</code> や <code>volatile</code> の修飾および参照を除去したいだけで、配列からポインタ、関数型から関数ポインタへの変換については不要であっても、C++17 では <code>std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</code> と書くと長くなるため <code>std::decay</code> を使うというケースがよくありました。C++20 からは <code>std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</code> と同じ効果を持つ <code>std::remove_cvref</code> trait と、そのヘルパー型 <code>std::remove_cvref_t</code> が追加され、短く書けるようになります。<code>std::remove_reference_t&lt;std::remove_cv_t&lt;T&gt;&gt;</code> のような順番の間違いを防ぐことにもつながります。</p>
<h3 id="stddecay-p0777r1">標準ライブラリでの不必要な <code>std::decay</code> の使用を回避 <a href="https://wg21.link/P0777R1">(P0777R1)</a><a class="headerlink" href="#stddecay-p0777r1" title="Permanent link">&para;</a></h3>
<p>C++17 の標準ライブラリの規格では <code>std::decay_t</code> がおよそ 40 箇所で使われていましたが、そのうち cv 修飾の除去や参照の除去だけで十分な箇所について、実装の意図をより明確にするため <code>std::remove_reference_t</code> や、C++20 から導入される <code>std::remove_cvref_t</code> に置き換えられます。具体的には、<code>std::apply</code> や、<code>std::optional</code>, <code>std::variant</code> の一部のメンバ関数などで置き換えが発生します。</p>
<h3 id="numbers-p0631r8">数学定数を提供する <code>&lt;numbers&gt;</code> ヘッダ <a href="https://wg21.link/P0631R8">(P0631R8)</a><a class="headerlink" href="#numbers-p0631r8" title="Permanent link">&para;</a></h3>
<p>これまで C++ の標準ライブラリには数学定数が用意されていませんでした（<code>M_PI</code> などは拡張）。C++20 からは数学定数をまとめた <code>&lt;numbers&gt;</code> ヘッダが追加され、13 種類の数学定数の変数テンプレート宣言と、それらの <code>double</code> 型への特殊化の定義が提供されます。<br />
変数テンプレートは、標準ライブラリコンセプト <code>floating_point</code> を使って、<code>std::numbers</code> 名前空間に次のように宣言されます。
<div class="highlight"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">floating_point</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mf">3.141592653589793238462643383279502884</span><span class="n">L</span><span class="p">;</span>
</code></pre></div>
合わせて <code>double</code> 型への特殊化の定義が次のような実装で提供されます。
<div class="highlight"><pre><span></span><code><span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
C++20 で追加される数学定数の一覧は次のとおりです。</p>
<table>
<thead>
<tr>
<th>定数名</th>
<th>説明</th>
<th>binary128 に充分な精度を持つ値</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_v</td>
<td>e</td>
<td>2.718281828459045235360287471352662498L</td>
</tr>
<tr>
<td>log2e_v</td>
<td>2 を底とする e の対数</td>
<td>1.442695040888963407359924681001892137L</td>
</tr>
<tr>
<td>log10e_v</td>
<td>10 を底とする e の対数</td>
<td>0.434294481903251827651128918916605082L</td>
</tr>
<tr>
<td>pi_v</td>
<td>円周率 (π)</td>
<td>3.141592653589793238462643383279502884L</td>
</tr>
<tr>
<td>inv_pi_v</td>
<td>1/π</td>
<td>0.318309886183790671537767526745028724L</td>
</tr>
<tr>
<td>inv_sqrtpi_v</td>
<td>1/√π</td>
<td>0.564189583547756286948079451560772586L</td>
</tr>
<tr>
<td>ln2_v</td>
<td>2 の自然対数</td>
<td>0.693147180559945309417232121458176568L</td>
</tr>
<tr>
<td>ln10_v</td>
<td>10 の自然対数</td>
<td>2.302585092994045684017991454684364208L</td>
</tr>
<tr>
<td>sqrt2_v</td>
<td>√2</td>
<td>1.414213562373095048801688724209698078L</td>
</tr>
<tr>
<td>sqrt3_v</td>
<td>√3</td>
<td>1.732050807568877293527446341505872366L</td>
</tr>
<tr>
<td>inv_sqrt3_v</td>
<td>1/√3</td>
<td>0.577350269189625764509148780501957456L</td>
</tr>
<tr>
<td>egamma_v</td>
<td>オイラーの定数</td>
<td>0.577215664901532860606512090082402431L</td>
</tr>
<tr>
<td>phi_v</td>
<td>黄金数 (φ)</td>
<td>1.618033988749894848204586834365638117L</td>
</tr>
</tbody>
</table>
<p>コードで使用する際は、<code>using</code> 宣言によって記述を短くできます。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numbers&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi_v</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span>  <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="basic_stringreserve-capacity-p0966r1"><code>basic_string::reserve()</code> が capacity を縮小しないように <a href="https://wg21.link/P0966R1">(P0966R1)</a><a class="headerlink" href="#basic_stringreserve-capacity-p0966r1" title="Permanent link">&para;</a></h3>
<p>C++17 では、<code>std::basic_string::reserve(size_type)</code> に現在の <code>capacity()</code> よりも小さい値が渡された際、shrink-to-fit を実行することが許可されていたため、注意深く使わないとメモリの再配置を頻繁に引き起こし、実行時性能を低下させることがありました。また、デフォルト引数として <code>0</code> が定義されており、<code>s.reserve()</code> と <code>s.shrink_to_fit()</code> で機能が重複するという問題や、shrink-to-fit を実行せずデフォルト引数も無い <code>std::vector::reserve(size_type)</code> との一貫性がないという問題がありました。C++20 からの新しい仕様では <code>std::vector</code> 側に合わせ、<code>std::basic_string::reserve(size_type)</code> に現在の <code>capacity()</code> よりも小さい値が渡された際には何もしないことが保証され、デフォルト引数も廃止（互換性のために deprecated 指定の <code>std::basic_string:reserve(void)</code> オーバーロードが追加）となり、これらの問題が解決されます。</p>
<h3 id="constains-p0458r2">連想コンテナに <code>constains()</code> メンバ関数を追加 <a href="https://wg21.link/P0458R2">(P0458R2)</a><a class="headerlink" href="#constains-p0458r2" title="Permanent link">&para;</a></h3>
<p>ある要素が連想コンテナに含まれているか調べるための C++17 までのイディオムは、直感的でなく初心者にとっても明快ではありませんでした。C++20 からは、要素の存在をチェックする <code>contains(key)</code> メンバ関数が <code>std::map</code>, <code>std::multimap</code>, <code>std::set</code>, <code>std::multiset</code>, <code>std::unordered_map</code>, <code>std::unordered_multimap</code>, <code>std::unordered_set</code>, <code>std::unordered_multiset</code> に追加されます。</p>
<div class="tabbed-set" data-tabs="4:2">
<input name="__tabbed_4" type="radio" id="__tabbed_4_1" checked="checked" /><label for="__tabbed_4_1">C++17</label><div class="tabbed-content"><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="mi">200</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">201</span><span class="p">,</span> <span class="s">&quot;Created&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">202</span><span class="p">,</span> <span class="s">&quot;Accepted&quot;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">!=</span> <span class="n">table</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;key exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<input name="__tabbed_4" type="radio" id="__tabbed_4_2" /><label for="__tabbed_4_2">C++20</label><div class="tabbed-content"><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="mi">200</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">201</span><span class="p">,</span> <span class="s">&quot;Created&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">202</span><span class="p">,</span> <span class="s">&quot;Accepted&quot;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">200</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;key exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
</div>
<h3 id="stderase-stderase_if-p1209r0">コンテナから指定した要素を削除する操作に一貫して使える <code>std::erase()</code>, <code>std::erase_if()</code> 関数 <a href="https://wg21.link/p1209r0">(P1209R0)</a><a class="headerlink" href="#stderase-stderase_if-p1209r0" title="Permanent link">&para;</a></h3>
<p>コンテナから特定の要素を削除するという処理は、コンテナの種類によって最適な書き方が異なります。<code>std::unordered_map</code> ではイテレータを使って先頭から要素を削除していき、<code>std::list</code> ではメンバ関数の <code>remove()</code> や <code>remove_if()</code> を使い、<code>std::vector</code> では <code>std::remove_if()</code> と <code>erase()</code> メンバ関数を組み合わせます。このようにコンテナの特性に応じてコードを書き分けるのは大変だったため、C++20 ではすべてのコンテナ向けに適切な実装を提供する、一貫して使える非メンバ関数 <code>std::erase()</code>, <code>std::erase_if()</code> が追加されます。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">92</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span> <span class="n">li</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">92</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;aa&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;bb&quot;</span><span class="p">,</span> <span class="mi">14</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;dd&quot;</span><span class="p">,</span> <span class="mi">5</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;ee&quot;</span><span class="p">,</span> <span class="mi">92</span> <span class="p">}</span> <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span> <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="stdbit_cast-p0476r2">バイト列の再解釈キャストを補助する <code>std::bit_cast()</code> 関数 <a href="https://wg21.link/P0476R2">(P0476R2)</a><a class="headerlink" href="#stdbit_cast-p0476r2" title="Permanent link">&para;</a></h3>
<p>ある型のオブジェクトが格納されているバイト列に対して、別の型のオブジェクトと解釈してアクセスすること (type punning) は C++ では禁止されています (strict aliasing rule). <code>float</code> 型の値のバイト列を <code>std::uint32_t</code> 型として扱うときの間違った方法として、次のサンプルのように <code>reinterpret_cast</code> や <code>union</code> を用いる例があります。これは直感的に見え、実際ほとんどのコンパイラで期待通り動作しますが、規格上は未定義動作となる不正なコードです。正しくは <code>std::memcpy()</code> を使います。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">union</span> <span class="n">FloatUint32</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">;</span>

    <span class="c1">// 未定義動作</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u1</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>

    <span class="c1">// 未定義動作</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">FloatUint32</span><span class="p">{</span> <span class="n">f</span> <span class="p">}.</span><span class="n">u</span><span class="p">;</span>

    <span class="c1">// OK</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u3</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u3</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>しかし、<code>std::memcpy()</code> では型変換を <code>constexpr</code> にできず、また、デフォルトコンストラクト可能でない型に対応するには <code>std::aligned_storage</code> と組み合わせる必要があるなど、適切な実装は面倒でした。C++20 では、この実装をコンパイラサポートによる <code>constexpr</code> 対応も含めて実現する <code>std::bit_cast()</code> 関数が提供されます。</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">To</span><span class="p">,</span> <span class="k">typename</span> <span class="n">From</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">To</span> <span class="n">bit_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">From</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</code></pre></div>

<p>変換先の型 <code>To</code> と変換元の型 <code>From</code> について、<code>sizeof(To) != sizeof(From)</code> の場合や、<code>std::is_trivially_copyable_v&lt;To&gt; == false</code> または <code>std::is_trivially_copyable_v&lt;From&gt; == false</code> の場合にはコンパイルエラーになるため、間違いを減らす効果もあります。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bit&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bit_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="numeric-p0616r0"><code>&lt;numeric&gt;</code> の関数の非効率な実装を改善 <a href="https://wg21.link/P0616R0">(P0616R0)</a><a class="headerlink" href="#numeric-p0616r0" title="Permanent link">&para;</a></h3>
<p>C++17 では、<code>std::accumulate()</code> は <code>acc = binary_op(acc, *i)</code> として実装されると規格に定められていいたため、次のようなケースで <code>std::accumulate()</code> の最中に <code>std::string</code> のアロケーションが大量に発生して非効率でした。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">&quot;abc&quot;</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;start&quot;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">r</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
C++17 の <code>std::accumulate()</code> の中で行われること:
<div class="highlight"><pre><span></span><code><span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="c1">// operator+(const std::string&amp;, const std::string&amp;)</span>
<span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="p">...</span> <span class="c1">// くり返し</span>
</code></pre></div></p>
<p>C++20 では、<code>std::move()</code> を使う <code>acc = binary_op(std::move(acc), *i)</code> という実装に変更され、右辺値の演算に対する効率的な実装を提供する型 (<code>std::string</code> など) が、恩恵を受けられるようになります。</p>
<p>C++20 の <code>std::accumulate()</code> の中で行われること:
<div class="highlight"><pre><span></span><code><span class="n">acc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="c1">// operator+(std::string&amp;&amp;, const std::string&amp;)</span>
<span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div>
<code>operator+(std::string&amp;&amp; lhs, const std::string&amp; rhs)</code> は基本的に <code>lhs.append(rhs)</code> です。次のようにあらかじめ十分なキャパシティを確保したバッファを <code>std::accumulate()</code> 内で使えるようにもなります。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">&quot;abc&quot;</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;start&quot;</span><span class="p">;</span>

    <span class="n">s</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">words</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">size</span><span class="p">()));</span> <span class="c1">// C++17 では無意味</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">r</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>std::move()</code> を使うこの仕様変更は、同じ <code>&lt;numeric&gt;</code> ヘッダの <code>std::inner_product()</code> や <code>std::partial_sum()</code>, <code>std::adjacent_difference()</code> にも適用されます。</p>
<h3 id="2-p0556r3-p1355r2-p1956r1">2 の累乗数に関するユーティリティ関数を追加 <a href="https://wg21.link/P0556R3">(P0556R3)</a>, <a href="https://wg21.link/P1355R2">(P1355R2)</a>, <a href="https://wg21.link/P1956R1">(P1956R1)</a><a class="headerlink" href="#2-p0556r3-p1355r2-p1956r1" title="Permanent link">&para;</a></h3>
<p>ある整数が 2 の累乗数であるかを調べたり、ある整数に近い 2 の累乗数を探したりする処理は、プログラミングでよく登場しますが、C++17 の標準ライブラリには実装されていませんでした。C++20 では次のような関数が追加されます。</p>
<div class="highlight"><pre><span></span><code><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">has_single_bit</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="n">bit_ceil</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="n">bit_floor</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="n">bit_width</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>引数 <code>x</code> のビット列に含まれる 1 が 1 個だけであるかを判定する <code>std::has_single_bit(x)</code><ul>
<li>「<code>x</code> が 2 の累乗数 (1, 2, 4, 8, ...) であるか」と同じ意味</li>
</ul>
</li>
<li><code>x</code> 以上で最小の 2 の累乗数を返す <code>std::bit_ceil(x)</code></li>
<li><code>x</code> 以下で最大の 2 の累乗数 (ただし <code>x</code> が 0 の場合は 0) を返す <code>std::bit_floor(x)</code></li>
<li><code>(1 + log2(x))</code> の整数部 (ただし <code>x</code> が 0 の場合は 0) を返す <code>std::bit_width(x)</code><ul>
<li>「<code>x</code> を表現するために何ビット必要か」と同じ意味</li>
</ul>
</li>
</ul>
<p>いずれの関数も、型 <code>T</code> が符号なし整数型 (<code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>) の場合のみオーバーロード解決に参加します。なお、<code>std::bit_ceil(x)</code> について、結果が型 <code>T</code> で表現できない場合の動作は未定義です。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bit&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">has_single_bit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">bit_ceil</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">bit_floor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">bit_width</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>0: 0 1 0 0
1: 1 1 1 1
2: 1 2 2 2
3: 0 4 2 2
4: 1 4 4 3
5: 0 8 4 3
6: 0 8 4 3
7: 0 8 4 3
8: 1 8 8 4
9: 0 16 8 4
10: 0 16 8 4
11: 0 16 8 4
12: 0 16 8 4
13: 0 16 8 4
14: 0 16 8 4
15: 0 16 8 4
16: 1 16 16 5
</code></pre></div></p>
<h3 id="stdlist-stdforward_list-p0646r1"><code>std::list</code> と <code>std::forward_list</code> の要素削除メンバ関数が、削除した要素数を返すように <a href="https://wg21.link/P0646R1">(P0646R1)</a><a class="headerlink" href="#stdlist-stdforward_list-p0646r1" title="Permanent link">&para;</a></h3>
<p><code>std::list</code> のメンバ関数 <code>remove()</code> で要素を削除した際、実際に削除された要素数を知るには、前後で <code>size()</code> の比較を行わなければなりませんでした。しかし、<code>std::forward_list</code> の場合は <code>size()</code> メンバ関数を持たないため、O(n) の操作である <code>std::distance()</code> を使う必要がありました。C++20 では、<code>std::list</code> および <code>std::forward_list</code> の <code>remove()</code>, <code>remove_if()</code>, <code>unique()</code> メンバ関数が、削除された要素数を戻り値として返すようになります。なお、呼び出し側で戻り値を使わない場合、主要コンパイラは最適化で処理を省略するため、この仕様変更が実行時性能に与える影響は無いとされています。</p>
<h3 id="stdis_bounded_array-stdis_unbounded_array-p1357r1">要素数が決まっている配列型かどうかを調べる型特性 <code>std::is_bounded_array</code>, <code>std::is_unbounded_array</code> <a href="https://wg21.link/P1357R1">(P1357R1)</a><a class="headerlink" href="#stdis_bounded_array-stdis_unbounded_array-p1357r1" title="Permanent link">&para;</a></h3>
<p>C++17 の標準ライブラリが提供する型特性には、配列の要素数が決まっている (bounded) かどうかを判定するものはありませんでした。C++20 では利便性のために、型 <code>T</code> が要素数既知の配列型であるかを調べる型特性 <code>std::is_bounded_array&lt;T&gt;</code> と、型 <code>T</code> が要素数未知の配列型であるかを調べる型特性 <code>std::is_unbounded_array&lt;T&gt;</code> が追加されました。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_bounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// false</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_bounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// false</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_bounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// true</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unbounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// false</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unbounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// true</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unbounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>false
false
true
false
true
false
</code></pre></div></p>
<p>C++ 標準ライブラリの機能では、例えば <code>std::make_unique()</code> が要素数既知の配列型を禁止しています。こうしたオーバーロードを扱うときに、この型特性が便利です。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// コンパイルエラー</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="stdfunction-noexcept-p0771r1"><code>std::function</code> のムーブコンストラクタが <code>noexcept</code> に <a href="https://wg21.link/P0771R1">(P0771R1)</a><a class="headerlink" href="#stdfunction-noexcept-p0771r1" title="Permanent link">&para;</a></h3>
<p>実行時性能を向上させるため、C++20 では <code>std::function</code> のムーブコンストラクタが <code>noexcept</code> になります。なお、libstdc++ と libc++ では提案時点ですでに実装済みでした。</p>
<h3 id="utility-algorithm-constexpr-p0202r3-p0879r0"><code>&lt;utility&gt;</code>, <code>&lt;algorithm&gt;</code> の多くの関数が <code>constexpr</code> に <a href="https://wg21.link/P0202R3">(P0202R3)</a>, <a href="https://wg21.link/P0879R0">(P0879R0)</a><a class="headerlink" href="#utility-algorithm-constexpr-p0202r3-p0879r0" title="Permanent link">&para;</a></h3>
<p>C++20 では <code>&lt;utility&gt;</code> ヘッダの <code>std::swap()</code>, <code>std::exchange()</code> および、<code>&lt;algorithm&gt;</code> ヘッダで条件を満たす全関数が <code>constexpr</code> に対応します。<code>std::all_of()</code> や <code>std::sort()</code>, <code>std::reverse()</code> など、よく使われるアルゴリズム関数が <code>constexpr</code> になります。</p>
<p><code>&lt;algorithm&gt;</code> ヘッダで <code>constexpr</code> にならないのは以下の関数のみです。</p>
<ul>
<li><code>std::stable_partition()</code>, <code>std::inplace_merge()</code>, <code>std::stable_sort()</code><ul>
<li>メモリのアロケーション等が必要なため</li>
</ul>
</li>
<li><code>std::shuffle()</code>, <code>std::sample()</code><ul>
<li><code>constexpr</code> 関数を持たない <code>std::uniform_int_distribution</code> を使用するため</li>
</ul>
</li>
<li><code>ExecutionPolicy</code> を引数に取る関数</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">SumOfTop3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// C++20 では constexpr</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">SumOfTop3</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">});</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">7</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 7</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>7
</code></pre></div>

<h3 id="delete-p0722r3">デストラクタを自動で呼ばない <code>delete</code> 演算子オーバーロード <a href="https://wg21.link/P0722R3">(P0722R3)</a><a class="headerlink" href="#delete-p0722r3" title="Permanent link">&para;</a></h3>
<p>C++17 では、ユーザ定義の <code>delete</code> の中でメンバ変数にアクセスしたくても、すでにクラスのデストラクタが呼ばれているため未定義の動作になります。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Object</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_str</span> <span class="o">=</span> <span class="s">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>    
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;m_str: &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_str</span> <span class="c1">// 未定義の動作</span>
            <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Object</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>C++20 では、<code>delete</code> の第二引数を <code>std::destroying_delete_t</code> 型にすることで、デストラクタの呼び出しが自動で実行されない挙動に設定できます（この新しい挙動を「destroying operator delete」と呼びます）。<code>void T::operator delete(T* ptr, std::destroying_delete_t)</code> のように、第一引数にはクラスへのポインタが渡され、明示的にデストラクタ <code>ptr-&gt;~T()</code> を呼ぶ必要があります。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Object</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_str</span> <span class="o">=</span> <span class="s">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="n">Object</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">destroying_delete_t</span><span class="p">)</span>
    <span class="p">{</span>    
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;m_str: &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_str</span>
            <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>      
        <span class="n">p</span><span class="o">-&gt;~</span><span class="n">Object</span><span class="p">();</span>
        <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Object</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="p0553r4">ビット循環シフト・ビットカウント関数 <a href="https://wg21.link/P0553R4">(P0553R4)</a><a class="headerlink" href="#p0553r4" title="Permanent link">&para;</a></h3>
<p>ビット列の左端と右端が循環するようにシフトするビットローテーションや、1 になっているビットを数える popcount などのビット操作命令は、多くの CPU アーキテクチャに搭載されていますが、それに対応する関数は C++17 標準ライブラリには存在せず、<code>__builtin_popcount</code> (GCC, Clang) や <code>__popcnt</code> (MSVC) のような、処理系が提供する非標準の組み込み関数を使う必要がありました。C++20 では、7 種類のビット操作が標準ライブラリ関数として提供されます。</p>
<div class="highlight"><pre><span></span><code><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">rotl</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">rotr</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">countl_zero</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">countl_one</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">countr_zero</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">countr_one</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">popcount</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>引数 <code>x</code> を <code>s</code> だけ左にビットローテーションさせる <code>std::rotl(x, s)</code><ul>
<li><code>s</code> が負数の場合 <code>std::rotr(x, -s)</code> と同等</li>
</ul>
</li>
<li>引数 <code>x</code> を <code>s</code> だけ右にビットローテーションさせる <code>std::rotr(x, s)</code><ul>
<li><code>s</code> が負数の場合 <code>std::rotl(x, -s)</code> と同等</li>
</ul>
</li>
<li><code>x</code> の最上位ビットから数えて 0 が連続する個数を返す <code>std::countl_zero(x)</code></li>
<li><code>x</code> の最上位ビットから数えて 1 が連続する個数を返す <code>std::countl_one(x)</code></li>
<li><code>x</code> の最下位ビットから数えて 0 が連続する個数を返す <code>std::countr_zero(x)</code></li>
<li><code>x</code> の最下位ビットから数えて 1 が連続する個数を返す <code>std::countr_one(x)</code></li>
<li><code>x</code> の 2 進表現に含まれる 1 の個数を返す <code>std::popcount(x)</code></li>
</ul>
<p>いずれの関数も、型 <code>T</code> が符号なし整数型 (<code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>) の場合のみオーバーロード解決に参加します。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bit&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">ShowBinary</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">15</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b0001</span><span class="err">&#39;</span><span class="mo">0110</span><span class="err">&#39;</span><span class="mi">1110</span><span class="err">&#39;</span><span class="mi">1111</span><span class="p">;</span>

    <span class="n">ShowBinary</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ShowBinary</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">rotl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ShowBinary</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">rotr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">countl_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>   <span class="c1">// 3</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">countl_one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// 0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">countr_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>   <span class="c1">// 0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">countr_one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// 4</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">popcount</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>      <span class="c1">// 10</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>0001011011101111

1111000101101110
1110001011011101
1100010110111011
1000101101110111
0001011011101111
0010110111011110
0101101110111100
1011011101111000
0110111011110001

0110111011110001
1011011101111000
0101101110111100
0010110111011110
0001011011101111
1000101101110111
1100010110111011
1110001011011101
1111000101101110

3
0
0
4
10
</code></pre></div></p>
<h3 id="stdarray-stdto_array-p0325r4">組み込み配列から <code>std::array</code> を作成する <code>std::to_array()</code> <a href="https://wg21.link/P0325R4">(P0325R4)</a><a class="headerlink" href="#stdarray-stdto_array-p0325r4" title="Permanent link">&para;</a></h3>
<p>C++17 で導入された型推論ガイドによって、<code>std::array</code> で次のようなコードが書けるようになりました。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span> <span class="c1">// std::array&lt;int, 3&gt;</span>
<span class="p">}</span>
</code></pre></div>

<p>しかし、<code>"hello"</code> や <code>int[4]</code> のような組み込み配列から <code>std::array&lt;char, 6&gt;</code> や <code>std::array&lt;int, 4&gt;</code> を作成する方法はありませんでした。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">{</span> <span class="s">&quot;hello&quot;</span> <span class="p">};</span> <span class="c1">// std::array&lt;const char*, 1&gt;</span>

    <span class="kt">int</span> <span class="n">xs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span> <span class="p">};</span>
    <span class="k">auto</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">{</span> <span class="n">xs</span> <span class="p">};</span> <span class="c1">// std::array&lt;int*, 1&gt;</span>
<span class="p">}</span>
</code></pre></div>

<p>C++20 では、組み込み配列の左辺値または右辺値を引数にとり、値をコピー（ムーブ）して新しい <code>std::array</code> を作成する補助関数 <code>std::to_array()</code> が追加され、組み込み配列からの <code>std::array</code> の作成が簡単になりました。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_array</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span> <span class="c1">// std::array&lt;char, 6&gt;</span>

    <span class="kt">int</span> <span class="n">xs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span> <span class="p">};</span>
    <span class="k">auto</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_array</span><span class="p">(</span><span class="n">xs</span><span class="p">);</span> <span class="c1">// std::array&lt;int, 4&gt;</span>

    <span class="k">auto</span> <span class="n">a3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_array</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">});</span> <span class="c1">// std::array&lt;long, 2&gt;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="stdfilesystemcreate_directory-p1164r1"><code>std::filesystem::create_directory()</code> の挙動を直感的に <a href="https://wg21.link/P1164R1">(P1164R1)</a><a class="headerlink" href="#stdfilesystemcreate_directory-p1164r1" title="Permanent link">&para;</a></h3>
<p>C++17 で導入された <code>std::filesystem::create_directory()</code> および <code>std::filesystem::create_directories()</code> の当初の仕様では、</p>
<ul>
<li>新しく作成するディレクトリのパスと同名のファイルが存在するときにはエラーにならない</li>
<li>新しく作成するディレクトリのパスが <code>"a/b/c"</code> であるとき、すでに <code>"a/b"</code> という名前のファイルが存在する場合はエラーとなる一方で、<code>"a/b/c"</code> というファイルが存在する場合にはエラーにならない</li>
</ul>
<p>という、対処しにくく一貫しない挙動がありました。C++20 では同名の（ディレクトリでない）ファイルが存在する場合は常にエラーになるよう仕様が修正されます。この変更は C++17 規格にさかのぼって適用され、対応した C++17 環境でも利用できます。</p>
<h3 id="stdmake_shared-stdallocate_shared-p0674r1"><code>std::make_shared()</code> と <code>std::allocate_shared()</code> が配列をサポート <a href="https://wg21.link/P0674R1">(P0674R1)</a><a class="headerlink" href="#stdmake_shared-stdallocate_shared-p0674r1" title="Permanent link">&para;</a></h3>
<p>C++11 で導入された <code>std::make_shared()</code>, <code>std::allocate_shared()</code> は配列をサポートしていませんでした。C++20 からは配列型のためのオーバーロードが追加されます。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 値初期化された int[100]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0</span>

    <span class="c1">// 値初期化された double[6][4]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[][</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[][</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0.0</span>

    <span class="c1">// 値初期化された int[100]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p3</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0</span>

    <span class="c1">// 値初期化された double[6][4]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p4</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0.0</span>

    <span class="c1">// int[100] で各要素は -1</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p5</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// -1</span>

    <span class="c1">// double[6][4] で、各 double[4] は { 1.0, 0.9, 0.8, 0.7 }</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[][</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">p6</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[][</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.7</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p6</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0.7</span>

    <span class="c1">// int[100] で各要素は -2</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">p7</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p7</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// -2</span>

    <span class="c1">// double[6][4] で、各 double[4] は { 0.0, 0.1, 0.2, 0.3 }</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">p8</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">({</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p8</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0.3</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>0
0
0
0
-1
0.7
-2
0.3
</code></pre></div></p>
<h3 id="stdshift_left-stdshift_right-p0769r2">範囲の要素を左右にシフトする <code>std::shift_left()</code>, <code>std::shift_right()</code> 関数 <a href="https://wg21.link/P0769R2">(P0769R2)</a><a class="headerlink" href="#stdshift_left-stdshift_right-p0769r2" title="Permanent link">&para;</a></h3>
<p>ある範囲の要素を左右に移動させたいときは <code>std::rotate()</code> を使う方法がありましたが、はみ出た分は回転して反対側に移動する操作であるため、それらの値が不要な場合は余計なコストが発生していました。また、<code>std::rotate()</code> では要素をどちらにどれだけ移動するかという意図を明快に表現できませんでした。</p>
<p>C++20 では、ある範囲の要素を回転無しで移動（シフト）させる <code>std::shift_left(first, last, n)</code>, <code>std::shift_right(first, last, n)</code> 関数が追加されます。移動させる要素の範囲を <code>first</code>, <code>last</code> で指定し、<code>n</code> 個分左右にシフトします。<code>n</code> が 0 以下の場合は何もしません。移動により要素がなくなった部分は有効で未規定の状態になるため、新しい要素を代入するか、<code>erase()</code> で削除します。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>

        <span class="c1">// 左へ 1 ローテ―ト</span>
        <span class="c1">// { 2, 3, 4, 5, 1 }</span>
        <span class="n">std</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span> <span class="c1">// 2 3 4 5 6</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>

        <span class="c1">// 左へ 1 シフト</span>
        <span class="c1">// { 2, 3, 4, 5, (未規定) }</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shift_left</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

        <span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span> <span class="c1">// 2 3 4 5 6</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>2 3 4 5 6 
2 3 4 5 6 
</code></pre></div></p>
<h3 id="stdstring_view-p1391r4"><code>std::string_view</code> のコンストラクタに、範囲のイテレータペアを受け取るオーバーロードを追加 <a href="https://wg21.link/P1391R4">(P1391R4)</a><a class="headerlink" href="#stdstring_view-p1391r4" title="Permanent link">&para;</a></h3>
<p>これまでは、メモリ連続な範囲から <code>std::string_view</code> を作成するには、先頭ポインタとサイズを渡す必要があり、イテレータを使用することはできませんでした。</p>
<p>C++20 では、イテレータコンセプト <code>std::contiguous_iterator&lt;It&gt;</code> を満たす先頭イテレータ <code>It</code> と、<code>std::sized_sentinel_for&lt;It&gt;</code> を満たすイテレータ <code>End</code> による <code>string_view::string_view(It first, End last);</code> というコンストラクタのオーバーロードが追加されます。これにより、<code>char</code> 型の配列や <code>std::vector&lt;char&gt;</code>, 非標準のライブラリで使われている様々な文字列クラスからの <code>std::string_view</code> の構築が、イテレータを使う方法で実現できるようになります。</p>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">chars</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="sc">&#39;E&#39;</span> <span class="p">};</span>

    <span class="c1">// C++17 まで</span>
    <span class="c1">//const std::string_view sv{ chars.data(), chars.size() };</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span><span class="p">{</span> <span class="n">chars</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">chars</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sv</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>ABCDE
</code></pre></div></p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../.." title="Home" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  前
                </span>
                Home
              </div>
            </div>
          </a>
        
        
          <a href="../cppx/" title="C++23 以降に向けた提案" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  次
                </span>
                C++23 以降に向けた提案
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            To the extent possible under law, Ryo Suzuki has waived all copyright and related or neighboring rights to C++ の歩き方 | CppMap. Third party copyrights are property of their respective owners.
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
  <div class="md-footer-social">
    
      
      
        
        
      
      <a href="https://twitter.com/Reputeless" target="_blank" rel="noopener" title="twitter.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
      </a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.b39636ac.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "\u30af\u30ea\u30c3\u30d7\u30dc\u30fc\u30c9\u3078\u30b3\u30d4\u30fc", "clipboard.copied": "\u30b3\u30d4\u30fc\u3057\u307e\u3057\u305f", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\u3000\u3001\u3002\uff0c\uff0e]+", "search.result.placeholder": "\u691c\u7d22\u30ad\u30fc\u30ef\u30fc\u30c9\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044", "search.result.none": "\u4f55\u3082\u898b\u3064\u304b\u308a\u307e\u305b\u3093\u3067\u3057\u305f", "search.result.one": "1\u4ef6\u898b\u3064\u304b\u308a\u307e\u3057\u305f", "search.result.other": "#\u4ef6\u898b\u3064\u304b\u308a\u307e\u3057\u305f"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.a68abb33.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>