



<!doctype html>
<html lang="ja" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="C++20 の新しい言語機能と標準ライブラリ機能の解説">
      
      
        <link rel="canonical" href="https://cppmap.github.io/standardization/cpp20/">
      
      
        <meta name="author" content="Ryo Suzuki">
      
      
        <meta name="lang:clipboard.copy" content="クリップボードへコピー">
      
        <meta name="lang:clipboard.copied" content="コピーしました">
      
        <meta name="lang:search.language" content="en, ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="何も見つかりませんでした">
      
        <meta name="lang:search.result.one" content="1件見つかりました">
      
        <meta name="lang:search.result.other" content="#件見つかりました">
      
        <meta name="lang:search.tokenizer" content="[\s　、。，．がのをにへとでやかもる「」『』]+">
      
      <link rel="shortcut icon" href="../../assets/images/logo.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.2">
    
    
      
        <title>C++20 の新機能 - C++ の歩き方 | CppMap</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.adb8469c.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="../../cppmap_styles.css">
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#c20" tabindex="0" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://cppmap.github.io/" title="C++ の歩き方 | CppMap" aria-label="C++ の歩き方 | CppMap" class="md-header-nav__button md-logo">
          
            <i class="md-icon">donut_small</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              C++ の歩き方 | CppMap
            </span>
            <span class="md-header-nav__topic">
              
                C++20 の新機能
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="検索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            検索キーワードを入力してください
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/cppmap/cppmap.docs" title="リポジトリへ" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    cppmap/cppmap.docs
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="./" class="md-tabs__link md-tabs__link--active">
          C++ 規格
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../articles/comment-tricks/" class="md-tabs__link">
          記事
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../learn/books/" class="md-tabs__link">
          学習
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../libraries/boost/" class="md-tabs__link">
          ライブラリ
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../tools/onlinecompilers/" class="md-tabs__link">
          ツール
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../contribution/contributors/" class="md-tabs__link">
          貢献
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://cppmap.github.io/" title="C++ の歩き方 | CppMap" class="md-nav__button md-logo">
      
        <i class="md-icon">donut_small</i>
      
    </a>
    C++ の歩き方 | CppMap
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/cppmap/cppmap.docs" title="リポジトリへ" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    cppmap/cppmap.docs
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      C++ 規格
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        C++ 規格
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        C++20 の新機能
      </label>
    
    <a href="./" title="C++20 の新機能" class="md-nav__link md-nav__link--active">
      C++20 の新機能
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目次</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    言語機能
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0683r1" class="md-nav__link">
    ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0704r1" class="md-nav__link">
    メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p1236r1" class="md-nav__link">
    符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8-bit-2" class="md-nav__link">
    （参考）符号付き 8-bit 整数の 2 進表現
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-no_unique_address-p0840r2" class="md-nav__link">
    メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename-p0634r3" class="md-nav__link">
    型名であることが明らかな文脈で typename を省略可能に (P0634R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1064r0" class="md-nav__link">
    定数式での仮想関数呼び出しが可能に (P1064R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_id-dynamic_cast-constexpr-p1327r1" class="md-nav__link">
    type_id と dynamic_cast が constexpr に (P1327R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1330r0" class="md-nav__link">
    定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try-catch-p1002r1" class="md-nav__link">
    定数式の文脈では try-catch を無視するように (P1002R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deprecated-p1161r3" class="md-nav__link">
    添字式にかかるコンマ演算子の使用を deprecated に (P1161R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-p1099r5" class="md-nav__link">
    スコープ付き列挙型に対する using 宣言ができるように (P1099R5)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1771r1" class="md-nav__link">
    コンストラクタに [[nodiscard]] が使えるように (P1771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inline-namespace-p1094r2" class="md-nav__link">
    ネストした名前空間定義で inline namespace を使えるように (P1094R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#private-p0969r0" class="md-nav__link">
    本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった仕様を修正 (P0969R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1008r1" class="md-nav__link">
    ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 (P1008R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#throw-p0619r4" class="md-nav__link">
    throw() による動的例外指定を削除 (P0619R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1301r4" class="md-nav__link">
    メッセージ付きの [[nodiscard]] 属性 (P1301R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0329r4" class="md-nav__link">
    指示付き初期化子による集成体の初期化 (P0329R4)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    標準ライブラリ
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0457r2" class="md-nav__link">
    文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operatorbasic_istream-chart-chartn-p0487r1" class="md-nav__link">
    operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p0600r1" class="md-nav__link">
    戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-constexpr-p1023r0-p1032r1" class="md-nav__link">
    &lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chrono-zero-min-max-noexcept-p0972r0" class="md-nav__link">
    &lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointer_traits-constexpr-p1006r1" class="md-nav__link">
    pointer_traits が constexpr に (P1006R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assume_aligned-p1007r3" class="md-nav__link">
    ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make-p1020r1" class="md-nav__link">
    スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_type-p0919r3" class="md-nav__link">
    非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdmidpoint-p0811r3" class="md-nav__link">
    2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdlerp-p0811r3" class="md-nav__link">
    2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-p0754r2" class="md-nav__link">
    実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_nothrow_convertible-p0758r1" class="md-nav__link">
    例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdto_address-p0653r2" class="md-nav__link">
    ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-constexpr-p0415r1" class="md-nav__link">
    &lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_constant_evaluated-p0595r2" class="md-nav__link">
    コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0020r6" class="md-nav__link">
    浮動小数点数型のアトミック操作を拡張 (P0020R6)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmemory_order-enum-class-p0439r0" class="md-nav__link">
    std::memory_order を enum class に変更 (P0439R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-p0809r0" class="md-nav__link">
    Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0463r1" class="md-nav__link">
    実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cv-stdremove_cvref-trait-p0550r2" class="md-nav__link">
    型から cv 修飾と参照を除去する std::remove_cvref trait (P0550R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddecay-p0777r1" class="md-nav__link">
    標準ライブラリでの不必要な std::decay の使用を回避 (P0777R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numbers-p0631r8" class="md-nav__link">
    数学定数を提供する &lt;numbers&gt; ヘッダ (P0631R8)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basic_stringreserve-capacity-p0966r1" class="md-nav__link">
    basic_string::reserve() が capacity を縮小しないように (P0966R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constains-p0458r2" class="md-nav__link">
    連想コンテナに constains() メンバ関数を追加 (P0458R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stderase-stderase_if-p1209r0" class="md-nav__link">
    コンテナから指定した要素を削除する操作に一貫して使える std::erase(), std::erase_if() 関数 (P1209R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdbit_cast-p0476r2" class="md-nav__link">
    バイト列の再解釈キャストを補助する std::bit_cast() 関数 (P0476R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numeric-p0616r0" class="md-nav__link">
    &lt;numeric&gt; の関数の非効率な実装を改善 (P0616R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p0556r3-p1355r2-p1956r1" class="md-nav__link">
    2 の累乗数に関するユーティリティ関数を追加 (P0556R3), (P1355R2), (P1956R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdlist-stdforward_list-p0646r1" class="md-nav__link">
    std::list と std::forward_list の要素削除メンバ関数が、削除した要素数を返すように (P0646R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_bounded_array-stdis_unbounded_array-p1357r1" class="md-nav__link">
    要素数が決まっている配列型かどうかを調べる型特性 std::is_bounded_array, std::is_unbounded_array (P1357R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfunction-noexcept-p0771r1" class="md-nav__link">
    std::function のムーブコンストラクタが noexcept に (P0771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utility-algorithm-constexpr-p0202r3-p0879r0" class="md-nav__link">
    &lt;utility&gt;, &lt;algorithm&gt; の多くの関数が constexpr に (P0202R3), (P0879R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete-p0722r3" class="md-nav__link">
    デストラクタを自動で呼ばない delete 演算子オーバーロード (P0722R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0553r4" class="md-nav__link">
    ビット循環シフト・ビットカウント関数 (P0553R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdarray-stdto_array-p0325r4" class="md-nav__link">
    組み込み配列から std::array を作成する std::to_array() (P0325R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfilesystemcreate_directory-p1164r1" class="md-nav__link">
    std::filesystem::create_directory() の挙動を直感的に (P1164R1)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../cppx/" title="C++23 以降に向けた提案" class="md-nav__link">
      C++23 以降に向けた提案
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../meetings/" title="標準化会議" class="md-nav__link">
      標準化会議
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../status/" title="処理系の対応状況" class="md-nav__link">
      処理系の対応状況
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../working-drafts/" title="C++ 規格書" class="md-nav__link">
      C++ 規格書
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../header/" title="C++ 標準ライブラリ" class="md-nav__link">
      C++ 標準ライブラリ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      記事
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        記事
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/comment-tricks/" title="コメントアウトのトリック" class="md-nav__link">
      コメントアウトのトリック
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/it-compiles/" title="なぜかコンパイルできる" class="md-nav__link">
      なぜかコンパイルできる
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/it-does-not-compile/" title="なぜかコンパイルできない" class="md-nav__link">
      なぜかコンパイルできない
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/how-to-read-keywords/" title="予約語の読みと名前の由来" class="md-nav__link">
      予約語の読みと名前の由来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/how-to-read-libraries/" title="標準ライブラリの読みと名前の由来" class="md-nav__link">
      標準ライブラリの読みと名前の由来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/ieee754-arithmetic/" title="IEEE 754 演算のルール" class="md-nav__link">
      IEEE 754 演算のルール
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/acronyms/" title="C++ 関連の略語" class="md-nav__link">
      C++ 関連の略語
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/type-traits/" title="C++ 型特性 早見表" class="md-nav__link">
      C++ 型特性 早見表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/member-access/" title="C++ アクセス指定子の効果" class="md-nav__link">
      C++ アクセス指定子の効果
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      学習
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        学習
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/books/" title="C++ 書籍" class="md-nav__link">
      C++ 書籍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/online-resources/" title="C++ オンライン資料" class="md-nav__link">
      C++ オンライン資料
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/studymeetings/" title="国内の C++ 勉強会" class="md-nav__link">
      国内の C++ 勉強会
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/communities/" title="C++ コミュニティ" class="md-nav__link">
      C++ コミュニティ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/conferences/" title="C++ カンファレンス" class="md-nav__link">
      C++ カンファレンス
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      ライブラリ
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        ライブラリ
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/boost/" title="Boost" class="md-nav__link">
      Boost
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/containers/" title="コンテナ" class="md-nav__link">
      コンテナ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/text-data/" title="テキストデータ" class="md-nav__link">
      テキストデータ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/multi-threading/" title="並行・並列" class="md-nav__link">
      並行・並列
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/testing/" title="テストフレームワーク" class="md-nav__link">
      テストフレームワーク
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/math/" title="数学" class="md-nav__link">
      数学
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      ツール
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        ツール
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/onlinecompilers/" title="C++ オンラインコンパイラ" class="md-nav__link">
      C++ オンラインコンパイラ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/compilers/" title="C++ コンパイラ" class="md-nav__link">
      C++ コンパイラ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/package-manager/" title="C++ パッケージマネージャ" class="md-nav__link">
      C++ パッケージマネージャ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/code-formatter/" title="C++ コードフォーマッタ" class="md-nav__link">
      C++ コードフォーマッタ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      貢献
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        貢献
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../contribution/contributors/" title="コントリビュータ" class="md-nav__link">
      コントリビュータ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目次</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    言語機能
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0683r1" class="md-nav__link">
    ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0704r1" class="md-nav__link">
    メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p1236r1" class="md-nav__link">
    符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8-bit-2" class="md-nav__link">
    （参考）符号付き 8-bit 整数の 2 進表現
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-no_unique_address-p0840r2" class="md-nav__link">
    メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename-p0634r3" class="md-nav__link">
    型名であることが明らかな文脈で typename を省略可能に (P0634R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1064r0" class="md-nav__link">
    定数式での仮想関数呼び出しが可能に (P1064R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_id-dynamic_cast-constexpr-p1327r1" class="md-nav__link">
    type_id と dynamic_cast が constexpr に (P1327R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1330r0" class="md-nav__link">
    定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try-catch-p1002r1" class="md-nav__link">
    定数式の文脈では try-catch を無視するように (P1002R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deprecated-p1161r3" class="md-nav__link">
    添字式にかかるコンマ演算子の使用を deprecated に (P1161R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-p1099r5" class="md-nav__link">
    スコープ付き列挙型に対する using 宣言ができるように (P1099R5)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1771r1" class="md-nav__link">
    コンストラクタに [[nodiscard]] が使えるように (P1771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inline-namespace-p1094r2" class="md-nav__link">
    ネストした名前空間定義で inline namespace を使えるように (P1094R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#private-p0969r0" class="md-nav__link">
    本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった仕様を修正 (P0969R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1008r1" class="md-nav__link">
    ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 (P1008R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#throw-p0619r4" class="md-nav__link">
    throw() による動的例外指定を削除 (P0619R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1301r4" class="md-nav__link">
    メッセージ付きの [[nodiscard]] 属性 (P1301R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0329r4" class="md-nav__link">
    指示付き初期化子による集成体の初期化 (P0329R4)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    標準ライブラリ
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0457r2" class="md-nav__link">
    文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operatorbasic_istream-chart-chartn-p0487r1" class="md-nav__link">
    operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p0600r1" class="md-nav__link">
    戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-constexpr-p1023r0-p1032r1" class="md-nav__link">
    &lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chrono-zero-min-max-noexcept-p0972r0" class="md-nav__link">
    &lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointer_traits-constexpr-p1006r1" class="md-nav__link">
    pointer_traits が constexpr に (P1006R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assume_aligned-p1007r3" class="md-nav__link">
    ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make-p1020r1" class="md-nav__link">
    スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_type-p0919r3" class="md-nav__link">
    非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdmidpoint-p0811r3" class="md-nav__link">
    2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdlerp-p0811r3" class="md-nav__link">
    2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-p0754r2" class="md-nav__link">
    実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_nothrow_convertible-p0758r1" class="md-nav__link">
    例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdto_address-p0653r2" class="md-nav__link">
    ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-constexpr-p0415r1" class="md-nav__link">
    &lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_constant_evaluated-p0595r2" class="md-nav__link">
    コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0020r6" class="md-nav__link">
    浮動小数点数型のアトミック操作を拡張 (P0020R6)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmemory_order-enum-class-p0439r0" class="md-nav__link">
    std::memory_order を enum class に変更 (P0439R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-p0809r0" class="md-nav__link">
    Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0463r1" class="md-nav__link">
    実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cv-stdremove_cvref-trait-p0550r2" class="md-nav__link">
    型から cv 修飾と参照を除去する std::remove_cvref trait (P0550R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddecay-p0777r1" class="md-nav__link">
    標準ライブラリでの不必要な std::decay の使用を回避 (P0777R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numbers-p0631r8" class="md-nav__link">
    数学定数を提供する &lt;numbers&gt; ヘッダ (P0631R8)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basic_stringreserve-capacity-p0966r1" class="md-nav__link">
    basic_string::reserve() が capacity を縮小しないように (P0966R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constains-p0458r2" class="md-nav__link">
    連想コンテナに constains() メンバ関数を追加 (P0458R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stderase-stderase_if-p1209r0" class="md-nav__link">
    コンテナから指定した要素を削除する操作に一貫して使える std::erase(), std::erase_if() 関数 (P1209R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdbit_cast-p0476r2" class="md-nav__link">
    バイト列の再解釈キャストを補助する std::bit_cast() 関数 (P0476R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numeric-p0616r0" class="md-nav__link">
    &lt;numeric&gt; の関数の非効率な実装を改善 (P0616R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p0556r3-p1355r2-p1956r1" class="md-nav__link">
    2 の累乗数に関するユーティリティ関数を追加 (P0556R3), (P1355R2), (P1956R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdlist-stdforward_list-p0646r1" class="md-nav__link">
    std::list と std::forward_list の要素削除メンバ関数が、削除した要素数を返すように (P0646R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_bounded_array-stdis_unbounded_array-p1357r1" class="md-nav__link">
    要素数が決まっている配列型かどうかを調べる型特性 std::is_bounded_array, std::is_unbounded_array (P1357R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfunction-noexcept-p0771r1" class="md-nav__link">
    std::function のムーブコンストラクタが noexcept に (P0771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utility-algorithm-constexpr-p0202r3-p0879r0" class="md-nav__link">
    &lt;utility&gt;, &lt;algorithm&gt; の多くの関数が constexpr に (P0202R3), (P0879R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete-p0722r3" class="md-nav__link">
    デストラクタを自動で呼ばない delete 演算子オーバーロード (P0722R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0553r4" class="md-nav__link">
    ビット循環シフト・ビットカウント関数 (P0553R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdarray-stdto_array-p0325r4" class="md-nav__link">
    組み込み配列から std::array を作成する std::to_array() (P0325R4)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfilesystemcreate_directory-p1164r1" class="md-nav__link">
    std::filesystem::create_directory() の挙動を直感的に (P1164R1)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="c20">C++20 の新機能<a class="headerlink" href="#c20" title="Permanent link">&para;</a></h1>
<p>C++20 の変更すべてをカバーするために、項目追加・執筆作業中です（完成度 約 30%）</p>
<h2 id="_1">言語機能<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h3 id="p0683r1">ビットフィールドにデフォルトの初期値を設定可能に <a href="http://wg21.link/p0683r1">(P0683R1)</a><a class="headerlink" href="#p0683r1" title="Permanent link">&para;</a></h3>
<p>ビットフィールドにおけるビット幅の指定に続いて、<code class="codehilite"><span class="err">=</span></code> 演算子または <code class="codehilite"><span class="err">{}</span></code> 初期化子を使って初期化式を記述できるようになります。</p>
<p><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">char</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Forest</span><span class="p">,</span> <span class="n">Hill</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">Desert</span><span class="p">,</span> <span class="n">Tundra</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Tile</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">height</span> <span class="p">:</span> <span class="mi">4</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// デフォルト値を 1 に</span>
    <span class="n">Terrain</span> <span class="nl">terrain</span> <span class="p">:</span> <span class="mi">3</span> <span class="o">=</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Open</span><span class="p">;</span> <span class="c1">// デフォルト値を明示的に Terrain::Open に</span>
    <span class="kt">bool</span> <span class="nl">passable</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// デフォルト値を true に</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="n">Tile</span> <span class="n">tile1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile1</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile1</span><span class="p">.</span><span class="n">terrain</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tile1</span><span class="p">.</span><span class="n">passable</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">Tile</span> <span class="n">tile2</span><span class="p">{</span> <span class="mi">15</span><span class="p">,</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">,</span> <span class="nb">false</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile2</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile2</span><span class="p">.</span><span class="n">terrain</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tile2</span><span class="p">.</span><span class="n">passable</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="err">1, 0, true</span>
<span class="err">15, 3, false</span>
</code></pre></div></p>
<h3 id="p0704r1">メンバポインタ演算子の仕様を一貫性のために修正 <a href="http://wg21.link/p0704r1">(P0704R1)</a><a class="headerlink" href="#p0704r1" title="Permanent link">&para;</a></h3>
<p>C++17 までのメンバポインタ演算子 <code class="codehilite"><span class="err">.*</span></code> は「右辺値オブジェクトから、左辺値参照修飾されたメンバ関数ポインタに使うことは不適格」という規格文面になっていました。そのため、同じ意味をもつ次の 2 つのプログラムで後者だけ不適格とされ、一貫性がありませんでした。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Text</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_data</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Text</span><span class="p">{</span> <span class="s">&quot;Hello&quot;</span> <span class="p">}.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">Text</span><span class="p">{</span> <span class="s">&quot;Hello&quot;</span> <span class="p">}.</span><span class="o">*&amp;</span><span class="n">Text</span><span class="o">::</span><span class="n">get</span><span class="p">)()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// C++17 までは不適格、C++20 から OK</span>
<span class="p">}</span>
</code></pre></div>
C++20 では「右辺値オブジェクトから、左辺値参照修飾された "非 const" メンバ関数ポインタに使うことは不適格」と文面を修正し、後者もコンパイルできるようになります。</p>
<h3 id="2-p1236r1">符号付き整数型の負数表現を 2 の補数と規定 <a href="http://wg21.link/p1236r1">(P1236R1)</a><a class="headerlink" href="#2-p1236r1" title="Permanent link">&para;</a></h3>
<p>ほぼすべての現代的なコンピュータで、符号付き整数型の負数は 2 の補数で表現されます。しかし、C++ では負数の表現方法について規格で定めていなかったため、（現実的ではありませんが）2 の補数以外で負数表現を実装する余地も残されていました。C++20 からは 2 の補数のみを許可するよう規格文言が修正されました。<br />
近年のアーキテクチャで 2 の補数以外を使う例は、1 の補数を使う Unisys 2200 があります。また過去には符号と絶対値で表現するアーキテクチャもありました。これらはモダンな C++ を開発環境として使用しないので、この規格変更による影響は無いと考えられます。</p>
<h4 id="8-bit-2">（参考）符号付き 8-bit 整数の 2 進表現<a class="headerlink" href="#8-bit-2" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>10 進表現</th>
<th>2 の補数</th>
<th>1 の補数</th>
<th>符号と絶対値</th>
</tr>
</thead>
<tbody>
<tr>
<td>127</td>
<td>01111111</td>
<td>01111111</td>
<td>01111111</td>
</tr>
<tr>
<td>126</td>
<td>01111110</td>
<td>01111110</td>
<td>01111110</td>
</tr>
<tr>
<td>125</td>
<td>01111101</td>
<td>01111101</td>
<td>01111101</td>
</tr>
<tr>
<td>2</td>
<td>00000010</td>
<td>00000010</td>
<td>00000010</td>
</tr>
<tr>
<td>1</td>
<td>00000001</td>
<td>00000001</td>
<td>00000001</td>
</tr>
<tr>
<td>0</td>
<td>00000000</td>
<td>00000000</td>
<td>00000000</td>
</tr>
<tr>
<td>-0</td>
<td></td>
<td>11111111</td>
<td>10000000</td>
</tr>
<tr>
<td>-1</td>
<td>11111111</td>
<td>11111110</td>
<td>10000001</td>
</tr>
<tr>
<td>-2</td>
<td>11111110</td>
<td>11111101</td>
<td>10000010</td>
</tr>
<tr>
<td>-126</td>
<td>10000010</td>
<td>10000001</td>
<td>11111110</td>
</tr>
<tr>
<td>-127</td>
<td>10000001</td>
<td>10000000</td>
<td>11111111</td>
</tr>
<tr>
<td>-128</td>
<td>10000000</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="0-no_unique_address-p0840r2">メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる <code class="codehilite"><span class="o">[</span><span class="n">[no_unique_address</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を追加 <a href="http://wg21.link/p0840r2">(P0840R2)</a><a class="headerlink" href="#0-no_unique_address-p0840r2" title="Permanent link">&para;</a></h3>
<p>アロケータなどをクラスのメンバとして保持するとき、それがステートレスな空のクラスであってもオブジェクトのアドレスを一意に用意しないといけないため、サイズを 0 にできずメモリ消費が無駄に増えてしまう問題がありました。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4 より大きい</span>
<span class="p">}</span>
</code></pre></div>
これを回避するために「空の基底クラスは最適化によってサイズ 0 にしてよい」という仕様を利用した Empty Base Optimization (EBO) というテクニックがあり、標準ライブラリでも　<code class="codehilite"><span class="c">std::unique_ptr</span></code> や <code class="codehilite"><span class="c">std::shared_ptr</span></code>, <code class="codehilite"><span class="c">std::vector</span></code> などに使われています。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">X</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Empty</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div>
しかし、これらのクラスで継承による EBO を実装するとコードが複雑になるという欠点がありました。C++20 ではメンバの宣言に <code class="codehilite"><span class="o">[</span><span class="n">[no_unique_address</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を付けることで、継承を使わなくてもコンパイラが EBO と同じような最適化をできるようになり、従来の継承による EBO を使っていたコードを、より単純なコードに置き換えられます。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span> <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="typename-p0634r3">型名であることが明らかな文脈で <code class="codehilite"><span class="err">typename</span></code> を省略可能に <a href="https://wg21.link/P0634R3">(P0634R3)</a><a class="headerlink" href="#typename-p0634r3" title="Permanent link">&para;</a></h3>
<p>C++17 で依存名が型である場合に <code class="codehilite"><span class="err">typename</span></code> を付けないのは、派生クラス定義時の基底クラスの指定と、初期化子リストでの基底クラスの指定のみでした（厳密にはこの 2 つには <code class="codehilite"><span class="err">typename</span></code> を付けられません）。C++20 では、型名しか使えないさらにいくつかの文脈で <code class="codehilite"><span class="err">typename</span></code> が省略可能になります。次のサンプルコードの左右タブで比較できます。</p>
<div class="superfences-tabs">
<input name="__tabs_1" type="radio" id="__tab_1_0" checked="checked" />
<label for="__tab_1_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">S</span> <span class="p">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="c1">// 派生クラス定義時の基底クラスの指定</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>

    <span class="n">S</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 初期化子リストでの基底クラスの指定</span>

    <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">pointer</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">min_size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">MaxSize</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<input name="__tabs_1" type="radio" id="__tab_1_1" />
<label for="__tab_1_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;</span> <span class="c1">// OK</span>
<span class="k">struct</span> <span class="nl">S</span> <span class="p">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="c1">// 派生クラス定義時の基底クラスの指定</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="n">S</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 初期化子リストでの基底クラスの指定</span>

    <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">T</span><span class="o">::</span><span class="n">pointer</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="nf">min_size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// OK</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">MaxSize</span><span class="p">();</span> <span class="c1">// OK</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
</div>
<h3 id="p1064r0">定数式での仮想関数呼び出しが可能に <a href="https://wg21.link/P1064">(P1064R0)</a><a class="headerlink" href="#p1064r0" title="Permanent link">&para;</a></h3>
<p>コンパイル時に決定可能であれば、参照やポインタを通した仮想関数の呼び出しを <code class="codehilite"><span class="err">constexpr</span></code> にできるようになります。<code class="codehilite"><span class="err">constexpr</span></code> 修飾された仮想関数を非 <code class="codehilite"><span class="err">constexpr</span></code> 関数でオーバーライドすることや、その逆も可能です。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">GetVersion</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">version</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">Cpp20</span> <span class="n">cpp20</span><span class="p">;</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetVersion</span><span class="p">(</span><span class="n">cpp17</span><span class="p">)</span> <span class="o">==</span> <span class="mi">17</span><span class="p">);</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetVersion</span><span class="p">(</span><span class="n">cpp20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="type_id-dynamic_cast-constexpr-p1327r1"><code class="codehilite"><span class="err">type_id</span></code> と <code class="codehilite"><span class="err">dynamic_cast</span></code> が constexpr に <a href="https://wg21.link/P1327">(P1327R1)</a><a class="headerlink" href="#type_id-dynamic_cast-constexpr-p1327r1" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="err">dynamic_cast</span></code> と <code class="codehilite"><span class="err">type_id</span></code> が、例外を投げるケースを除いて <code class="codehilite"><span class="err">constexpr</span></code> になります。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">*</span> <span class="n">pCpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cpptype</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">pCpp</span><span class="p">);</span>

    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">refCpp</span> <span class="o">=</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp17</span><span class="o">&amp;</span> <span class="n">redCpp2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpp17</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">refCpp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>次のように例外を投げるケースでは <code class="codehilite"><span class="err">constexpr</span></code> にできずコンパイルエラーになります。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Cpp</span><span class="o">*</span> <span class="n">pCpp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cpptype</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">pCpp</span><span class="p">);</span> <span class="c1">//コンパイルエラー: 例外 std::bad_typeid を投げるため constexpr 不可</span>

    <span class="k">constexpr</span> <span class="k">static</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">refCpp</span> <span class="o">=</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp20</span><span class="o">&amp;</span> <span class="n">redCpp2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpp20</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">refCpp</span><span class="p">);</span> <span class="c1">// コンパイルエラー: 例外 std::bad_cast を投げるため constexpr 不可</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="p1330r0">定数式において共用体のアクティブメンバの切り替えが可能に <a href="https://wg21.link/P1330">(P1330R0)</a><a class="headerlink" href="#p1330r0" title="Permanent link">&para;</a></h3>
<p>共用体のアクティブメンバとは、最後に初期化または値を代入したメンバのことです。C++17 では共用体の初期化やアクティブメンバへのアクセスを定数式で行えましたが、アクティブメンバの切り替えはできませんでした。定数式でのアクティブメンバの切り替えが可能になると、共用体によって実装される <code class="codehilite"><span class="c">std::string</span></code> や <code class="codehilite"><span class="c">std::optional</span></code> などの標準ライブラリクラスのメンバ関数の <code class="codehilite"><span class="err">constexpr</span></code> 対応を拡充できます。非アクティブメンバへのアクセスは未定義動作なので、定数式で行うとコンパイルエラーになります。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>

<span class="k">union</span> <span class="n">Value</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">Value</span> <span class="nf">GetFloat</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Value</span><span class="p">{</span> <span class="n">x</span> <span class="p">};</span> <span class="c1">// value.f がアクティブメンバ</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">Value</span> <span class="nf">GetUint</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Value</span> <span class="n">value</span> <span class="o">=</span> <span class="n">GetFloat</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span> <span class="c1">// value.f がアクティブメンバ</span>
    <span class="n">value</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// value.i がアクティブメンバに</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetUint</span><span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="n">i</span> <span class="o">==</span> <span class="mi">123</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="try-catch-p1002r1">定数式の文脈では <code class="codehilite"><span class="err">try-catch</span></code> を無視するように <a href="https://wg21.link/P1002">(P1002R1)</a><a class="headerlink" href="#try-catch-p1002r1" title="Permanent link">&para;</a></h3>
<p>これまで <code class="codehilite"><span class="err">constexpr</span></code> 関数の中には <code class="codehilite"><span class="err">try-catch</span></code> ブロックを書くことができませんでした。しかし、<code class="codehilite"><span class="c">std::vector</span></code> 等のコンテナを <code class="codehilite"><span class="err">constexpr</span></code> 対応するにあたっては、この制限が障壁となるため、C++20 では <code class="codehilite"><span class="err">constexpr</span></code> 関数の中の <code class="codehilite"><span class="err">try-catch</span></code> は、定数式として評価されるときには無視するよう仕様が改められます。定数式の評価中に例外を投げるようであればコンパイルエラーになります。<code class="codehilite"><span class="c">std::vector</span></code> などを <code class="codehilite"><span class="err">constexpr</span></code> 対応させるための措置であり、将来の C++ におけるコンパイル時例外処理の実現を否定するものではありません。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt; </span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt; </span><span class="cp"></span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">AddU8</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">{};</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">DoubleU8</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">AddU8</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">except</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">DoubleU8</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span> <span class="o">==</span> <span class="mi">246</span><span class="p">);</span> <span class="c1">// OK: 例外を投げずに定数式として評価可能</span>

    <span class="c1">//static_assert(DoubleU8(200) &gt; 0); // コンパイルエラー: 定数式として評価される constexpr 関数内で例外を投げるため</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;result: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">DoubleU8</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// OK: 実行時に評価される関数で例外が発生する</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="deprecated-p1161r3">添字式にかかるコンマ演算子の使用を deprecated に <a href="https://wg21.link/P1161R3">(P1161R3)</a><a class="headerlink" href="#deprecated-p1161r3" title="Permanent link">&para;</a></h3>
<p>これまで <code class="codehilite"><span class="err">array[x, y]</span></code> というコードでは、コンマ演算子の作用で <code class="codehilite"><span class="err">y</span></code> が添字演算の引数として渡されました。しかし、この挙動は紛らわしく、将来の C++ 標準ライブラリに多次元配列クラスが実装されたとき、添字演算子を複数の引数に対応させるような規格を追加するうえでの障壁にもなります。そのため、C++20 から、<code class="codehilite"><span class="err">array[(x, y)]</span></code> のように括弧を使用する場合をのぞき、添字式にかかるコンマ演算子の使用が deprecated になります。古いコードで deprecated な書き方をしていた場合、前述のように <code class="codehilite"><span class="err">()</span></code> を付けることで、コードの挙動に影響を与えずに移植が可能です。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">v</span><span class="p">[</span><span class="o">++</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// C++17 まで OK, C++20 から deprecated</span>

    <span class="n">v</span><span class="p">[(</span><span class="o">++</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="using-p1099r5">スコープ付き列挙型に対する using 宣言ができるように <a href="http://wg21.link/p1099r5">(P1099R5)</a><a class="headerlink" href="#using-p1099r5" title="Permanent link">&para;</a></h3>
<p>これまでは、enum class のスコープ解決を省略する方法が無く、次のような <code class="codehilite"><span class="err">switch</span></code> で、列挙型の名前が何度も登場するようなコードを書く必要があり、読みにくく、長い列挙型の名前が避けられる原因になっていました。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span> <span class="n">terrain</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view_literals</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">terrain</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Open</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;Open&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Mountain</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;Mountain&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">River</span><span class="p">:</span>    <span class="k">return</span> <span class="s">&quot;River&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Ocean</span><span class="p">:</span>    <span class="k">return</span> <span class="s">&quot;Ocean&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>                <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
C++20 では <code class="codehilite"><span class="err">using</span></code> 宣言を拡張し、<code class="codehilite"><span class="err">using Terrain::Open;</span></code> で <code class="codehilite"><span class="err">Open</span></code> をエイリアスとして使えるようになります。また <code class="codehilite"><span class="err">using enum</span></code> 宣言という新しい仕組みにより、<code class="codehilite"><span class="err">using enum Terrain;</span></code> で <code class="codehilite"><span class="err">Terrain</span></code> がローカルスコープに導入され、スコープ解決演算子を使わずにその列挙子を使えるようになります。
<div class="codehilite"><pre><span></span><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span> <span class="n">terrain</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view_literals</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">terrain</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">Terrain</span><span class="p">;</span> <span class="c1">// using enum 宣言で、列挙型の名前 Terrain をローカルスコープに導入</span>
    <span class="k">case</span> <span class="nl">Open</span><span class="p">:</span>      <span class="k">return</span> <span class="s">&quot;Open&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Mountain</span><span class="p">:</span>  <span class="k">return</span> <span class="s">&quot;Mountain&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">River</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;River&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Ocean</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;Ocean&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">;</span> <span class="c1">// using 宣言で、列挙子 Mountain をローカルスコープに導入</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Mountain</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
なお、次のように複数の <code class="codehilite"><span class="err">using</span></code> 宣言によって名前の衝突が起こる場合はコンパイルエラーになります。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">State</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Closed</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">Terrain</span><span class="p">;</span> <span class="c1">// OK</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">State</span><span class="p">;</span>   <span class="c1">// コンパイルエラー: Terrain::Open と State::Open の名前が衝突</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="nodiscard-p1771r1">コンストラクタに <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> が使えるように <a href="http://wg21.link/p1771r1">(P1771R1)</a><a class="headerlink" href="#nodiscard-p1771r1" title="Permanent link">&para;</a></h3>
<p>C++17 で <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> が導入された際、仕様ではコンストラクタを対象としていませんでした（ただし、GCC では警告を出しつつもコンストラクタに付けた <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> をチェックしていました）。コンストラクタの呼び出しによって作成された一時オブジェクトが意図せず無視されたときに警告を出せると、ユーザの間違いを減らせます。そこで、コンストラクタにも <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を付けられるよう、C++17 向けの規格にさかのぼって仕様が修正され、C++20 および、この変更に対応した C++17 コンパイラで新仕様を利用できるようになります。なお、デストラクタを定義していた場合でも警告は消えません。
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="n">Circle</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

    <span class="n">Circle</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_r</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">),</span> <span class="n">r</span><span class="p">(</span><span class="n">_r</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Circle</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span> <span class="c1">// warning: nodiscard 属性のコンストラクタで作成された一時オブジェクトを無視</span>

    <span class="n">Circle</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">50</span><span class="p">).</span><span class="n">draw</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="inline-namespace-p1094r2">ネストした名前空間定義で <code class="codehilite"><span class="err">inline namespace</span></code> を使えるように <a href="http://wg21.link/p1094r2">(P1094R2)</a><a class="headerlink" href="#inline-namespace-p1094r2" title="Permanent link">&para;</a></h3>
<p>C++17 でネストした名前空間定義が導入されましたが、その中では <code class="codehilite"><span class="err">inline namespace</span></code> を使うことができず、<code class="codehilite"><span class="err">inline namespace</span></code> が <code class="codehilite"><span class="err">namespace</span></code> 内にある次のようなケースで恩恵を受けられませんでした。C++20 からはネストした名前空間定義の中で <code class="codehilite"><span class="err">inline</span></code> を使えるようになります。</p>
<div class="superfences-tabs">
<input name="__tabs_2" type="radio" id="__tab_2_0" checked="checked" />
<label for="__tab_2_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">mylib</span>
<span class="p">{</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">v2</span>
    <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">util</span>
        <span class="p">{</span>
            <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v2</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// v2</span>
<span class="p">}</span>
</code></pre></div></div>
<input name="__tabs_2" type="radio" id="__tab_2_1" />
<label for="__tab_2_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="kr">inline</span> <span class="n">v2</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v2</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// v2</span>
<span class="p">}</span>
</code></pre></div></div>
</div>
<h3 id="private-p0969r0">本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった仕様を修正 <a href="https://wg21.link/P0969R0">(P0969R0)</a><a class="headerlink" href="#private-p0969r0" title="Permanent link">&para;</a></h3>
<p>メンバ関数内で自身の <code class="codehilite"><span class="err">private</span></code> メンバにアクセスすることや、<code class="codehilite"><span class="err">friend</span></code> 指定された関数で該当クラスの <code class="codehilite"><span class="err">private</span></code> メンバ変数にアクセスすることは通常可能ですが、C++17 の構造化束縛はクラスの <code class="codehilite"><span class="err">public</span></code> メンバにしかバインドできないという規格文面の制約があり、次のようなケースで一貫性がありませんでした。この制約を課す合理的な理由は無かったため、C++17 向けの規格にさかのぼって仕様が修正され、アクセス可能であれば <code class="codehilite"><span class="err">private</span></code> メンバ変数をバインドできるようになります。C++20 および、この変更に対応した C++17 コンパイラで新仕様を利用できます。</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Date</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>

    <span class="kt">int</span> <span class="n">m_year</span><span class="p">,</span> <span class="n">m_month</span><span class="p">,</span> <span class="n">m_day</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

    <span class="k">friend</span> <span class="kt">void</span> <span class="n">Work</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">date</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="c1">// OK</span>
        <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_year</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_month</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_day</span><span class="p">;</span>

        <span class="c1">// これまではコンパイルエラー, C++20 以降 OK</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// friend 指定されている関数</span>
<span class="kt">void</span> <span class="nf">Work</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">date</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// OK</span>
    <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_year</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_month</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_day</span><span class="p">;</span>

    <span class="c1">// これまではコンパイルエラー, C++20 以降 OK</span>
    <span class="k">auto</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">date</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre></div>

<h3 id="p1008r1">ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 <a href="https://wg21.link/P1008R1">(P1008R1)</a><a class="headerlink" href="#p1008r1" title="Permanent link">&para;</a></h3>
<p>C++17 までは集成体の要件が緩かったため、コンストラクタについては、デフォルトコンストラクタが <code class="codehilite"><span class="err">= delete</span></code> または <code class="codehilite"><span class="err">private</span></code> であっても、集成体初期化によって初期化できる抜け道がありました。これはメンバ変数が意図しない値で初期化されるといった問題を引き起こします。C++20 からは集成体の要件が厳しくなり、ユーザ宣言されたコンストラクタがあるクラスは集成体にはなりません。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">B</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">C</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">;</span> <span class="c1">// コンパイルエラー</span>
    <span class="n">A</span> <span class="n">a2</span><span class="p">{};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>

    <span class="n">B</span> <span class="n">b1</span><span class="p">;</span> <span class="c1">// コンパイルエラー</span>
    <span class="n">B</span> <span class="n">b2</span><span class="p">{};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>

    <span class="n">C</span> <span class="n">c1</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">//コンパイルエラー</span>
    <span class="n">C</span> <span class="n">c2</span><span class="p">{</span> <span class="mi">123</span> <span class="p">};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="throw-p0619r4"><code class="codehilite"><span class="err">throw()</span></code> による動的例外指定を削除 <a href="https://wg21.link/P0619R4">(P0619R4)</a><a class="headerlink" href="#throw-p0619r4" title="Permanent link">&para;</a></h3>
<p>C++11 では、<code class="codehilite"><span class="err">noexcept</span></code> の追加に合わせ、<code class="codehilite"><span class="err">throw(typeid, ...)</span></code> や <code class="codehilite"><span class="err">throw()</span></code> による動的例外指定が非推奨化されました。C++17 では前者が削除されましたが、古いコードにおいて広く使われていた後者は、移行猶予のために <code class="codehilite"><span class="err">noexcept(true)</span></code> のエイリアスとして改められつつ保持されていました。C++20 では後者も削除されます。</p>
<h3 id="nodiscard-p1301r4">メッセージ付きの <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性 <a href="https://wg21.link/P1301R4">(P1301R4)</a><a class="headerlink" href="#nodiscard-p1301r4" title="Permanent link">&para;</a></h3>
<p>C++17 で追加された <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性は、ライブラリなどが提供する関数の誤用を防ぐ助けになりますが、関数がなぜ <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を持っているのかについて、利用者に十分な情報が伝わらない場合がありました。C++20 では <code class="codehilite"><span class="err">[[nodiscard(&quot;....&quot;)]]</span></code> のような形式でメッセージを追加できるようになります。戻り値の無視があった場合、コンパイラは警告に加えてこのメッセージを補足情報として出力できます。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Data</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_data</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_data</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">(</span><span class="s">&quot;Did you mean &#39;clear&#39;?&quot;</span><span class="p">)]]</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Data</span> <span class="n">data</span><span class="p">;</span>

    <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>コンパイラの出力例</p>
<div class="codehilite"><pre><span></span><code><span class="err">prog.cc:27:2: warning: ignoring return value of function declared with &#39;nodiscard&#39; attribute:</span>
<span class="err">        Did you mean &#39;clear&#39;? [-Wunused-result]</span>
<span class="err">        data.empty();</span>
<span class="err">        ^~~~~~~~~~</span>
<span class="err">1 warning generated.</span>
</code></pre></div>

<h3 id="p0329r4">指示付き初期化子による集成体の初期化 <a href="https://wg21.link/P0329R4">(P0329R4)</a><a class="headerlink" href="#p0329r4" title="Permanent link">&para;</a></h3>
<p>C++20 から、集成体において、メンバ変数名を指定した初期化（指示付き初期化子を用いた初期化: "Designated Initialization" ）ができるようになります。C 言語 (C99) にも同様の機能がありますが、C++20 では C99 の指示付き初期化子と比較して以下のような制約が追加されています。</p>
<ul>
<li>(a) 指示子の順番はメンバの宣言順と同じである必要がある</li>
<li>(b) 指示付き初期化子と通常の初期化子の混在はできない</li>
<li>(c) 同一メンバの指示付き初期化子は複数回使えない</li>
<li>(d) 指示付き初期化子はネストできない</li>
<li>(e) 配列の指示付き初期化はできない</li>
</ul>
<p>また、初期化子の評価順序が左から右であることが保証されます。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Item</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">Point</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">};</span> <span class="c1">// OK</span>
    <span class="n">Point</span> <span class="n">p2</span><span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">};</span> <span class="c1">// OK</span>
    <span class="n">Point</span> <span class="n">p3</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">};</span> <span class="c1">// OK: y は 0 に初期化される</span>
    <span class="n">Point</span> <span class="n">p4</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">};</span> <span class="c1">// OK: x は 0 に初期化される</span>
    <span class="n">F</span><span class="p">({</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="p">});</span> <span class="c1">// OK</span>

    <span class="n">Point</span> <span class="n">p4</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">30</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (a) 指示子の順番がメンバの宣言順と異なる</span>
    <span class="n">Point</span> <span class="n">p5</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (b) 指示付き初期化子と通常の初期化子は混在できない</span>
    <span class="n">Point</span> <span class="n">p6</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">30</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (c) 同一メンバの指示付き初期化子は複数回登場できない</span>

    <span class="n">Item</span> <span class="n">i1</span><span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;shield&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span> <span class="c1">// OK</span>
    <span class="n">Item</span> <span class="n">i2</span><span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span> <span class="c1">// OK: name は {} で初期化、pos は { -1, -1 } で初期化</span>

    <span class="n">Item</span> <span class="n">i3</span><span class="p">{</span> <span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">40</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (d) 指示付き初期化子はネストできない</span>

    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">};</span> <span class="c1">// コンパイルエラー: (e) 配列の指示付き初期化はできない</span>
<span class="p">}</span>
</code></pre></div>

<p>従来までの <code class="codehilite"><span class="err">Point p{}</span></code>, <code class="codehilite"><span class="err">Item i{}</span></code> のような集成体初期化を「指示付き初期化子が 0 個の初期化」と考えると、新しい挙動も理解しやすくなります。なお、次のように集成体ではないクラスの初期化には、指示付き初期化子は使えません。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_y</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// コンパイルエラー:</span>
    <span class="c1">// ユーザ宣言されたコンストラクタを持つため集成体ではない</span>
    <span class="c1">// 集成体でないため指示付き初期化子を使えない</span>
    <span class="n">Point</span> <span class="n">p</span><span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">};</span> 
<span class="p">}</span>
</code></pre></div>

<h2 id="_2">標準ライブラリ<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="p0457r2">文字列の先頭や末尾が、ある文字列と一致するか判定 <a href="https://wg21.link/P0457R2">(P0457R2)</a><a class="headerlink" href="#p0457r2" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="c">std::basic_string</span></code> と <code class="codehilite"><span class="c">std::basic_string_view</span></code> に、<code class="codehilite"><span class="err">starts_with()</span></code> と <code class="codehilite"><span class="err">ends_with()</span></code> メンバ関数が追加されます。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">HasPNGExtension</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">filePath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 文字列が &quot;.png&quot; で終わるなら true, それ以外は false を返す</span>
    <span class="k">return</span> <span class="n">filePath</span><span class="p">.</span><span class="n">ends_with</span><span class="p">(</span><span class="s">&quot;.png&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;picture.png&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;photo.jpg&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;music.mp3&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="err">true</span>
<span class="err">false</span>
<span class="err">false</span>
</code></pre></div></p>
<h3 id="operatorbasic_istream-chart-chartn-p0487r1"><code class="codehilite"><span class="err">operator&gt;&gt;(basic_istream&amp;, charT*)</span></code> の第二引数を <code class="codehilite"><span class="n">charT</span><span class="p">(</span><span class="o">&amp;</span><span class="p">)</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="w"></span></code> に変更して安全に <a href="https://wg21.link/P0487R1">(P0487R1)</a><a class="headerlink" href="#operatorbasic_istream-chart-chartn-p0487r1" title="Permanent link">&para;</a></h3>
<p>C++17 までの <code class="codehilite"><span class="err">operator&gt;&gt;(basic_istream&amp;, charT*)</span></code> は、関数にバッファのサイズが渡されないため、次のようなプログラムでバッファオーバーフローへの対策が必要でした。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="c1">// std::cin &gt;&gt; buffer; // 危険: バッファオーバーフローの可能性</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// OK: バッファオーバーフロー対策</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
C++20 では引数を次のように変更し、関数がバッファオーバーフローの対策を実装するようになります。
<div class="codehilite"><pre><span></span><code><span class="c1">// C++17 まで</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span><span class="o">&gt;</span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">charT</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>

<span class="c1">// C++20 から</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">charT</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)[</span><span class="n">N</span><span class="p">]);</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// OK: C++20 ではバッファオーバーフローを防げる</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
この変更に伴い、C++17 までは有効だった次のようなプログラムが、C++20 からコンパイルエラーになります。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// C++20 からはコンパイルエラー</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="nodiscard-p0600r1">戻り値の無視が不具合をもたらす関数に <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> を付与 <a href="https://wg21.link/P0600R1">(P0600R1)</a><a class="headerlink" href="#nodiscard-p0600r1" title="Permanent link">&para;</a></h3>
<p>C++17 で導入された <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を標準ライブラリで活用するようになります。C++20 では付与基準を「戻り値の無視がトラブルやメモリリークなどの重大なエラーを引き起こす C++ の関数」とし、<code class="codehilite"><span class="err">async()</span></code>, <code class="codehilite"><span class="err">launder()</span></code>, <code class="codehilite"><span class="err">allocate()</span></code>, <code class="codehilite"><span class="err">empty()</span></code>, <code class="codehilite"><span class="err">operator new()</span></code> が対象となっています。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>

    <span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// C++20 では警告</span>

    <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// C++20 では警告</span>
<span class="p">}</span>
</code></pre></div>
MSVC の標準ライブラリでは Visual Studio 2017 15.6 以降、規格の範囲を超えてより多くの関数（<a href="https://devblogs.microsoft.com/cppblog/c17-progress-in-vs-2017-15-5-and-15-6/">2,500 個以上</a>）に <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を使っています。その結果、<a href="https://bugs.chromium.org/p/webrtc/issues/detail?id=8463">Chromium のソースに無意味な std::move() が見つかる</a>など、既存のコードベースのバグの発見に役立っています。</p>
<h3 id="array-constexpr-p1023r0-p1032r1"><code class="codehilite"><span class="err">&lt;array&gt;</span></code> ヘッダのすべての関数が constexpr に <a href="https://wg21.link/P1023R0">(P1023R0)</a>, <a href="https://wg21.link/P1032R1">(P1032R1)</a><a class="headerlink" href="#array-constexpr-p1023r0-p1032r1" title="Permanent link">&para;</a></h3>
<p>C++17 の <code class="codehilite"><span class="err">&lt;array&gt;</span></code> ヘッダでは、比較演算子、<code class="codehilite"><span class="err">swap()</span></code>, <code class="codehilite"><span class="err">fill()</span></code> 以外のすべての関数が constexpr でした。C++20 ではさらに、array の比較演算の実装に使われている <code class="codehilite"><span class="c">std::equal()</span></code> と <code class="codehilite"><span class="c">std::lexicographical_compare()</span></code> が <a href="https://wg21.link/P0202R3">constexpr になった (P0202R3)</a> ことにともない、array の比較演算子を constexpr とし、また <code class="codehilite"><span class="err">swap()</span></code> と <code class="codehilite"><span class="err">fill()</span></code> についても constexpr にすることを決め、array ヘッダのすべての関数が constexpr で提供されます。</p>
<h3 id="chrono-zero-min-max-noexcept-p0972r0"><code class="codehilite"><span class="err">&lt;chrono&gt;</span></code> ヘッダの <code class="codehilite"><span class="err">zero()</span></code>, <code class="codehilite"><span class="err">min()</span></code>, <code class="codehilite"><span class="err">max()</span></code> 関数が noexcept に <a href="https://wg21.link/P0972R0">(P0972R0)</a><a class="headerlink" href="#chrono-zero-min-max-noexcept-p0972r0" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="c">std::chrono::duration_values</span></code>, <code class="codehilite"><span class="c">std::chrono::duration</span></code>, <code class="codehilite"><span class="c">std::chrono::time_point</span></code> などの <code class="codehilite"><span class="err">zero()</span></code>, <code class="codehilite"><span class="err">min()</span></code>, <code class="codehilite"><span class="err">max()</span></code> 関数に noexcept が付きます。</p>
<h3 id="pointer_traits-constexpr-p1006r1"><code class="codehilite"><span class="err">pointer_traits</span></code> が constexpr に <a href="https://wg21.link/P1006R1">(P1006R1)</a><a class="headerlink" href="#pointer_traits-constexpr-p1006r1" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="c">std::vector</span></code> を constexpr にするのに必要なため、<code class="codehilite"><span class="c">std::pointer_traits::pointer_to()</span></code> 関数が constrexpr になります。</p>
<h3 id="assume_aligned-p1007r3">ポインタのアライメントを最適化ヒントとしてコンパイラに伝える <code class="codehilite"><span class="err">assume_aligned()</span></code> 関数 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1007r3.pdf">(P1007R3)</a><a class="headerlink" href="#assume_aligned-p1007r3" title="Permanent link">&para;</a></h3>
<p>データのアドレスが 16 バイトなどのサイズにアライメントされている場合、コンパイラが SIMD を使った最適なコードを生成できる可能性があります。あるポインタの指すデータがアライメントされていることをコンパイラに伝える方法として、GCC や Clang では <code class="codehilite"><span class="err">__builtin_assume_aligned()</span></code> や <code class="codehilite"><span class="err">__attribute__((assume_aligned(alignment)))</span></code>, ICC では <code class="codehilite"><span class="err">__assume_aligned()</span></code> などの独自拡張がありますが、標準化された方法はありませんでした。C++20 では、これらの差異を吸収する次のような関数テンプレートが提供されます。
<div class="codehilite"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span><span class="o">*</span> <span class="n">assume_aligned</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</code></pre></div>
実際には次のように使います。
<div class="codehilite"><pre><span></span><code><span class="kt">void</span> <span class="nf">Multiply</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">factor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">assume_aligned</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x が 64 バイトアライメントであることを伝える</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// ループが適宜最適化される</span>
    <span class="p">{</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="make-p1020r1">スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 <a href="https://wg21.link/P1020R1">(P1020R1)</a><a class="headerlink" href="#make-p1020r1" title="Permanent link">&para;</a></h3>
<p>実行時性能のために、<code class="codehilite"><span class="err">float</span></code> や <code class="codehilite"><span class="err">unsigned char</span></code> など組み込み型の配列の値をデフォルト初期化させたい（ゼロ初期化しない）ケースがあります。しかし、<code class="codehilite"><span class="err">make_unique</span></code> や <code class="codehilite"><span class="err">make_shared</span></code>, <code class="codehilite"><span class="err">allocate_shared</span></code> でスマートポインタを作成した場合には値初期化が実行されます。C++20 では、値初期化をせずにデフォルト初期化でスマートポインタを作成する関数 <code class="codehilite"><span class="err">make_unique_default_init</span></code>, <code class="codehilite"><span class="err">make_shared_default_init</span></code>, <code class="codehilite"><span class="err">allocate_shared_default_init</span></code> が追加されました。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="c1">// 未初期化の変数を使う実験的なコード</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// デフォルト初期化</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">pv</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 値初期化 (0 初期化) </span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique_default_init</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// デフォルト初期化</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
出力例
<div class="codehilite"><pre><span></span><code><span class="err">2.20325e-38</span>
<span class="err">4.11052e+32</span>
<span class="err">1.3013e-45</span>
<span class="err">2.48626e-38</span>
<span class="err">0</span>
<span class="err">0</span>
<span class="err">0</span>
<span class="err">0</span>
<span class="err">2.30415e-38</span>
<span class="err">2.51341e-38</span>
<span class="err">4.63281e+30</span>
<span class="err">2.32703e+17</span>
</code></pre></div></p>
<h3 id="key_type-p0919r3">非順序連想コンテナのルックアップ操作で、<code class="codehilite"><span class="err">key_type</span></code> と比較可能な型を変換せずに使えるように <a href="http://wg21.link/P0919r3">(P0919R3)</a><a class="headerlink" href="#key_type-p0919r3" title="Permanent link">&para;</a></h3>
<p>C++17 までの <code class="codehilite"><span class="err">unorderd_map</span></code> や <code class="codehilite"><span class="err">unordered_set</span></code> など非順序連想コンテナでは、<code class="codehilite"><span class="err">find()</span></code>, <code class="codehilite"><span class="err">count()</span></code>, <code class="codehilite"><span class="err">equal_range()</span></code> などルックアップを行うメンバ関数は引数に <code class="codehilite"><span class="err">key_type</span></code> をとり、例えば次のようなケースで <code class="codehilite"><span class="c">std::string</span></code> 型の一時オブジェクトが作成されて非効率でした。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトが作成される</span>
<span class="p">}</span>
</code></pre></div>

<p>C++20 では、非順序連想コンテナのテンプレートパラメータ <code class="codehilite"><span class="err">Hash</span></code> が <code class="codehilite"><span class="err">transparent_key_equal</span></code> タグを持つときに、<code class="codehilite"><span class="err">key_type</span></code> 以外の型を引数にとるメンバ関数テンプレートのオーバーロードが使用可能になり、一時オブジェクトの作成を回避できるようになります。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">string_hash</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">transparent_key_equal</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;&gt;</span><span class="p">;</span>  <span class="c1">// KeyEqual to use</span>
    <span class="k">using</span> <span class="n">hash_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// helper local type</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">string_hash</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトは作成されない</span>

    <span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="n">sv</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトは作成されない</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="2-stdmidpoint-p0811r3">2 つの値の中点を計算する <code class="codehilite"><span class="c">std::midpoint()</span></code> 関数 <a href="https://wg21.link/P0811R3">(P0811R3)</a><a class="headerlink" href="#2-stdmidpoint-p0811r3" title="Permanent link">&para;</a></h3>
<p>2 つの値 <code class="codehilite"><span class="err">a</span></code>, <code class="codehilite"><span class="err">b</span></code> の中点を計算する際に、単純な <code class="codehilite"><span class="err">(a + b) / 2</span></code> という式ではオーバーフローを起こす可能性があります。C++20 で追加される <code class="codehilite"><span class="c">std::midpoint()</span></code> 関数では、整数に対して
<div class="codehilite"><pre><span></span><code><span class="k">constexpr</span> <span class="n">Integer</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">Integer</span> <span class="n">a</span><span class="p">,</span> <span class="n">Integer</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">U</span> <span class="o">=</span> <span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span> <span class="o">?</span> <span class="n">a</span><span class="o">-</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">:</span> <span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
のような実装が使われ、オーバーフローを回避できます。<code class="codehilite"><span class="err">(a + b)</span></code> が奇数になるケースの結果は <code class="codehilite"><span class="err">a</span></code> の方向に丸められます。<br />
浮動小数点数に対しては次のような実装が使われます。
<div class="codehilite"><pre><span></span><code><span class="n">Float</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">Float</span> <span class="n">a</span><span class="p">,</span> <span class="n">Float</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">isnormal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isnormal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span> <span class="o">+</span> <span class="mi">1</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// オーバーフロー</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">2</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">,</span> <span class="mi">1</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 1500000000</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 2</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 3</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="2-stdlerp-p0811r3">2 つの値の線形補間を計算する <code class="codehilite"><span class="c">std::lerp()</span></code> 関数 <a href="https://wg21.link/P0811R3">(P0811R3)</a><a class="headerlink" href="#2-stdlerp-p0811r3" title="Permanent link">&para;</a></h3>
<p>2 点 <code class="codehilite"><span class="err">a</span></code>, <code class="codehilite"><span class="err">b</span></code> の間をパラメータ <code class="codehilite"><span class="err">t</span></code> によって線形補間する関数が提供されます。計算結果 <code class="codehilite"><span class="err">r</span></code> は <code class="codehilite"><span class="err">a + t * (b - a)</span></code> によって求められますが、実装により <code class="codehilite"><span class="err">isfinite(a) &amp;&amp; isfinite(b)</span></code> のとき</p>
<ul>
<li><code class="codehilite"><span class="err">lerp(a, b, 0) == a &amp;&amp; lerp(a, b, 1) == b</span></code></li>
<li><code class="codehilite"><span class="err">0 &lt;= t &amp;&amp; t &lt;= 1</span></code> のとき <code class="codehilite"><span class="err">isfinite(r)</span></code></li>
<li><code class="codehilite"><span class="err">isfinite(t) &amp;&amp; a == b</span></code> のとき <code class="codehilite"><span class="err">r == a</span></code></li>
<li><code class="codehilite"><span class="err">isfinite(t) || !isnan(t) &amp;&amp; (b - a) != 0</span></code> のとき <code class="codehilite"><span class="sx">!isnan(r)</span></code></li>
</ul>
<p>また、<code class="codehilite"><span class="err">cmp(lerp(a,b,t2), lerp(a,b,t1)) * cmp(t2,t1) * cmp(b,a) &gt;= 0</span></code> (cmp は -1, 0, 1 を返す三方比較関数とする)<br />
であることが保証されます。
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 3</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 10</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 12</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="version-p0754r2">実装固有の情報をまとめる <code class="codehilite"><span class="err">&lt;version&gt;</span></code> ヘッダを追加 <a href="https://wg21.link/P0754R2">(P0754R2)</a><a class="headerlink" href="#version-p0754r2" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="err">__cpp_lib_byte</span></code>, <code class="codehilite"><span class="err">__cpp_lib_void_t</span></code> のような標準ライブラリの機能テストマクロ、その他ライブラリのバージョンや実装固有の情報をまとめる目的の <code class="codehilite"><span class="err">&lt;version&gt;</span></code> ヘッダが追加されました。
例えば C++20 以前の MSVC の標準ライブラリでは、<code class="codehilite"><span class="err">&lt;yvals_core.h&gt;</span></code> という独自ヘッダに標準ライブラリの機能テストマクロがまとめられていましたが、C++20 以降ではあらゆる実装において、<code class="codehilite"><span class="err">&lt;version&gt;</span></code> ヘッダを見ることで、こうした実装固有の情報にアクセスできるため利便性が高まります。</p>
<h3 id="is_nothrow_convertible-p0758r1">例外を投げない暗黙の変換が可能か調べる <code class="codehilite"><span class="err">is_nothrow_convertible</span></code> <a href="https://wg21.link/P0758R1">(P0758R1)</a><a class="headerlink" href="#is_nothrow_convertible-p0758r1" title="Permanent link">&para;</a></h3>
<p>型 <code class="codehilite"><span class="err">From</span></code> から型 <code class="codehilite"><span class="err">To</span></code> への暗黙の変換が可能であるかを調べる型特性クラス <code class="codehilite"><span class="c">std::is_convertible&lt;class From, class To&gt;</span></code> が C++11 から導入されましたが、その変換が <code class="codehilite"><span class="err">noexcept</span></code> でもあるかを調べられるバージョンは実装されていませんでした。
このことが原因で、<code class="codehilite"><span class="c">std::decay_copy</span></code> の提案 (<a href="http://wg21.link/n3255">N3255</a>) において、適切な <code class="codehilite"><span class="err">noexcept</span></code> 例外仕様を移植性のある方法で定義できない問題 (<a href="http://wg21.link/lwg2040">LWG 2040</a>) が指摘されていました。
<div class="codehilite"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> 
<span class="k">typename</span> <span class="n">decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">decay_copy</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="o">???</span> <span class="cm">/* is_nothrow_convertible&lt;T, T&gt;::value */</span><span class="p">);</span>
</code></pre></div>
C++20 からは、<code class="codehilite"><span class="err">noexcept</span></code> な暗黙の変換が可能であることを調べる新しい型特性クラス <code class="codehilite"><span class="c">std::is_nothrow_convertible&lt;class From, class To&gt;</span></code> が実装されることで問題を解消できます。
既存の標準ライブラリ関数においても、<code class="codehilite"><span class="c">std::basic_string</span></code> のメンバ関数テンプレートに、より適切な <code class="codehilite"><span class="err">noexcept</span></code> 例外仕様を定義するために活用されます。</p>
<div class="codehilite"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">size_type</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">is_nothrow_convertible_v</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">basic_string_view</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span> <span class="n">Traits</span><span class="o">&gt;&gt;</span><span class="p">);</span>
</code></pre></div>

<h3 id="stdto_address-p0653r2">ポインタライクなオブジェクトからアドレスを取得する <code class="codehilite"><span class="c">std::to_address()</span></code> 関数 <a href="https://wg21.link/P0653R2">(P0653R2)</a><a class="headerlink" href="#stdto_address-p0653r2" title="Permanent link">&para;</a></h3>
<p>ポインタライクなオブジェクトを引数にとり、それが表すのと同じアドレスを生ポインタで返す関数 <code class="codehilite"><span class="c">std::to_address(p)</span></code> が追加されます。オブジェクトがポインタ型の場合はその値を返し、それ以外の場合、<code class="codehilite"><span class="c">std::pointer_traits&lt;Ptr&gt;::to_address(p)</span></code> の特殊化が定義されていて使えればその戻り値を、そうでない場合は <code class="codehilite"><span class="c">std::to_address(p.operator-&gt;())</span></code> の戻り値を返します。</p>
<h3 id="complex-constexpr-p0415r1"><code class="codehilite"><span class="err">&lt;complex&gt;</span></code> ヘッダの関数の <code class="codehilite"><span class="err">constexpr</span></code> 対応を強化 <a href="https://wg21.link/P0415R1">(P0415R1)</a><a class="headerlink" href="#complex-constexpr-p0415r1" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="err">&lt;complex&gt;</span></code> ヘッダが提供する関数のうち、複素数の四則演算、ノルムの取得、共役複素数の取得など、<code class="codehilite"><span class="err">constexpr</span></code> 非対応の数学関数 (sqrt など) を使わずに実装できるものが <code class="codehilite"><span class="err">constexpr</span></code> 化されます。</p>
<h3 id="stdis_constant_evaluated-p0595r2">コンパイル時評価の文脈か実行時評価の文脈かを判別できる <code class="codehilite"><span class="c">std::is_constant_evaluated()</span></code> 関数 <a href="https://wg21.link/P0595">(P0595R2)</a><a class="headerlink" href="#stdis_constant_evaluated-p0595r2" title="Permanent link">&para;</a></h3>
<p>C++17 までは、実行するコードを、コンパイル時評価か実行時評価かに応じて使い分ける方法はありませんでした。C++20 では、コンパイル時評価されている文脈では <code class="codehilite"><span class="err">true</span></code> を、それ以外の場合では <code class="codehilite"><span class="err">false</span></code> を返す <code class="codehilite"><span class="c">std::is_constant_evaluated()</span></code> 関数が <code class="codehilite"><span class="err">&lt;type_traits&gt;</span></code> ヘッダに追加されます。例えば標準ライブラリで <code class="codehilite"><span class="err">constexpr</span></code> 対応していないような数学関数を提供する際、コンパイル時評価では <code class="codehilite"><span class="err">constexpr</span></code> 版の実装を、実行時には非 <code class="codehilite"><span class="err">constexpr</span></code> の標準ライブラリの実装を提供するよう選択させることができます。なお、<code class="codehilite"><span class="c">std::is_constant_evaluated()</span></code> を <code class="codehilite"><span class="err">if constexpr</span></code> の <code class="codehilite"><span class="err">( )</span></code> 内や <code class="codehilite"><span class="err">static_assert</span></code> 内で使うと常に <code class="codehilite"><span class="err">true</span></code> に評価されてしまうので注意が必要です。基本的には <code class="codehilite"><span class="err">if (std::is_constant_evaluated())</span></code> と書きます。</p>
<p><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">float</span> <span class="nf">Sin_impl</span><span class="p">(</span><span class="kt">float</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">float</span> <span class="n">xn</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">?</span> <span class="mf">0.0f</span> <span class="o">:</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">xn</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">+</span> <span class="n">Sin_impl</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">xn</span> <span class="o">*</span> <span class="n">x2</span><span class="p">,</span> <span class="n">nf</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="kt">float</span> <span class="nf">Sin</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_constant_evaluated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Sin_impl</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">Pi</span> <span class="o">=</span> <span class="mf">3.14159265f</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span> <span class="c1">// コンパイル時計算    </span>
    <span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>  <span class="c1">// 実行時計算</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="err">0.7071068286895752</span>
<span class="err">0.7071067690849304</span>
</code></pre></div></p>
<h3 id="p0020r6">浮動小数点数型のアトミック操作を拡張 <a href="https://wg21.link/P0020R6">(P0020R6)</a><a class="headerlink" href="#p0020r6" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="c">std::atomic&lt;T&gt;</span></code> の <code class="codehilite"><span class="err">float</span></code>, <code class="codehilite"><span class="err">double</span></code>, <code class="codehilite"><span class="err">long double</span></code> 型の特殊化に、メンバ関数 <code class="codehilite"><span class="err">fetch_add()</span></code>, <code class="codehilite"><span class="err">fetch_sub()</span></code>, <code class="codehilite"><span class="err">operator+=()</span></code>, <code class="codehilite"><span class="err">operator-=()</span></code> が追加されます。</p>
<h3 id="stdmemory_order-enum-class-p0439r0"><code class="codehilite"><span class="c">std::memory_order</span></code> を <code class="codehilite"><span class="err">enum class</span></code> に変更 <a href="https://wg21.link/P0439R0">(P0439R0)</a><a class="headerlink" href="#stdmemory_order-enum-class-p0439r0" title="Permanent link">&para;</a></h3>
<p>C++17 まで <code class="codehilite"><span class="err">enum</span></code> で定義されていた <code class="codehilite"><span class="c">std::memory_order</span></code> を、モダンな C++ 文法と型安全のために、<code class="codehilite"><span class="err">enum class</span></code> で定義する仕様に変更されます。これまでの表記は定数で提供されるようになるため、既存のソースコードは影響を受けません。また、バイナリ互換性のために、<code class="codehilite"><span class="err">enum class</span></code> の基底型の選択は実装に任せられています。</p>
<div class="superfences-tabs">
<input name="__tabs_3" type="radio" id="__tab_3_0" checked="checked" />
<label for="__tab_3_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><code><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="k">enum</span> <span class="n">memory_order</span>
    <span class="p">{</span>
        <span class="n">memory_order_relaxed</span><span class="p">,</span>
        <span class="n">memory_order_consume</span><span class="p">,</span>
        <span class="n">memory_order_acquire</span><span class="p">,</span>
        <span class="n">memory_order_release</span><span class="p">,</span>
        <span class="n">memory_order_acq_rel</span><span class="p">,</span>
        <span class="n">memory_order_seq_cst</span>
    <span class="p">}</span> <span class="n">memory_order</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<input name="__tabs_3" type="radio" id="__tab_3_1" />
<label for="__tab_3_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><code><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">memory_order</span> <span class="cm">/* : unspecified */</span>
    <span class="p">{</span>
        <span class="n">relaxed</span><span class="p">,</span>
        <span class="n">consume</span><span class="p">,</span>
        <span class="n">acquire</span><span class="p">,</span>
        <span class="n">release</span><span class="p">,</span>
        <span class="n">acq_rel</span><span class="p">,</span>
        <span class="n">seq_cst</span>
    <span class="p">};</span>

    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_relaxed</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_consume</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">consume</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_acquire</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">acquire</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_release</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">release</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_acq_rel</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">acq_rel</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_seq_cst</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">seq_cst</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
</div>
<h3 id="hash-p0809r0"><code class="codehilite"><span class="err">Hash</span></code> が同一の挙動をしない非順序連想コンテナどうしの比較が可能に <a href="https://wg21.link/P0809R0">(P0809R0)</a><a class="headerlink" href="#hash-p0809r0" title="Permanent link">&para;</a></h3>
<p>C++17 までは、非順序連想コンテナの <code class="codehilite"><span class="err">operator==</span></code>, <code class="codehilite"><span class="err">operator!=</span></code> について、「両者の <code class="codehilite"><span class="err">Hash</span></code> と <code class="codehilite"><span class="err">Pred</span></code> がそれぞれ同一の挙動をしない場合は未定義動作」と規格に記されていました。しかし、ランダムなソルトを使うハッシュ関数を持つコンテナ同士の比較もユースケースとして想定され、また、対応するための実装も難しくなかったことから、C++20 からはこのうち <code class="codehilite"><span class="err">Hash</span></code> に関する記述が削除されました。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">RandomizedHash</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">rnd</span><span class="p">;</span>

    <span class="n">RandomizedHash</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
        <span class="n">rnd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">rd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">s</span><span class="p">)</span> <span class="o">^</span> <span class="n">rnd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">RandomizedHash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">u1</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Three&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">RandomizedHash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">u2</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Three&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="c1">// それぞれ異なるハッシュ値を返す</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;abcde&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;u1: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">u1</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;u2: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">u2</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="c1">// C++17 までは未定義動作、C++20 から OK</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="p0463r1">実行環境のエンディアンを判別するための列挙定数を追加 <a href="https://wg21.link/P0463R1">(P0463R1)</a><a class="headerlink" href="#p0463r1" title="Permanent link">&para;</a></h3>
<p>これまでの C++ プログラムでは、ターゲットアーキテクチャのバイトオーダを判別する際にトリッキーなコードを書く必要がありました。C++20 からは、リトルエンディアンを表す <code class="codehilite"><span class="c">endian::little</span></code>, ビッグエンディアンを表す <code class="codehilite"><span class="c">endian::big</span></code>, 実行環境のエンディアンを表す <code class="codehilite"><span class="c">endian::native</span></code> の 3 つの <code class="codehilite"><span class="err">endian</span></code> 型の列挙定数（値は実装に依存）が <code class="codehilite"><span class="err">&lt;type_traits&gt;</span></code> に定義され、<code class="codehilite"><span class="c">endian::native</span></code> をそれ以外の値と比較することで、実行環境のバイトオーダを判別できるようになります。現在の C++ コンパイラで、リトルエンディアンでもビッグエンディアンでもないミドルエンディアン（PDP エンディアンなど）をサポートしているものはありませんが、ミドルエンディアンの環境においては、<code class="codehilite"><span class="c">endian::native</span></code> は <code class="codehilite"><span class="c">endian::big</span></code> でも <code class="codehilite"><span class="c">endian::little</span></code> でもない値を持つことになっています。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">little</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Little-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">big</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Big-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Middle-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="cv-stdremove_cvref-trait-p0550r2">型から cv 修飾と参照を除去する <code class="codehilite"><span class="c">std::remove_cvref</span></code> trait <a href="https://wg21.link/P0550R2">(P0550R2)</a><a class="headerlink" href="#cv-stdremove_cvref-trait-p0550r2" title="Permanent link">&para;</a></h3>
<p>型から <code class="codehilite"><span class="err">const</span></code> や <code class="codehilite"><span class="err">volatile</span></code> の修飾および参照を除去したいだけで、配列からポインタ、関数型から関数ポインタへの変換については不要であっても、C++17 では <code class="codehilite"><span class="c">std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</span></code> と書くと長くなるため <code class="codehilite"><span class="c">std::decay</span></code> を使うというケースがよくありました。C++20 からは <code class="codehilite"><span class="c">std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</span></code> と同じ効果を持つ <code class="codehilite"><span class="c">std::remove_cvref</span></code> trait と、そのヘルパー型 <code class="codehilite"><span class="c">std::remove_cvref_t</span></code> が追加され、短く書けるようになります。<code class="codehilite"><span class="c">std::remove_reference_t&lt;std::remove_cv_t&lt;T&gt;&gt;</span></code> のような順番の間違いを防ぐことにもつながります。</p>
<h3 id="stddecay-p0777r1">標準ライブラリでの不必要な <code class="codehilite"><span class="c">std::decay</span></code> の使用を回避 <a href="https://wg21.link/P0777R1">(P0777R1)</a><a class="headerlink" href="#stddecay-p0777r1" title="Permanent link">&para;</a></h3>
<p>C++17 の標準ライブラリの規格では <code class="codehilite"><span class="c">std::decay_t</span></code> がおよそ 40 箇所で使われていましたが、そのうち cv 修飾の除去や参照の除去だけで十分な箇所について、実装の意図をより明確にするため <code class="codehilite"><span class="c">std::remove_reference_t</span></code> や、C++20 から導入される <code class="codehilite"><span class="c">std::remove_cvref_t</span></code> に置き換えられます。具体的には、<code class="codehilite"><span class="c">std::apply</span></code> や、<code class="codehilite"><span class="c">std::optional</span></code>, <code class="codehilite"><span class="c">std::variant</span></code> の一部のメンバ関数などで置き換えが発生します。</p>
<h3 id="numbers-p0631r8">数学定数を提供する <code class="codehilite"><span class="err">&lt;numbers&gt;</span></code> ヘッダ <a href="https://wg21.link/P0631R8">(P0631R8)</a><a class="headerlink" href="#numbers-p0631r8" title="Permanent link">&para;</a></h3>
<p>これまで C++ の標準ライブラリには数学定数が用意されていませんでした（<code class="codehilite"><span class="err">M_PI</span></code> などは拡張）。C++20 からは数学定数をまとめた <code class="codehilite"><span class="err">&lt;numbers&gt;</span></code> ヘッダが追加され、13 種類の数学定数の変数テンプレート宣言と、それらの <code class="codehilite"><span class="err">double</span></code> 型への特殊化の定義が提供されます。<br />
変数テンプレートは、標準ライブラリコンセプト <code class="codehilite"><span class="err">floating_point</span></code> を使って、<code class="codehilite"><span class="c">std::numbers</span></code> 名前空間に次のように宣言されます。
<div class="codehilite"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">floating_point</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mf">3.141592653589793238462643383279502884</span><span class="n">L</span><span class="p">;</span>
</code></pre></div>
合わせて <code class="codehilite"><span class="err">double</span></code> 型への特殊化の定義が次のような実装で提供されます。
<div class="codehilite"><pre><span></span><code><span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
C++20 で追加される数学定数の一覧は次のとおりです。</p>
<table>
<thead>
<tr>
<th>定数名</th>
<th>説明</th>
<th>binary128 に充分な精度を持つ値</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_v</td>
<td>e</td>
<td>2.718281828459045235360287471352662498L</td>
</tr>
<tr>
<td>log2e_v</td>
<td>2 を底とする e の対数</td>
<td>1.442695040888963407359924681001892137L</td>
</tr>
<tr>
<td>log10e_v</td>
<td>10 を底とする e の対数</td>
<td>0.434294481903251827651128918916605082L</td>
</tr>
<tr>
<td>pi_v</td>
<td>円周率 (π)</td>
<td>3.141592653589793238462643383279502884L</td>
</tr>
<tr>
<td>inv_pi_v</td>
<td>1/π</td>
<td>0.318309886183790671537767526745028724L</td>
</tr>
<tr>
<td>inv_sqrtpi_v</td>
<td>1/√π</td>
<td>0.564189583547756286948079451560772586L</td>
</tr>
<tr>
<td>ln2_v</td>
<td>2 の自然対数</td>
<td>0.693147180559945309417232121458176568L</td>
</tr>
<tr>
<td>ln10_v</td>
<td>10 の自然対数</td>
<td>2.302585092994045684017991454684364208L</td>
</tr>
<tr>
<td>sqrt2_v</td>
<td>√2</td>
<td>1.414213562373095048801688724209698078L</td>
</tr>
<tr>
<td>sqrt3_v</td>
<td>√3</td>
<td>1.732050807568877293527446341505872366L</td>
</tr>
<tr>
<td>inv_sqrt3_v</td>
<td>1/√3</td>
<td>0.577350269189625764509148780501957456L</td>
</tr>
<tr>
<td>egamma_v</td>
<td>オイラーの定数</td>
<td>0.577215664901532860606512090082402431L</td>
</tr>
<tr>
<td>phi_v</td>
<td>黄金数 (φ)</td>
<td>1.618033988749894848204586834365638117L</td>
</tr>
</tbody>
</table>
<p>コードで使用する際は、<code class="codehilite"><span class="err">using</span></code> 宣言によって記述を短くできます。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numbers&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi_v</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span>  <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="basic_stringreserve-capacity-p0966r1"><code class="codehilite"><span class="c">basic_string::reserve()</span></code> が capacity を縮小しないように <a href="https://wg21.link/P0966R1">(P0966R1)</a><a class="headerlink" href="#basic_stringreserve-capacity-p0966r1" title="Permanent link">&para;</a></h3>
<p>C++17 では、<code class="codehilite"><span class="c">std::basic_string::reserve(size_type)</span></code> に現在の <code class="codehilite"><span class="err">capacity()</span></code> よりも小さい値が渡された際、shrink-to-fit を実行することが許可されていたため、注意深く使わないとメモリの再配置を頻繁に引き起こし、実行時性能を低下させることがありました。また、デフォルト引数として <code class="codehilite"><span class="err">0</span></code> が定義されており、<code class="codehilite"><span class="err">s.reserve()</span></code> と <code class="codehilite"><span class="err">s.shrink_to_fit()</span></code> で機能が重複するという問題や、shrink-to-fit を実行せずデフォルト引数も無い <code class="codehilite"><span class="c">std::vector::reserve(size_type)</span></code> との一貫性がないという問題がありました。C++20 からの新しい仕様では <code class="codehilite"><span class="c">std::vector</span></code> 側に合わせ、<code class="codehilite"><span class="c">std::basic_string::reserve(size_type)</span></code> に現在の <code class="codehilite"><span class="err">capacity()</span></code> よりも小さい値が渡された際には何もしないことが保証され、デフォルト引数も廃止（互換性のために deprecated 指定の <code class="codehilite"><span class="c">std::basic_string:reserve(void)</span></code> オーバーロードが追加）となり、これらの問題が解決されます。</p>
<h3 id="constains-p0458r2">連想コンテナに <code class="codehilite"><span class="err">constains()</span></code> メンバ関数を追加 <a href="https://wg21.link/P0458R2">(P0458R2)</a><a class="headerlink" href="#constains-p0458r2" title="Permanent link">&para;</a></h3>
<p>ある要素が連想コンテナに含まれているか調べるための C++17 までのイディオムは、直感的でなく初心者にとっても明快ではありませんでした。C++20 からは、要素の存在をチェックする <code class="codehilite"><span class="err">contains(key)</span></code> メンバ関数が <code class="codehilite"><span class="c">std::map</span></code>, <code class="codehilite"><span class="c">std::multimap</span></code>, <code class="codehilite"><span class="c">std::set</span></code>, <code class="codehilite"><span class="c">std::multiset</span></code>, <code class="codehilite"><span class="c">std::unordered_map</span></code>, <code class="codehilite"><span class="c">std::unordered_multimap</span></code>, <code class="codehilite"><span class="c">std::unordered_set</span></code>, <code class="codehilite"><span class="c">std::unordered_multiset</span></code> に追加されます。</p>
<div class="superfences-tabs">
<input name="__tabs_4" type="radio" id="__tab_4_0" checked="checked" />
<label for="__tab_4_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="mi">200</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">201</span><span class="p">,</span> <span class="s">&quot;Created&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">202</span><span class="p">,</span> <span class="s">&quot;Accepted&quot;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">!=</span> <span class="n">table</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;key exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<input name="__tabs_4" type="radio" id="__tab_4_1" />
<label for="__tab_4_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="mi">200</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">201</span><span class="p">,</span> <span class="s">&quot;Created&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">202</span><span class="p">,</span> <span class="s">&quot;Accepted&quot;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">200</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;key exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
</div>
<h3 id="stderase-stderase_if-p1209r0">コンテナから指定した要素を削除する操作に一貫して使える <code class="codehilite"><span class="c">std::erase()</span></code>, <code class="codehilite"><span class="c">std::erase_if()</span></code> 関数 <a href="https://wg21.link/p1209r0">(P1209R0)</a><a class="headerlink" href="#stderase-stderase_if-p1209r0" title="Permanent link">&para;</a></h3>
<p>コンテナから特定の要素を削除するという処理は、コンテナの種類によって最適な書き方が異なります。<code class="codehilite"><span class="c">std::unordered_map</span></code> ではイテレータを使って先頭から要素を削除していき、<code class="codehilite"><span class="c">std::list</span></code> ではメンバ関数の <code class="codehilite"><span class="err">remove()</span></code> や <code class="codehilite"><span class="err">remove_if()</span></code> を使い、<code class="codehilite"><span class="c">std::vector</span></code> では <code class="codehilite"><span class="c">std::remove_if()</span></code> と <code class="codehilite"><span class="err">erase()</span></code> メンバ関数を組み合わせます。このようにコンテナの特性に応じてコードを書き分けるのは大変だったため、C++20 ではすべてのコンテナ向けに適切な実装を提供する、一貫して使える非メンバ関数 <code class="codehilite"><span class="c">std::erase()</span></code>, <code class="codehilite"><span class="c">std::erase_if()</span></code> が追加されます。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">92</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">li</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">92</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;aa&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;bb&quot;</span><span class="p">,</span> <span class="mi">14</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;dd&quot;</span><span class="p">,</span> <span class="mi">5</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;ee&quot;</span><span class="p">,</span> <span class="mi">92</span> <span class="p">}</span> <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span> <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="stdbit_cast-p0476r2">バイト列の再解釈キャストを補助する <code class="codehilite"><span class="c">std::bit_cast()</span></code> 関数 <a href="https://wg21.link/P0476R2">(P0476R2)</a><a class="headerlink" href="#stdbit_cast-p0476r2" title="Permanent link">&para;</a></h3>
<p>ある型のオブジェクトが格納されているバイト列に対して、別の型のオブジェクトと解釈してアクセスすること (type punning) は C++ では禁止されています (strict aliasing rule). <code class="codehilite"><span class="err">float</span></code> 型の値のバイト列を <code class="codehilite"><span class="c">std::uint32_t</span></code> 型として扱うときの間違った方法として、次のサンプルのように <code class="codehilite"><span class="err">reinterpret_cast</span></code> や <code class="codehilite"><span class="err">union</span></code> を用いる例があります。これは直感的に見え、実際ほとんどのコンパイラで期待通り動作しますが、規格上は未定義動作となる不正なコードです。正しくは <code class="codehilite"><span class="c">std::memcpy()</span></code> を使います。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">union</span> <span class="n">FloatUint32</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">;</span>

    <span class="c1">// 未定義動作</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u1</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>

    <span class="c1">// 未定義動作</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">FloatUint32</span><span class="p">{</span> <span class="n">f</span> <span class="p">}.</span><span class="n">u</span><span class="p">;</span>

    <span class="c1">// OK</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u3</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u3</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>しかし、<code class="codehilite"><span class="c">std::memcpy()</span></code> では型変換を <code class="codehilite"><span class="err">constexpr</span></code> にできず、また、デフォルトコンストラクト可能でない型に対応するには <code class="codehilite"><span class="c">std::aligned_storage</span></code> と組み合わせる必要があるなど、適切な実装は面倒でした。C++20 では、この実装をコンパイラサポートによる <code class="codehilite"><span class="err">constexpr</span></code> 対応も含めて実現する <code class="codehilite"><span class="c">std::bit_cast()</span></code> 関数が提供されます。</p>
<div class="codehilite"><pre><span></span><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">To</span><span class="p">,</span> <span class="k">typename</span> <span class="n">From</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">To</span> <span class="n">bit_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">From</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</code></pre></div>

<p>変換先の型 <code class="codehilite"><span class="err">To</span></code> と変換元の型 <code class="codehilite"><span class="err">From</span></code> について、<code class="codehilite"><span class="err">sizeof(To) != sizeof(From)</span></code> の場合や、<code class="codehilite"><span class="c">std::is_trivially_copyable_v&lt;To&gt; == false</span></code> または <code class="codehilite"><span class="c">std::is_trivially_copyable_v&lt;From&gt; == false</span></code> の場合にはコンパイルエラーになるため、間違いを減らす効果もあります。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bit&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">u</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bit_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="numeric-p0616r0"><code class="codehilite"><span class="err">&lt;numeric&gt;</span></code> の関数の非効率な実装を改善 <a href="https://wg21.link/P0616R0">(P0616R0)</a><a class="headerlink" href="#numeric-p0616r0" title="Permanent link">&para;</a></h3>
<p>C++17 では、<code class="codehilite"><span class="c">std::accumulate()</span></code> は <code class="codehilite"><span class="err">acc = binary_op(acc, *i)</span></code> として実装されると規格に定められていいたため、次のようなケースで <code class="codehilite"><span class="c">std::accumulate()</span></code> の最中に <code class="codehilite"><span class="c">std::string</span></code> のアロケーションが大量に発生して非効率でした。</p>
<p><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">&quot;abc&quot;</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;start&quot;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">r</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
C++17 の <code class="codehilite"><span class="c">std::accumulate()</span></code> の中で行われること:
<div class="codehilite"><pre><span></span><code><span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="c1">// operator+(const std::string&amp;, const std::string&amp;)</span>
<span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="p">...</span> <span class="c1">// くり返し</span>
</code></pre></div></p>
<p>C++20 では、<code class="codehilite"><span class="c">std::move()</span></code> を使う <code class="codehilite"><span class="err">acc = binary_op(std::move(acc), *i)</span></code> という実装に変更され、右辺値の演算に対する効率的な実装を提供する型 (<code class="codehilite"><span class="c">std::string</span></code> など) が、恩恵を受けられるようになります。</p>
<p>C++20 の <code class="codehilite"><span class="c">std::accumulate()</span></code> の中で行われること:
<div class="codehilite"><pre><span></span><code><span class="n">acc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="c1">// operator+(std::string&amp;&amp;, const std::string&amp;)</span>
<span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div>
<code class="codehilite"><span class="err">operator+(std::string&amp;&amp; lhs, const std::string&amp; rhs)</span></code> は基本的に <code class="codehilite"><span class="err">lhs.append(rhs)</span></code> です。次のようにあらかじめ十分なキャパシティを確保したバッファを <code class="codehilite"><span class="c">std::accumulate()</span></code> 内で使えるようにもなります。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">&quot;abc&quot;</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;start&quot;</span><span class="p">;</span>

    <span class="n">s</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">words</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">size</span><span class="p">()));</span> <span class="c1">// C++17 では無意味</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">r</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code class="codehilite"><span class="c">std::move()</span></code> を使うこの仕様変更は、同じ <code class="codehilite"><span class="err">&lt;numeric&gt;</span></code> ヘッダの <code class="codehilite"><span class="c">std::inner_product()</span></code> や <code class="codehilite"><span class="c">std::partial_sum()</span></code>, <code class="codehilite"><span class="c">std::adjacent_difference()</span></code> にも適用されます。</p>
<h3 id="2-p0556r3-p1355r2-p1956r1">2 の累乗数に関するユーティリティ関数を追加 <a href="https://wg21.link/P0556R3">(P0556R3)</a>, <a href="https://wg21.link/P1355R2">(P1355R2)</a>, <a href="https://wg21.link/P1956R1">(P1956R1)</a><a class="headerlink" href="#2-p0556r3-p1355r2-p1956r1" title="Permanent link">&para;</a></h3>
<p>ある整数が 2 の累乗数であるかを調べたり、ある整数に近い 2 の累乗数を探したりする処理は、プログラミングでよく登場しますが、C++17 の標準ライブラリには実装されていませんでした。C++20 では次のような関数が追加されます。</p>
<div class="codehilite"><pre><span></span><code><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">has_single_bit</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="n">bit_ceil</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="n">bit_floor</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="n">T</span> <span class="n">bit_width</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>引数 <code class="codehilite"><span class="err">x</span></code> のビット列に含まれる 1 が 1 個だけであるかを判定する <code class="codehilite"><span class="c">std::has_single_bit(x)</span></code><ul>
<li>「<code class="codehilite"><span class="err">x</span></code> が 2 の累乗数 (1, 2, 4, 8, ...) であるか」と同じ意味</li>
</ul>
</li>
<li><code class="codehilite"><span class="err">x</span></code> 以上で最小の 2 の累乗数を返す <code class="codehilite"><span class="c">std::bit_ceil(x)</span></code></li>
<li><code class="codehilite"><span class="err">x</span></code> 以下で最大の 2 の累乗数 (ただし <code class="codehilite"><span class="err">x</span></code> が 0 の場合は 0) を返す <code class="codehilite"><span class="c">std::bit_floor(x)</span></code></li>
<li><code class="codehilite"><span class="err">(1 + log2(x))</span></code> の整数部 (ただし <code class="codehilite"><span class="err">x</span></code> が 0 の場合は 0) を返す <code class="codehilite"><span class="c">std::bit_width(x)</span></code><ul>
<li>「<code class="codehilite"><span class="err">x</span></code> を表現するために何ビット必要か」と同じ意味</li>
</ul>
</li>
</ul>
<p>いずれの関数も、型 <code class="codehilite"><span class="err">T</span></code> が符号なし整数型 (<code class="codehilite"><span class="err">unsigned char</span></code>, <code class="codehilite"><span class="err">unsigned short</span></code>, <code class="codehilite"><span class="err">unsigned int</span></code>, <code class="codehilite"><span class="err">unsigned long</span></code>, <code class="codehilite"><span class="err">unsigned long long</span></code>) の場合のみオーバーロード解決に参加します。なお、<code class="codehilite"><span class="c">std::bit_ceil(x)</span></code> について、結果が型 <code class="codehilite"><span class="err">T</span></code> で表現できない場合の動作は未定義です。</p>
<p><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bit&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">has_single_bit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">bit_ceil</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">bit_floor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">bit_width</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="mi">0</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">1</span><span class="o">:</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="mi">2</span><span class="o">:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span>
<span class="mi">3</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">4</span> <span class="mi">2</span> <span class="mi">2</span>
<span class="mi">4</span><span class="o">:</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">4</span> <span class="mi">3</span>
<span class="mi">5</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">8</span> <span class="mi">4</span> <span class="mi">3</span>
<span class="mi">6</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">8</span> <span class="mi">4</span> <span class="mi">3</span>
<span class="mi">7</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">8</span> <span class="mi">4</span> <span class="mi">3</span>
<span class="mi">8</span><span class="o">:</span> <span class="mi">1</span> <span class="mi">8</span> <span class="mi">8</span> <span class="mi">4</span>
<span class="mi">9</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">8</span> <span class="mi">4</span>
<span class="mi">10</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">8</span> <span class="mi">4</span>
<span class="mi">11</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">8</span> <span class="mi">4</span>
<span class="mi">12</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">8</span> <span class="mi">4</span>
<span class="mi">13</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">8</span> <span class="mi">4</span>
<span class="mi">14</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">8</span> <span class="mi">4</span>
<span class="mi">15</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">8</span> <span class="mi">4</span>
<span class="mi">16</span><span class="o">:</span> <span class="mi">1</span> <span class="mi">16</span> <span class="mi">16</span> <span class="mi">5</span>
</code></pre></div></p>
<h3 id="stdlist-stdforward_list-p0646r1"><code class="codehilite"><span class="c">std::list</span></code> と <code class="codehilite"><span class="c">std::forward_list</span></code> の要素削除メンバ関数が、削除した要素数を返すように <a href="https://wg21.link/P0646R1">(P0646R1)</a><a class="headerlink" href="#stdlist-stdforward_list-p0646r1" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="c">std::list</span></code> のメンバ関数 <code class="codehilite"><span class="err">remove()</span></code> で要素を削除した際、実際に削除された要素数を知るには、前後で <code class="codehilite"><span class="err">size()</span></code> の比較を行わなければなりませんでした。しかし、<code class="codehilite"><span class="c">std::forward_list</span></code> の場合は <code class="codehilite"><span class="err">size()</span></code> メンバ関数を持たないため、O(n) の操作である <code class="codehilite"><span class="c">std::distance()</span></code> を使う必要がありました。C++20 では、<code class="codehilite"><span class="c">std::list</span></code> および <code class="codehilite"><span class="c">std::forward_list</span></code> の <code class="codehilite"><span class="err">remove()</span></code>, <code class="codehilite"><span class="err">remove_if()</span></code>, <code class="codehilite"><span class="err">unique()</span></code> メンバ関数が、削除された要素数を戻り値として返すようになります。なお、呼び出し側で戻り値を使わない場合、主要コンパイラは最適化で処理を省略するため、この仕様変更が実行時性能に与える影響は無いとされています。</p>
<h3 id="stdis_bounded_array-stdis_unbounded_array-p1357r1">要素数が決まっている配列型かどうかを調べる型特性 <code class="codehilite"><span class="c">std::is_bounded_array</span></code>, <code class="codehilite"><span class="c">std::is_unbounded_array</span></code> <a href="https://wg21.link/P1357R1">(P1357R1)</a><a class="headerlink" href="#stdis_bounded_array-stdis_unbounded_array-p1357r1" title="Permanent link">&para;</a></h3>
<p>C++17 の標準ライブラリが提供する型特性には、配列の要素数が決まっている (bounded) かどうかを判定するものはありませんでした。C++20 では利便性のために、型 <code class="codehilite"><span class="err">T</span></code> が要素数既知の配列型であるかを調べる型特性 <code class="codehilite"><span class="c">std::is_bounded_array&lt;T&gt;</span></code> と、型 <code class="codehilite"><span class="err">T</span></code> が要素数未知の配列型であるかを調べる型特性 <code class="codehilite"><span class="c">std::is_unbounded_array&lt;T&gt;</span></code> が追加されました。</p>
<p><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_bounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// false</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_bounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// false</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_bounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// true</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unbounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// false</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unbounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// true</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unbounded_array_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="err">false</span>
<span class="err">false</span>
<span class="err">true</span>
<span class="err">false</span>
<span class="err">true</span>
<span class="err">false</span>
</code></pre></div></p>
<p>C++ 標準ライブラリの機能では、例えば <code class="codehilite"><span class="c">std::make_unique()</span></code> が要素数既知の配列型を禁止しています。こうしたオーバーロードを扱うときに、この型特性が便利です。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// コンパイルエラー</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="stdfunction-noexcept-p0771r1"><code class="codehilite"><span class="c">std::function</span></code> のムーブコンストラクタが <code class="codehilite"><span class="err">noexcept</span></code> に <a href="https://wg21.link/P0771R1">(P0771R1)</a><a class="headerlink" href="#stdfunction-noexcept-p0771r1" title="Permanent link">&para;</a></h3>
<p>実行時性能を向上させるため、C++20 では <code class="codehilite"><span class="c">std::function</span></code> のムーブコンストラクタが <code class="codehilite"><span class="err">noexcept</span></code> になります。なお、libstdc++ と libc++ では提案時点ですでに実装済みでした。</p>
<h3 id="utility-algorithm-constexpr-p0202r3-p0879r0"><code class="codehilite"><span class="err">&lt;utility&gt;</span></code>, <code class="codehilite"><span class="err">&lt;algorithm&gt;</span></code> の多くの関数が <code class="codehilite"><span class="err">constexpr</span></code> に <a href="https://wg21.link/P0202R3">(P0202R3)</a>, <a href="https://wg21.link/P0879R0">(P0879R0)</a><a class="headerlink" href="#utility-algorithm-constexpr-p0202r3-p0879r0" title="Permanent link">&para;</a></h3>
<p>C++20 では <code class="codehilite"><span class="err">&lt;utility&gt;</span></code> ヘッダの <code class="codehilite"><span class="c">std::swap()</span></code>, <code class="codehilite"><span class="c">std::exchange()</span></code> および、<code class="codehilite"><span class="err">&lt;algorithm&gt;</span></code> ヘッダで条件を満たす全関数が <code class="codehilite"><span class="err">constexpr</span></code> に対応します。<code class="codehilite"><span class="c">std::all_of()</span></code> や <code class="codehilite"><span class="c">std::sort()</span></code>, <code class="codehilite"><span class="c">std::reverse()</span></code> など、よく使われるアルゴリズム関数が <code class="codehilite"><span class="err">constexpr</span></code> になります。</p>
<p><code class="codehilite"><span class="err">&lt;algorithm&gt;</span></code> ヘッダで <code class="codehilite"><span class="err">constexpr</span></code> にならないのは以下の関数のみです。</p>
<ul>
<li><code class="codehilite"><span class="c">std::stable_partition()</span></code>, <code class="codehilite"><span class="c">std::inplace_merge()</span></code>, <code class="codehilite"><span class="c">std::stable_sort()</span></code><ul>
<li>メモリのアロケーション等が必要なため</li>
</ul>
</li>
<li><code class="codehilite"><span class="c">std::shuffle()</span></code>, <code class="codehilite"><span class="c">std::sample()</span></code><ul>
<li><code class="codehilite"><span class="err">constexpr</span></code> 関数を持たない <code class="codehilite"><span class="c">std::uniform_int_distribution</span></code> を使用するため</li>
</ul>
</li>
<li><code class="codehilite"><span class="err">ExecutionPolicy</span></code> を引数に取る関数</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">SumOfTop3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// C++20 では constexpr</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">SumOfTop3</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">});</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">7</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 7</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="err">7</span>
</code></pre></div>

<h3 id="delete-p0722r3">デストラクタを自動で呼ばない <code class="codehilite"><span class="err">delete</span></code> 演算子オーバーロード <a href="https://wg21.link/P0722R3">(P0722R3)</a><a class="headerlink" href="#delete-p0722r3" title="Permanent link">&para;</a></h3>
<p>C++17 では、ユーザ定義の <code class="codehilite"><span class="err">delete</span></code> の中でメンバ変数にアクセスしたくても、すでにクラスのデストラクタが呼ばれているため未定義の動作になります。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Object</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_str</span> <span class="o">=</span> <span class="s">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>    
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;m_str: &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_str</span> <span class="c1">// 未定義の動作</span>
            <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Object</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>C++20 では、<code class="codehilite"><span class="err">delete</span></code> の第二引数を <code class="codehilite"><span class="c">std::destroying_delete_t</span></code> 型にすることで、デストラクタの呼び出しが自動で実行されない挙動に設定できます（この新しい挙動を「destroying operator delete」と呼びます）。<code class="codehilite"><span class="err">void T::operator delete(T* ptr, std::destroying_delete_t)</span></code> のように、第一引数にはクラスへのポインタが渡され、明示的にデストラクタ <code class="codehilite"><span class="err">ptr-&gt;~T()</span></code> を呼ぶ必要があります。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Object</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_str</span> <span class="o">=</span> <span class="s">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="n">Object</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">destroying_delete_t</span><span class="p">)</span>
    <span class="p">{</span>    
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;m_str: &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_str</span>
            <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>      
        <span class="n">p</span><span class="o">-&gt;~</span><span class="n">Object</span><span class="p">();</span>
        <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Object</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="p0553r4">ビット循環シフト・ビットカウント関数 <a href="https://wg21.link/P0553R4">(P0553R4)</a><a class="headerlink" href="#p0553r4" title="Permanent link">&para;</a></h3>
<p>ビット列の左端と右端が循環するようにシフトするビットローテーションや、1 になっているビットを数える popcount などのビット操作命令は、多くの CPU アーキテクチャに搭載されていますが、それに対応する関数は C++17 標準ライブラリには存在せず、<code class="codehilite"><span class="err">__builtin_popcount</span></code> (GCC, Clang) や <code class="codehilite"><span class="err">__popcnt</span></code> (MSVC) のような、処理系が提供する非標準の組み込み関数を使う必要がありました。C++20 では、7 種類のビット操作が標準ライブラリ関数として提供されます。</p>
<div class="codehilite"><pre><span></span><code><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">rotl</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">rotr</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">countl_zero</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">countl_one</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">countr_zero</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">countr_one</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">popcount</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>引数 <code class="codehilite"><span class="err">x</span></code> を <code class="codehilite"><span class="err">s</span></code> だけ左にビットローテーションさせる <code class="codehilite"><span class="c">std::rotl(x, s)</span></code><ul>
<li><code class="codehilite"><span class="err">s</span></code> が負数の場合 <code class="codehilite"><span class="c">std::rotr(x, -s)</span></code> と同等</li>
</ul>
</li>
<li>引数 <code class="codehilite"><span class="err">x</span></code> を <code class="codehilite"><span class="err">s</span></code> だけ右にビットローテーションさせる <code class="codehilite"><span class="c">std::rotr(x, s)</span></code><ul>
<li><code class="codehilite"><span class="err">s</span></code> が負数の場合 <code class="codehilite"><span class="c">std::rotl(x, -s)</span></code> と同等</li>
</ul>
</li>
<li><code class="codehilite"><span class="err">x</span></code> の最上位ビットから数えて 0 が連続する個数を返す <code class="codehilite"><span class="c">std::countl_zero(x)</span></code></li>
<li><code class="codehilite"><span class="err">x</span></code> の最上位ビットから数えて 1 が連続する個数を返す <code class="codehilite"><span class="c">std::countl_one(x)</span></code></li>
<li><code class="codehilite"><span class="err">x</span></code> の最下位ビットから数えて 0 が連続する個数を返す <code class="codehilite"><span class="c">std::countr_zero(x)</span></code></li>
<li><code class="codehilite"><span class="err">x</span></code> の最下位ビットから数えて 1 が連続する個数を返す <code class="codehilite"><span class="c">std::countr_one(x)</span></code></li>
<li><code class="codehilite"><span class="err">x</span></code> の 2 進表現に含まれる 1 の個数を返す <code class="codehilite"><span class="c">std::popcount(x)</span></code></li>
</ul>
<p>いずれの関数も、型 <code class="codehilite"><span class="err">T</span></code> が符号なし整数型 (<code class="codehilite"><span class="err">unsigned char</span></code>, <code class="codehilite"><span class="err">unsigned short</span></code>, <code class="codehilite"><span class="err">unsigned int</span></code>, <code class="codehilite"><span class="err">unsigned long</span></code>, <code class="codehilite"><span class="err">unsigned long long</span></code>) の場合のみオーバーロード解決に参加します。</p>
<p><div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bit&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">ShowBinary</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">15</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b0001</span><span class="err">&#39;</span><span class="mo">0110</span><span class="err">&#39;</span><span class="mi">1110</span><span class="err">&#39;</span><span class="mi">1111</span><span class="p">;</span>

    <span class="n">ShowBinary</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ShowBinary</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">rotl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ShowBinary</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">rotr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">countl_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>   <span class="c1">// 3</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">countl_one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// 0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">countr_zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>   <span class="c1">// 0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">countr_one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="mi">0001011011101111</span>

<span class="mi">1111000101101110</span>
<span class="mi">1110001011011101</span>
<span class="mi">1100010110111011</span>
<span class="mi">1000101101110111</span>
<span class="mi">0001011011101111</span>
<span class="mi">0010110111011110</span>
<span class="mi">0101101110111100</span>
<span class="mi">1011011101111000</span>
<span class="mi">0110111011110001</span>

<span class="mi">0110111011110001</span>
<span class="mi">1011011101111000</span>
<span class="mi">0101101110111100</span>
<span class="mi">0010110111011110</span>
<span class="mi">0001011011101111</span>
<span class="mi">1000101101110111</span>
<span class="mi">1100010110111011</span>
<span class="mi">1110001011011101</span>
<span class="mi">1111000101101110</span>

<span class="mi">3</span>
<span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">4</span>
</code></pre></div></p>
<h3 id="stdarray-stdto_array-p0325r4">組み込み配列から <code class="codehilite"><span class="c">std::array</span></code> を作成する <code class="codehilite"><span class="c">std::to_array()</span></code> <a href="https://wg21.link/P0325R4">(P0325R4)</a><a class="headerlink" href="#stdarray-stdto_array-p0325r4" title="Permanent link">&para;</a></h3>
<p>C++17 で導入された型推論ガイドによって、<code class="codehilite"><span class="c">std::array</span></code> で次のようなコードが書けるようになりました。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span> <span class="c1">// std::array&lt;int, 3&gt;</span>
<span class="p">}</span>
</code></pre></div>

<p>しかし、<code class="codehilite"><span class="err">&quot;hello&quot;</span></code> や <code class="codehilite"><span class="err">int[4]</span></code> のような組み込み配列から <code class="codehilite"><span class="c">std::array&lt;char, 6&gt;</span></code> や <code class="codehilite"><span class="c">std::array&lt;int, 4&gt;</span></code> を作成する方法はありませんでした。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">{</span> <span class="s">&quot;hello&quot;</span> <span class="p">};</span> <span class="c1">// std::array&lt;const char*, 1&gt;</span>

    <span class="kt">int</span> <span class="n">xs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span> <span class="p">};</span>
    <span class="k">auto</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">{</span> <span class="n">xs</span> <span class="p">};</span> <span class="c1">// std::array&lt;int*, 1&gt;</span>
<span class="p">}</span>
</code></pre></div>

<p>C++20 では、組み込み配列の左辺値または右辺値を引数にとり、値をコピー（ムーブ）して新しい <code class="codehilite"><span class="c">std::array</span></code> を作成する補助関数 <code class="codehilite"><span class="c">std::to_array()</span></code> が追加され、組み込み配列からの <code class="codehilite"><span class="c">std::array</span></code> の作成が簡単になりました。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_array</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span> <span class="c1">// std::array&lt;char, 6&gt;</span>

    <span class="kt">int</span> <span class="n">xs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span> <span class="p">};</span>
    <span class="k">auto</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_array</span><span class="p">(</span><span class="n">xs</span><span class="p">);</span> <span class="c1">// std::array&lt;int, 4&gt;</span>

    <span class="k">auto</span> <span class="n">a3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_array</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">});</span> <span class="c1">// std::array&lt;long, 2&gt;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="stdfilesystemcreate_directory-p1164r1"><code class="codehilite"><span class="c">std::filesystem::create_directory()</span></code> の挙動を直感的に <a href="https://wg21.link/P1164R1">(P1164R1)</a><a class="headerlink" href="#stdfilesystemcreate_directory-p1164r1" title="Permanent link">&para;</a></h3>
<p>C++17 で導入された <code class="codehilite"><span class="c">std::filesystem::create_directory()</span></code> および <code class="codehilite"><span class="c">std::filesystem::create_directories()</span></code> の当初の仕様では、</p>
<ul>
<li>新しく作成するディレクトリのパスと同名のファイルが存在するときにはエラーにならない</li>
<li>新しく作成するディレクトリのパスが <code class="codehilite"><span class="err">&quot;a/b/c&quot;</span></code> であるとき、すでに <code class="codehilite"><span class="err">&quot;a/b&quot;</span></code> という名前のファイルが存在する場合はエラーとなる一方で、<code class="codehilite"><span class="err">&quot;a/b/c&quot;</span></code> というファイルが存在する場合にはエラーにならない</li>
</ul>
<p>という、対処しにくく一貫しない挙動がありました。C++20 では同名の（ディレクトリでない）ファイルが存在する場合は常にエラーになるよう仕様が修正されます。この変更は C++17 規格にさかのぼって適用され、対応した C++17 環境でも利用できます。</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../.." title="Home" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  前
                </span>
                Home
              </span>
            </div>
          </a>
        
        
          <a href="../cppx/" title="C++23 以降に向けた提案" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  次
                </span>
                C++23 以降に向けた提案
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            To the extent possible under law, Ryo Suzuki has waived all copyright and related or neighboring rights to C++ の歩き方 | CppMap. Third party copyrights are property of their respective owners.
          </div>
        
        powered by
        <a href="https://www.mkdocs.org" target="_blank" rel="noopener">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://twitter.com/Reputeless" target="_blank" rel="noopener" title="twitter" class="md-footer-social__link fa fa-twitter"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.c33a9706.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
          
            
              
                <script src="../../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../../assets/javascripts/lunr/lunr.ja.js"></script>
              
            
          
          
            <script src="../../assets/javascripts/lunr/lunr.multi.js"></script>
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>