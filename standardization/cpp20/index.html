



<!doctype html>
<html lang="ja" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="C++20 の新しい言語機能と標準ライブラリ機能の解説">
      
      
        <link rel="canonical" href="https://cppmap.github.io/standardization/cpp20/">
      
      
        <meta name="author" content="Ryo Suzuki">
      
      
        <meta name="lang:clipboard.copy" content="クリップボードへコピー">
      
        <meta name="lang:clipboard.copied" content="コピーしました">
      
        <meta name="lang:search.language" content="en, ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="何も見つかりませんでした">
      
        <meta name="lang:search.result.one" content="1件見つかりました">
      
        <meta name="lang:search.result.other" content="#件見つかりました">
      
        <meta name="lang:search.tokenizer" content="[\s　、。，．がのをにへとでやかもる「」『』]+">
      
      <link rel="shortcut icon" href="../../assets/images/logo.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.2.0">
    
    
      
        <title>C++20 の新機能 - C++ の歩き方 | CppMap</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.750b69bd.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="../../cppmap_styles.css">
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#c20" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://cppmap.github.io/" title="C++ の歩き方 | CppMap" class="md-header-nav__button md-logo">
          
            <i class="md-icon">donut_small</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              C++ の歩き方 | CppMap
            </span>
            <span class="md-header-nav__topic">
              C++20 の新機能
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="検索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            検索キーワードを入力してください
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/cppmap/cppmap.docs" title="リポジトリへ" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    cppmap/cppmap.docs
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." title="Home" class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="./" title="C++ 規格" class="md-tabs__link md-tabs__link--active">
          C++ 規格
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../articles/comment-tricks/" title="記事" class="md-tabs__link">
          記事
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../learn/books/" title="学習" class="md-tabs__link">
          学習
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../libraries/boost/" title="ライブラリ" class="md-tabs__link">
          ライブラリ
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../tools/compilers/" title="ツール" class="md-tabs__link">
          ツール
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../contribution/contributors/" title="貢献" class="md-tabs__link">
          貢献
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://cppmap.github.io/" title="C++ の歩き方 | CppMap" class="md-nav__button md-logo">
      
        <i class="md-icon">donut_small</i>
      
    </a>
    C++ の歩き方 | CppMap
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/cppmap/cppmap.docs" title="リポジトリへ" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    cppmap/cppmap.docs
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      C++ 規格
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        C++ 規格
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        C++20 の新機能
      </label>
    
    <a href="./" title="C++20 の新機能" class="md-nav__link md-nav__link--active">
      C++20 の新機能
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目次</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" title="言語機能" class="md-nav__link">
    言語機能
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0683r1" title="ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)" class="md-nav__link">
    ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0704r1" title="メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)" class="md-nav__link">
    メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p1236r1" title="符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)" class="md-nav__link">
    符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8-bit-2" title="（参考）符号付き 8-bit 整数の 2 進表現" class="md-nav__link">
    （参考）符号付き 8-bit 整数の 2 進表現
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-no_unique_address-p0840r2" title="メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)" class="md-nav__link">
    メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename-p0634r3" title="型名であることが明らかな文脈で typename を省略可能に (P0634R3)" class="md-nav__link">
    型名であることが明らかな文脈で typename を省略可能に (P0634R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1064r0" title="定数式での仮想関数呼び出しが可能に (P1064R0)" class="md-nav__link">
    定数式での仮想関数呼び出しが可能に (P1064R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_id-dynamic_cast-constexpr-p1327r1" title="type_id と dynamic_cast が constexpr に (P1327R1)" class="md-nav__link">
    type_id と dynamic_cast が constexpr に (P1327R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1330r0" title="定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)" class="md-nav__link">
    定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try-catch-p1002r1" title="定数式の文脈では try-catch を無視するように (P1002R1)" class="md-nav__link">
    定数式の文脈では try-catch を無視するように (P1002R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deprecated-p1161r3" title="添字式にかかるコンマ演算子の使用を deprecated に (P1161R3)" class="md-nav__link">
    添字式にかかるコンマ演算子の使用を deprecated に (P1161R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-p1099r5" title="スコープ付き列挙型に対する using 宣言ができるように (P1099R5)" class="md-nav__link">
    スコープ付き列挙型に対する using 宣言ができるように (P1099R5)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1771r1" title="コンストラクタに [[nodiscard]] が使えるように (P1771R1)" class="md-nav__link">
    コンストラクタに [[nodiscard]] が使えるように (P1771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inline-namespace-p1094r2" title="ネストした名前空間定義で inline namespace を使えるように (P1094R2)" class="md-nav__link">
    ネストした名前空間定義で inline namespace を使えるように (P1094R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#private-p0969r0" title="本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった問題を修正 (P0969R0)" class="md-nav__link">
    本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった問題を修正 (P0969R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1008r1" title="ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 (P1008R1)" class="md-nav__link">
    ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 (P1008R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#throw-p0619r4" title="throw() による動的例外指定を削除 (P0619R4)" class="md-nav__link">
    throw() による動的例外指定を削除 (P0619R4)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="標準ライブラリ" class="md-nav__link">
    標準ライブラリ
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0457r2" title="文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)" class="md-nav__link">
    文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operatorbasic_istream-chart-chartn-p0487r1" title="operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)" class="md-nav__link">
    operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p0600r1" title="戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)" class="md-nav__link">
    戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-constexpr-p1023r0-p1032r1" title="&lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)" class="md-nav__link">
    &lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chrono-zero-min-max-noexcept-p0972r0" title="&lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)" class="md-nav__link">
    &lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointer_traits-constexpr-p1006r1" title="pointer_traits が constexpr に (P1006R1)" class="md-nav__link">
    pointer_traits が constexpr に (P1006R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assume_aligned-p1007r3" title="ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)" class="md-nav__link">
    ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make-p1020r1" title="スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)" class="md-nav__link">
    スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_type-p0919r3" title="非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)" class="md-nav__link">
    非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdmidpoint-p0811r3" title="2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)" class="md-nav__link">
    2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdlerp-p0811r3" title="2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)" class="md-nav__link">
    2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-p0754r2" title="実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)" class="md-nav__link">
    実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_nothrow_convertible-p0758r1" title="例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)" class="md-nav__link">
    例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdto_address-p0653r2" title="ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)" class="md-nav__link">
    ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-constexpr-p0415r1" title="&lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)" class="md-nav__link">
    &lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_constant_evaluated-p0595r2" title="コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)" class="md-nav__link">
    コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0020r6" title="浮動小数点数型のアトミック操作を拡張 (P0020R6)" class="md-nav__link">
    浮動小数点数型のアトミック操作を拡張 (P0020R6)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmemory_order-enum-class-p0439r0" title="std::memory_order を enum class に変更 (P0439R0)" class="md-nav__link">
    std::memory_order を enum class に変更 (P0439R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-p0809r0" title="Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)" class="md-nav__link">
    Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0463r1" title="実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)" class="md-nav__link">
    実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cv-stdremove_cvref-trait-p0550r2" title="型から cv 修飾と参照を除去する std::remove_cvref trait (P0550R2)" class="md-nav__link">
    型から cv 修飾と参照を除去する std::remove_cvref trait (P0550R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddecay-p0777r1" title="標準ライブラリでの不必要な std::decay の使用を回避 (P0777R1)" class="md-nav__link">
    標準ライブラリでの不必要な std::decay の使用を回避 (P0777R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numbers-p0631r8" title="数学定数を提供する &lt;numbers&gt; ヘッダ (P0631R8)" class="md-nav__link">
    数学定数を提供する &lt;numbers&gt; ヘッダ (P0631R8)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basic_stringreserve-capacity-p0966r1" title="basic_string::reserve() が capacity を縮小しないように (P0966R1)" class="md-nav__link">
    basic_string::reserve() が capacity を縮小しないように (P0966R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constains-p0458r2" title="連想コンテナに constains() メンバ関数を追加 (P0458R2)" class="md-nav__link">
    連想コンテナに constains() メンバ関数を追加 (P0458R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stderase-stderase_if-p1209r0" title="コンテナから指定した要素を削除する操作に一貫して使える std::erase(), std::erase_if() 関数 (P1209R0)" class="md-nav__link">
    コンテナから指定した要素を削除する操作に一貫して使える std::erase(), std::erase_if() 関数 (P1209R0)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../cppx/" title="C++23 以降に向けた提案" class="md-nav__link">
      C++23 以降に向けた提案
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../meetings/" title="標準化会議" class="md-nav__link">
      標準化会議
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../status/" title="処理系の対応状況" class="md-nav__link">
      処理系の対応状況
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../working-drafts/" title="規格ドラフト" class="md-nav__link">
      規格ドラフト
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../header/" title="C++ 標準ライブラリ" class="md-nav__link">
      C++ 標準ライブラリ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      記事
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        記事
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/comment-tricks/" title="コメントアウトのトリック" class="md-nav__link">
      コメントアウトのトリック
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/it-compiles/" title="なぜかコンパイルできる" class="md-nav__link">
      なぜかコンパイルできる
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/it-does-not-compile/" title="なぜかコンパイルできない" class="md-nav__link">
      なぜかコンパイルできない
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/how-to-read-keywords/" title="予約語の読みと名前の由来" class="md-nav__link">
      予約語の読みと名前の由来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/how-to-read-libraries/" title="標準ライブラリの読みと名前の由来" class="md-nav__link">
      標準ライブラリの読みと名前の由来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/ieee754-arithmetic/" title="IEEE 754 演算のルール" class="md-nav__link">
      IEEE 754 演算のルール
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/acronyms/" title="C++ 関連の略語" class="md-nav__link">
      C++ 関連の略語
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      学習
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        学習
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/books/" title="C++ 書籍" class="md-nav__link">
      C++ 書籍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/online-resources/" title="C++ オンライン資料" class="md-nav__link">
      C++ オンライン資料
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/studymeetings/" title="国内の C++ 勉強会" class="md-nav__link">
      国内の C++ 勉強会
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/communities/" title="C++ コミュニティ" class="md-nav__link">
      C++ コミュニティ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      ライブラリ
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        ライブラリ
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/boost/" title="Boost" class="md-nav__link">
      Boost
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/containers/" title="コンテナ" class="md-nav__link">
      コンテナ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/text-data/" title="テキストデータ" class="md-nav__link">
      テキストデータ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/multi-threading/" title="並行・並列" class="md-nav__link">
      並行・並列
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/testing/" title="テストフレームワーク" class="md-nav__link">
      テストフレームワーク
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      ツール
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        ツール
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/compilers/" title="C++ コンパイラ" class="md-nav__link">
      C++ コンパイラ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/onlinecompilers/" title="C++ オンラインコンパイラ" class="md-nav__link">
      C++ オンラインコンパイラ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/package-manager/" title="C++ パッケージマネージャ" class="md-nav__link">
      C++ パッケージマネージャ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      貢献
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        貢献
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../contribution/contributors/" title="コントリビュータ" class="md-nav__link">
      コントリビュータ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目次</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" title="言語機能" class="md-nav__link">
    言語機能
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0683r1" title="ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)" class="md-nav__link">
    ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0704r1" title="メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)" class="md-nav__link">
    メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p1236r1" title="符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)" class="md-nav__link">
    符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8-bit-2" title="（参考）符号付き 8-bit 整数の 2 進表現" class="md-nav__link">
    （参考）符号付き 8-bit 整数の 2 進表現
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-no_unique_address-p0840r2" title="メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)" class="md-nav__link">
    メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename-p0634r3" title="型名であることが明らかな文脈で typename を省略可能に (P0634R3)" class="md-nav__link">
    型名であることが明らかな文脈で typename を省略可能に (P0634R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1064r0" title="定数式での仮想関数呼び出しが可能に (P1064R0)" class="md-nav__link">
    定数式での仮想関数呼び出しが可能に (P1064R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_id-dynamic_cast-constexpr-p1327r1" title="type_id と dynamic_cast が constexpr に (P1327R1)" class="md-nav__link">
    type_id と dynamic_cast が constexpr に (P1327R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1330r0" title="定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)" class="md-nav__link">
    定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try-catch-p1002r1" title="定数式の文脈では try-catch を無視するように (P1002R1)" class="md-nav__link">
    定数式の文脈では try-catch を無視するように (P1002R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deprecated-p1161r3" title="添字式にかかるコンマ演算子の使用を deprecated に (P1161R3)" class="md-nav__link">
    添字式にかかるコンマ演算子の使用を deprecated に (P1161R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-p1099r5" title="スコープ付き列挙型に対する using 宣言ができるように (P1099R5)" class="md-nav__link">
    スコープ付き列挙型に対する using 宣言ができるように (P1099R5)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p1771r1" title="コンストラクタに [[nodiscard]] が使えるように (P1771R1)" class="md-nav__link">
    コンストラクタに [[nodiscard]] が使えるように (P1771R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inline-namespace-p1094r2" title="ネストした名前空間定義で inline namespace を使えるように (P1094R2)" class="md-nav__link">
    ネストした名前空間定義で inline namespace を使えるように (P1094R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#private-p0969r0" title="本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった問題を修正 (P0969R0)" class="md-nav__link">
    本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった問題を修正 (P0969R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1008r1" title="ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 (P1008R1)" class="md-nav__link">
    ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 (P1008R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#throw-p0619r4" title="throw() による動的例外指定を削除 (P0619R4)" class="md-nav__link">
    throw() による動的例外指定を削除 (P0619R4)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="標準ライブラリ" class="md-nav__link">
    標準ライブラリ
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0457r2" title="文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)" class="md-nav__link">
    文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operatorbasic_istream-chart-chartn-p0487r1" title="operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)" class="md-nav__link">
    operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p0600r1" title="戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)" class="md-nav__link">
    戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-constexpr-p1023r0-p1032r1" title="&lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)" class="md-nav__link">
    &lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chrono-zero-min-max-noexcept-p0972r0" title="&lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)" class="md-nav__link">
    &lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointer_traits-constexpr-p1006r1" title="pointer_traits が constexpr に (P1006R1)" class="md-nav__link">
    pointer_traits が constexpr に (P1006R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assume_aligned-p1007r3" title="ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)" class="md-nav__link">
    ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make-p1020r1" title="スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)" class="md-nav__link">
    スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_type-p0919r3" title="非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)" class="md-nav__link">
    非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdmidpoint-p0811r3" title="2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)" class="md-nav__link">
    2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdlerp-p0811r3" title="2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)" class="md-nav__link">
    2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-p0754r2" title="実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)" class="md-nav__link">
    実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_nothrow_convertible-p0758r1" title="例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)" class="md-nav__link">
    例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdto_address-p0653r2" title="ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)" class="md-nav__link">
    ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-constexpr-p0415r1" title="&lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)" class="md-nav__link">
    &lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_constant_evaluated-p0595r2" title="コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)" class="md-nav__link">
    コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0020r6" title="浮動小数点数型のアトミック操作を拡張 (P0020R6)" class="md-nav__link">
    浮動小数点数型のアトミック操作を拡張 (P0020R6)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmemory_order-enum-class-p0439r0" title="std::memory_order を enum class に変更 (P0439R0)" class="md-nav__link">
    std::memory_order を enum class に変更 (P0439R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-p0809r0" title="Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)" class="md-nav__link">
    Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0463r1" title="実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)" class="md-nav__link">
    実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cv-stdremove_cvref-trait-p0550r2" title="型から cv 修飾と参照を除去する std::remove_cvref trait (P0550R2)" class="md-nav__link">
    型から cv 修飾と参照を除去する std::remove_cvref trait (P0550R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddecay-p0777r1" title="標準ライブラリでの不必要な std::decay の使用を回避 (P0777R1)" class="md-nav__link">
    標準ライブラリでの不必要な std::decay の使用を回避 (P0777R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numbers-p0631r8" title="数学定数を提供する &lt;numbers&gt; ヘッダ (P0631R8)" class="md-nav__link">
    数学定数を提供する &lt;numbers&gt; ヘッダ (P0631R8)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basic_stringreserve-capacity-p0966r1" title="basic_string::reserve() が capacity を縮小しないように (P0966R1)" class="md-nav__link">
    basic_string::reserve() が capacity を縮小しないように (P0966R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constains-p0458r2" title="連想コンテナに constains() メンバ関数を追加 (P0458R2)" class="md-nav__link">
    連想コンテナに constains() メンバ関数を追加 (P0458R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stderase-stderase_if-p1209r0" title="コンテナから指定した要素を削除する操作に一貫して使える std::erase(), std::erase_if() 関数 (P1209R0)" class="md-nav__link">
    コンテナから指定した要素を削除する操作に一貫して使える std::erase(), std::erase_if() 関数 (P1209R0)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="c20">C++20 の新機能<a class="headerlink" href="#c20" title="Permanent link">&para;</a></h1>
<p>C++20 の変更すべてをカバーするために、項目追加・執筆作業中です（完成度 約 25%）</p>
<h2 id="_1">言語機能<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h3 id="p0683r1">ビットフィールドにデフォルトの初期値を設定可能に <a href="http://wg21.link/p0683r1">(P0683R1)</a><a class="headerlink" href="#p0683r1" title="Permanent link">&para;</a></h3>
<p>ビットフィールドにおけるビット幅の指定に続いて、<code class="codehilite"><span class="o">=</span></code> 演算子または <code class="codehilite"><span class="err">{}</span></code> 初期化子を使って初期化式を記述できるようになります。</p>
<p><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Forest</span><span class="p">,</span> <span class="n">Hill</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">Desert</span><span class="p">,</span> <span class="n">Tundra</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Tile</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">height</span> <span class="p">:</span> <span class="mi">4</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// デフォルト値を 1 に</span>
    <span class="n">Terrain</span> <span class="nl">terrain</span> <span class="p">:</span> <span class="mi">3</span> <span class="o">=</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Open</span><span class="p">;</span> <span class="c1">// デフォルト値を明示的に Terrain::Open に</span>
    <span class="kt">bool</span> <span class="nl">passable</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// デフォルト値を true に</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="n">Tile</span> <span class="n">tile1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tile1</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile1</span><span class="p">.</span><span class="n">terrain</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tile1</span><span class="p">.</span><span class="n">passable</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">Tile</span> <span class="n">tile2</span><span class="p">{</span> <span class="mi">15</span><span class="p">,</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">,</span> <span class="nb">false</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tile2</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile2</span><span class="p">.</span><span class="n">terrain</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tile2</span><span class="p">.</span><span class="n">passable</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">true</span>
<span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="k">false</span>
</pre></div></p>
<h3 id="p0704r1">メンバポインタ演算子の仕様を一貫性のために修正 <a href="http://wg21.link/p0704r1">(P0704R1)</a><a class="headerlink" href="#p0704r1" title="Permanent link">&para;</a></h3>
<p>C++17 までのメンバポインタ演算子 <code class="codehilite"><span class="p">.</span><span class="o">*</span></code> は「右辺値オブジェクトから、左辺値参照修飾されたメンバ関数ポインタに使うことは不適格」という規格文面になっていました。そのため、同じ意味をもつ次の 2 つのプログラムで後者だけ不適格とされ、一貫性がありませんでした。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Text</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_data</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Text</span><span class="p">{</span> <span class="s">&quot;Hello&quot;</span> <span class="p">}.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">Text</span><span class="p">{</span> <span class="s">&quot;Hello&quot;</span> <span class="p">}.</span><span class="o">*&amp;</span><span class="n">Text</span><span class="o">::</span><span class="n">get</span><span class="p">)()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// C++17 までは不適格、C++20 から OK</span>
<span class="p">}</span>
</pre></div>
C++20 では「右辺値オブジェクトから、左辺値参照修飾された "非 const" メンバ関数ポインタに使うことは不適格」と文面を修正し、後者もコンパイルできるようになります。</p>
<h3 id="2-p1236r1">符号付き整数型の負数表現を 2 の補数と規定 <a href="http://wg21.link/p1236r1">(P1236R1)</a><a class="headerlink" href="#2-p1236r1" title="Permanent link">&para;</a></h3>
<p>ほぼすべての現代的なコンピュータで、符号付き整数型の負数は 2 の補数で表現されます。しかし、C++ では負数の表現方法について規格で定めていなかったため、（現実的ではありませんが）2 の補数以外で負数表現を実装する余地も残されていました。C++20 からは 2 の補数のみを許可するよう規格文言が修正されました。<br />
近年のアーキテクチャで 2 の補数以外を使う例は、1 の補数を使う Unisys 2200 があります。また過去には符号と絶対値で表現するアーキテクチャもありました。これらはモダンな C++ を開発環境として使用しないので、この規格変更による影響は無いと考えられます。</p>
<h4 id="8-bit-2">（参考）符号付き 8-bit 整数の 2 進表現<a class="headerlink" href="#8-bit-2" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>10 進表現</th>
<th>2 の補数</th>
<th>1 の補数</th>
<th>符号と絶対値</th>
</tr>
</thead>
<tbody>
<tr>
<td>127</td>
<td>01111111</td>
<td>01111111</td>
<td>01111111</td>
</tr>
<tr>
<td>126</td>
<td>01111110</td>
<td>01111110</td>
<td>01111110</td>
</tr>
<tr>
<td>125</td>
<td>01111101</td>
<td>01111101</td>
<td>01111101</td>
</tr>
<tr>
<td>2</td>
<td>00000010</td>
<td>00000010</td>
<td>00000010</td>
</tr>
<tr>
<td>1</td>
<td>00000001</td>
<td>00000001</td>
<td>00000001</td>
</tr>
<tr>
<td>0</td>
<td>00000000</td>
<td>00000000</td>
<td>00000000</td>
</tr>
<tr>
<td>-0</td>
<td></td>
<td>11111111</td>
<td>10000000</td>
</tr>
<tr>
<td>-1</td>
<td>11111111</td>
<td>11111110</td>
<td>10000001</td>
</tr>
<tr>
<td>-2</td>
<td>11111110</td>
<td>11111101</td>
<td>10000010</td>
</tr>
<tr>
<td>-126</td>
<td>10000010</td>
<td>10000001</td>
<td>11111110</td>
</tr>
<tr>
<td>-127</td>
<td>10000001</td>
<td>10000000</td>
<td>11111111</td>
</tr>
<tr>
<td>-128</td>
<td>10000000</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="0-no_unique_address-p0840r2">メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる <code class="codehilite"><span class="o">[</span><span class="n">[no_unique_address</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を追加 <a href="http://wg21.link/p0840r2">(P0840R2)</a><a class="headerlink" href="#0-no_unique_address-p0840r2" title="Permanent link">&para;</a></h3>
<p>アロケータなどをクラスのメンバとして保持するとき、それがステートレスな空のクラスであってもオブジェクトのアドレスを一意に用意しないといけないため、サイズを 0 にできずメモリ消費が無駄に増えてしまう問題がありました。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4 より大きい</span>
<span class="p">}</span>
</pre></div>
これを回避するために「空の基底クラスは最適化によってサイズ 0 にしてよい」という仕様を利用した Empty Base Optimization (EBO) というテクニックがあり、標準ライブラリでも　<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span></code> や <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> などに使われています。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">X</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Empty</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</pre></div>
しかし、これらのクラスで継承による EBO を実装するとコードが複雑になるという欠点がありました。C++20 ではメンバの宣言に <code class="codehilite"><span class="o">[</span><span class="n">[no_unique_address</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を付けることで、継承を使わなくてもコンパイラが EBO と同じような最適化をできるようになり、従来の継承による EBO を使っていたコードを、より単純なコードに置き換えられます。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span> <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="typename-p0634r3">型名であることが明らかな文脈で <code class="codehilite"><span class="n">typename</span></code> を省略可能に <a href="https://wg21.link/P0634R3">(P0634R3)</a><a class="headerlink" href="#typename-p0634r3" title="Permanent link">&para;</a></h3>
<p>C++17 で依存名が型である場合に <code class="codehilite"><span class="n">typename</span></code> を付けないのは、派生クラス定義時の基底クラスの指定と、初期化子リストでの基底クラスの指定のみでした（厳密にはこの 2 つには <code class="codehilite"><span class="n">typename</span></code> を付けられません）。C++20 では、型名しか使えないさらにいくつかの文脈で <code class="codehilite"><span class="n">typename</span></code> が省略可能になります。次のサンプルコードの左右タブで比較できます。</p>
<div class="superfences-tabs">
<input name="__tabs_1" type="radio" id="__tab_1_0" checked="checked" />
<label for="__tab_1_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">S</span> <span class="p">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="c1">// 派生クラス定義時の基底クラスの指定</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>

    <span class="n">S</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 初期化子リストでの基底クラスの指定</span>

    <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">pointer</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">min_size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">MaxSize</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>
<input name="__tabs_1" type="radio" id="__tab_1_1" />
<label for="__tab_1_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;</span> <span class="c1">// OK</span>
<span class="k">struct</span> <span class="nl">S</span> <span class="p">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="c1">// 派生クラス定義時の基底クラスの指定</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="n">S</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 初期化子リストでの基底クラスの指定</span>

    <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">T</span><span class="o">::</span><span class="n">pointer</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="nf">min_size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// OK</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">MaxSize</span><span class="p">();</span> <span class="c1">// OK</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>
</div>
<h3 id="p1064r0">定数式での仮想関数呼び出しが可能に <a href="https://wg21.link/P1064">(P1064R0)</a><a class="headerlink" href="#p1064r0" title="Permanent link">&para;</a></h3>
<p>コンパイル時に決定可能であれば、参照やポインタを通した仮想関数の呼び出しを <code class="codehilite"><span class="n">constexpr</span></code> にできるようになります。<code class="codehilite"><span class="n">constexpr</span></code> 修飾された仮想関数を非 <code class="codehilite"><span class="n">constexpr</span></code> 関数でオーバーライドすることや、その逆も可能です。</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">GetVersion</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">version</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">Cpp20</span> <span class="n">cpp20</span><span class="p">;</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetVersion</span><span class="p">(</span><span class="n">cpp17</span><span class="p">)</span> <span class="o">==</span> <span class="mi">17</span><span class="p">);</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetVersion</span><span class="p">(</span><span class="n">cpp20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h3 id="type_id-dynamic_cast-constexpr-p1327r1"><code class="codehilite"><span class="n">type_id</span></code> と <code class="codehilite"><span class="n">dynamic_cast</span></code> が constexpr に <a href="https://wg21.link/P1327">(P1327R1)</a><a class="headerlink" href="#type_id-dynamic_cast-constexpr-p1327r1" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="n">dynamic_cast</span></code> と <code class="codehilite"><span class="n">type_id</span></code> が、例外を投げるケースを除いて <code class="codehilite"><span class="n">constexpr</span></code> になります。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">*</span> <span class="n">pCpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cpptype</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">pCpp</span><span class="p">);</span>

    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">refCpp</span> <span class="o">=</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp17</span><span class="o">&amp;</span> <span class="n">redCpp2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpp17</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">refCpp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>次のように例外を投げるケースでは <code class="codehilite"><span class="n">constexpr</span></code> にできずコンパイルエラーになります。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Cpp</span><span class="o">*</span> <span class="n">pCpp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cpptype</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">pCpp</span><span class="p">);</span> <span class="c1">//コンパイルエラー: 例外 std::bad_typeid を投げるため constexpr 不可</span>

    <span class="k">constexpr</span> <span class="k">static</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">refCpp</span> <span class="o">=</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp20</span><span class="o">&amp;</span> <span class="n">redCpp2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpp20</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">refCpp</span><span class="p">);</span> <span class="c1">// コンパイルエラー: 例外 std::bad_cast を投げるため constexpr 不可</span>
<span class="p">}</span>
</pre></div>

<h3 id="p1330r0">定数式において共用体のアクティブメンバの切り替えが可能に <a href="https://wg21.link/P1330">(P1330R0)</a><a class="headerlink" href="#p1330r0" title="Permanent link">&para;</a></h3>
<p>共用体のアクティブメンバとは、最後に初期化または値を代入したメンバのことです。C++17 では共用体の初期化やアクティブメンバへのアクセスを定数式で行えましたが、アクティブメンバの切り替えはできませんでした。定数式でのアクティブメンバの切り替えが可能になると、共用体によって実装される <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">string</span></code> や <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">optional</span></code> などの標準ライブラリクラスのメンバ関数の <code class="codehilite"><span class="n">constexpr</span></code> 対応を拡充できます。非アクティブメンバへのアクセスは未定義動作なので、定数式で行うとコンパイルエラーになります。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>

<span class="k">union</span> <span class="n">Value</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">Value</span> <span class="nf">GetFloat</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Value</span><span class="p">{</span> <span class="n">x</span> <span class="p">};</span> <span class="c1">// value.f がアクティブメンバ</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">Value</span> <span class="nf">GetUint</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Value</span> <span class="n">value</span> <span class="o">=</span> <span class="n">GetFloat</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span> <span class="c1">// value.f がアクティブメンバ</span>
    <span class="n">value</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// value.i がアクティブメンバに</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetUint</span><span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="n">i</span> <span class="o">==</span> <span class="mi">123</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h3 id="try-catch-p1002r1">定数式の文脈では <code class="codehilite"><span class="n">try</span><span class="o">-</span><span class="n">catch</span></code> を無視するように <a href="https://wg21.link/P1002">(P1002R1)</a><a class="headerlink" href="#try-catch-p1002r1" title="Permanent link">&para;</a></h3>
<p>これまで <code class="codehilite"><span class="n">constexpr</span></code> 関数の中には <code class="codehilite"><span class="n">try</span><span class="o">-</span><span class="n">catch</span></code> ブロックを書くことができませんでした。しかし、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> 等のコンテナを <code class="codehilite"><span class="n">constexpr</span></code> 対応するにあたっては、この制限が障壁となるため、C++20 では <code class="codehilite"><span class="n">constexpr</span></code> 関数の中の <code class="codehilite"><span class="n">try</span><span class="o">-</span><span class="n">catch</span></code> は、定数式として評価されるときには無視するよう仕様が改められます。定数式の評価中に例外を投げるようであればコンパイルエラーになります。<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> などを <code class="codehilite"><span class="n">constexpr</span></code> 対応させるための措置であり、将来の C++ におけるコンパイル時例外処理の実現を否定するものではありません。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt; </span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt; </span><span class="cp"></span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">AddU8</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">{};</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">DoubleU8</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">AddU8</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">except</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">DoubleU8</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span> <span class="o">==</span> <span class="mi">246</span><span class="p">);</span> <span class="c1">// OK: 例外を投げずに定数式として評価可能</span>

    <span class="c1">//static_assert(DoubleU8(200) &gt; 0); // コンパイルエラー: 定数式として評価される constexpr 関数内で例外を投げるため</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;result: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">DoubleU8</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// OK: 実行時に評価される関数で例外が発生する</span>
<span class="p">}</span>
</pre></div>

<h3 id="deprecated-p1161r3">添字式にかかるコンマ演算子の使用を deprecated に <a href="https://wg21.link/P1161R3">(P1161R3)</a><a class="headerlink" href="#deprecated-p1161r3" title="Permanent link">&para;</a></h3>
<p>これまで <code class="codehilite"><span class="nb">array</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span></code> というコードでは、コンマ演算子の作用で <code class="codehilite"><span class="n">y</span></code> が添字演算の引数として渡されました。しかし、この挙動は紛らわしく、将来の C++ 標準ライブラリに多次元配列クラスが実装されたとき、添字演算子を複数の引数に対応させるような規格を追加するうえでの障壁にもなります。そのため、C++20 から、<code class="codehilite"><span class="nb">array</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span></code> のように括弧を使用する場合をのぞき、添字式にかかるコンマ演算子の使用が deprecated になります。古いコードで deprecated な書き方をしていた場合、前述のように <code class="codehilite"><span class="p">()</span></code> を付けることで、コードの挙動に影響を与えずに移植が可能です。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">v</span><span class="p">[</span><span class="o">++</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// C++17 まで OK, C++20 から deprecated</span>

    <span class="n">v</span><span class="p">[(</span><span class="o">++</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>

<h3 id="using-p1099r5">スコープ付き列挙型に対する using 宣言ができるように <a href="http://wg21.link/p1099r5">(P1099R5)</a><a class="headerlink" href="#using-p1099r5" title="Permanent link">&para;</a></h3>
<p>これまでは、enum class のスコープ解決を省略する方法が無く、次のような <code class="codehilite"><span class="n">switch</span></code> で、列挙型の名前が何度も登場するようなコードを書く必要があり、読みにくく、長い列挙型の名前が避けられる原因になっていました。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span> <span class="n">terrain</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view_literals</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">terrain</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Open</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;Open&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Mountain</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;Mountain&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">River</span><span class="p">:</span>    <span class="k">return</span> <span class="s">&quot;River&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">Terrain</span><span class="o">::</span><span class="nl">Ocean</span><span class="p">:</span>    <span class="k">return</span> <span class="s">&quot;Ocean&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>                <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
C++20 では <code class="codehilite"><span class="k">using</span></code> 宣言を拡張し、<code class="codehilite"><span class="nt">using</span> <span class="nt">Terrain</span><span class="p">::</span><span class="nd">Open</span><span class="o">;</span></code> で <code class="codehilite"><span class="k">Open</span></code> をエイリアスとして使えるようになります。また <code class="codehilite"><span class="k">using</span> <span class="n">enum</span></code> 宣言という新しい仕組みにより、<code class="codehilite"><span class="k">using</span> <span class="n">enum</span> <span class="n">Terrain</span><span class="p">;</span></code> で <code class="codehilite"><span class="n">Terrain</span></code> がローカルスコープに導入され、スコープ解決演算子を使わずにその列挙子を使えるようになります。
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Terrain</span> <span class="n">terrain</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view_literals</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">terrain</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">Terrain</span><span class="p">;</span> <span class="c1">// using enum 宣言で、列挙型の名前 Terrain をローカルスコープに導入</span>
    <span class="k">case</span> <span class="nl">Open</span><span class="p">:</span>      <span class="k">return</span> <span class="s">&quot;Open&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Mountain</span><span class="p">:</span>  <span class="k">return</span> <span class="s">&quot;Mountain&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">River</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;River&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Ocean</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;Ocean&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="n">sv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">;</span> <span class="c1">// using 宣言で、列挙子 Mountain をローカルスコープに導入</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ToString</span><span class="p">(</span><span class="n">Mountain</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
なお、次のように複数の <code class="codehilite"><span class="k">using</span></code> 宣言によって名前の衝突が起こる場合はコンパイルエラーになります。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">State</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Closed</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">Terrain</span><span class="p">;</span> <span class="c1">// OK</span>
    <span class="k">using</span> <span class="k">enum</span> <span class="n">State</span><span class="p">;</span>   <span class="c1">// コンパイルエラー: Terrain::Open と State::Open の名前が衝突</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="nodiscard-p1771r1">コンストラクタに <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> が使えるように <a href="http://wg21.link/p1771r1">(P1771R1)</a><a class="headerlink" href="#nodiscard-p1771r1" title="Permanent link">&para;</a></h3>
<p>C++17 で <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> が導入された際、仕様ではコンストラクタを対象としていませんでした（ただし、GCC では警告を出しつつもコンストラクタに付けた <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> をチェックしていました）。コンストラクタの呼び出しによって作成された一時オブジェクトが意図せず無視されたときに警告を出せると、ユーザの間違いを減らせます。そこで、コンストラクタにも <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を付けられるよう、C++17 向けの規格にさかのぼって仕様が修正され、C++20 および、この変更に対応した C++17 コンパイラで新仕様を利用できるようになります。なお、デストラクタを定義していた場合でも警告は消えません。
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">Circle</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

    <span class="n">Circle</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_r</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">),</span> <span class="n">r</span><span class="p">(</span><span class="n">_r</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Circle</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span> <span class="c1">// warning: nodiscard 属性のコンストラクタで作成された一時オブジェクトを無視</span>

    <span class="n">Circle</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">50</span><span class="p">).</span><span class="n">draw</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="inline-namespace-p1094r2">ネストした名前空間定義で <code class="codehilite"><span class="n">inline</span> <span class="n">namespace</span></code> を使えるように <a href="http://wg21.link/p1094r2">(P1094R2)</a><a class="headerlink" href="#inline-namespace-p1094r2" title="Permanent link">&para;</a></h3>
<p>C++17 でネストした名前空間定義が導入されましたが、その中では <code class="codehilite"><span class="n">inline</span> <span class="n">namespace</span></code> を使うことができず、<code class="codehilite"><span class="n">inline</span> <span class="n">namespace</span></code> が <code class="codehilite"><span class="n">namespace</span></code> 内にある次のようなケースで恩恵を受けられませんでした。C++20 からはネストした名前空間定義の中で <code class="codehilite"><span class="n">inline</span></code> を使えるようになります。</p>
<div class="superfences-tabs">
<input name="__tabs_2" type="radio" id="__tab_2_0" checked="checked" />
<label for="__tab_2_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">mylib</span>
<span class="p">{</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">v2</span>
    <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">util</span>
        <span class="p">{</span>
            <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v2</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// v2</span>
<span class="p">}</span>
</pre></div></div>
<input name="__tabs_2" type="radio" id="__tab_2_1" />
<label for="__tab_2_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">mylib</span><span class="o">::</span><span class="kr">inline</span> <span class="n">v2</span><span class="o">::</span><span class="n">util</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">v2</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mylib</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// v2</span>
<span class="p">}</span>
</pre></div></div>
</div>
<h3 id="private-p0969r0">本来アクセス可能な private メンバに構造化束縛ではアクセスできなかった問題を修正 <a href="https://wg21.link/P0969R0">(P0969R0)</a><a class="headerlink" href="#private-p0969r0" title="Permanent link">&para;</a></h3>
<p>メンバ関数内で自身の <code class="codehilite"><span class="n">private</span></code> メンバにアクセスすることや、<code class="codehilite"><span class="n">friend</span></code> 指定された関数で該当クラスの <code class="codehilite"><span class="n">private</span></code> メンバ変数にアクセスすることは通常可能ですが、C++17 の構造化束縛はクラスの <code class="codehilite"><span class="k">public</span></code> メンバにしかバインドできないという規格文面の制約があり、次のようなケースで一貫性がありませんでした。この制約を課す合理的な理由は無かったため、C++17 向けの規格にさかのぼって仕様が修正され、アクセス可能であれば <code class="codehilite"><span class="n">private</span></code> メンバ変数をバインドできるようになります。C++20 および、この変更に対応した C++17 コンパイラで新仕様を利用できます。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Date</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>

    <span class="kt">int</span> <span class="n">m_year</span><span class="p">,</span> <span class="n">m_month</span><span class="p">,</span> <span class="n">m_day</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

    <span class="k">friend</span> <span class="kt">void</span> <span class="n">Work</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">date</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="c1">// OK</span>
        <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_year</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_month</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_day</span><span class="p">;</span>

        <span class="c1">// これまではコンパイルエラー, C++20 以降 OK</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// friend 指定されている関数</span>
<span class="kt">void</span> <span class="nf">Work</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">date</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// OK</span>
    <span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_year</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_month</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">m_day</span><span class="p">;</span>

    <span class="c1">// これまではコンパイルエラー, C++20 以降 OK</span>
    <span class="k">auto</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">date</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>

<h3 id="p1008r1">ユーザ宣言されたコンストラクタを持つクラスの集成体初期化を禁止 <a href="https://wg21.link/P1008R1">(P1008R1)</a><a class="headerlink" href="#p1008r1" title="Permanent link">&para;</a></h3>
<p>C++17 までは集成体の要件が緩かったため、コンストラクタについては、デフォルトコンストラクタが <code class="codehilite"><span class="o">=</span> <span class="k">delete</span></code> または <code class="codehilite"><span class="n">private</span></code> であっても、集成体初期化によって初期化できる抜け道がありました。これはメンバ変数が意図しない値で初期化されるといった問題を引き起こします。C++20 からは集成体の要件が厳しくなり、ユーザ宣言されたコンストラクタがあるクラスは集成体にはなりません。</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">B</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">C</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">;</span> <span class="c1">// コンパイルエラー</span>
    <span class="n">A</span> <span class="n">a2</span><span class="p">{};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>

    <span class="n">B</span> <span class="n">b1</span><span class="p">;</span> <span class="c1">// コンパイルエラー</span>
    <span class="n">B</span> <span class="n">b2</span><span class="p">{};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>

    <span class="n">C</span> <span class="n">c1</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">//コンパイルエラー</span>
    <span class="n">C</span> <span class="n">c2</span><span class="p">{</span> <span class="mi">123</span> <span class="p">};</span> <span class="c1">// C++17 までは OK, C++20 からはコンパイルエラー</span>
<span class="p">}</span>
</pre></div>

<h3 id="throw-p0619r4"><code class="codehilite"><span class="n">throw</span><span class="p">()</span></code> による動的例外指定を削除 <a href="https://wg21.link/P0619R4">(P0619R4)</a><a class="headerlink" href="#throw-p0619r4" title="Permanent link">&para;</a></h3>
<p>C++11 では、<code class="codehilite"><span class="n">noexcept</span></code> の追加に合わせ、<code class="codehilite"><span class="n">throw</span><span class="p">(</span><span class="n">typeid</span><span class="p">,</span> <span class="p">...)</span></code> や <code class="codehilite"><span class="n">throw</span><span class="p">()</span></code> による動的例外指定が非推奨化されました。C++17 では前者が削除されましたが、古いコードにおいて広く使われていた後者は、移行猶予のために <code class="codehilite"><span class="n">noexcept</span><span class="p">(</span><span class="k">true</span><span class="p">)</span></code> のエイリアスとして改められつつ保持されていました。C++20 では後者も削除されます。</p>
<h2 id="_2">標準ライブラリ<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="p0457r2">文字列の先頭や末尾が、ある文字列と一致するか判定 <a href="https://wg21.link/P0457R2">(P0457R2)</a><a class="headerlink" href="#p0457r2" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string</span></code> と <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string_view</span></code> に、<code class="codehilite"><span class="n">starts_with</span><span class="p">()</span></code> と <code class="codehilite"><span class="n">ends_with</span><span class="p">()</span></code> メンバ関数が追加されます。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">HasPNGExtension</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">filePath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 文字列が &quot;.png&quot; で終わるなら true, それ以外は false を返す</span>
    <span class="k">return</span> <span class="n">filePath</span><span class="p">.</span><span class="n">ends_with</span><span class="p">(</span><span class="s">&quot;.png&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;picture.png&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;photo.jpg&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;music.mp3&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="k">true</span>
<span class="k">false</span>
<span class="k">false</span>
</pre></div></p>
<h3 id="operatorbasic_istream-chart-chartn-p0487r1"><code class="codehilite"><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">charT</span><span class="o">*</span><span class="p">)</span></code> の第二引数を <code class="codehilite"><span class="n">charT</span><span class="p">(</span><span class="o">&amp;</span><span class="p">)</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="w"></span></code> に変更して安全に <a href="https://wg21.link/P0487R1">(P0487R1)</a><a class="headerlink" href="#operatorbasic_istream-chart-chartn-p0487r1" title="Permanent link">&para;</a></h3>
<p>C++17 までの <code class="codehilite"><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">charT</span><span class="o">*</span><span class="p">)</span></code> は、関数にバッファのサイズが渡されないため、次のようなプログラムでバッファオーバーフローへの対策が必要でした。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="c1">// std::cin &gt;&gt; buffer; // 危険: バッファオーバーフローの可能性</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// OK: バッファオーバーフロー対策</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
C++20 では引数を次のように変更し、関数がバッファオーバーフローの対策を実装するようになります。
<div class="codehilite"><pre><span></span><span class="c1">// C++17 まで</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span><span class="o">&gt;</span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">charT</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>

<span class="c1">// C++20 から</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">charT</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)[</span><span class="n">N</span><span class="p">]);</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// OK: C++20 ではバッファオーバーフローを防げる</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
この変更に伴い、C++17 までは有効だった次のようなプログラムが、C++20 からコンパイルエラーになります。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// C++20 からはコンパイルエラー</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="nodiscard-p0600r1">戻り値の無視が不具合をもたらす関数に <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> を付与 <a href="https://wg21.link/P0600R1">(P0600R1)</a><a class="headerlink" href="#nodiscard-p0600r1" title="Permanent link">&para;</a></h3>
<p>C++17 で導入された <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を標準ライブラリで活用するようになります。C++20 では付与基準を「戻り値の無視がトラブルやメモリリークなどの重大なエラーを引き起こす C++ の関数」とし、<code class="codehilite"><span class="n">async</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">launder</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">allocate</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">empty</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">operator</span> <span class="k">new</span><span class="p">()</span></code> が対象となっています。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>

    <span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// C++20 では警告</span>

    <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// C++20 では警告</span>
<span class="p">}</span>
</pre></div>
MSVC の標準ライブラリでは Visual Studio 2017 15.6 以降、規格の範囲を超えてより多くの関数（<a href="https://devblogs.microsoft.com/cppblog/c17-progress-in-vs-2017-15-5-and-15-6/">2,500 個以上</a>）に <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を使っています。その結果、<a href="https://bugs.chromium.org/p/webrtc/issues/detail?id=8463">Chromium のソースに無意味な std::move() が見つかる</a>など、既存のコードベースのバグの発見に役立っています。</p>
<h3 id="array-constexpr-p1023r0-p1032r1"><code class="codehilite"><span class="o">&lt;</span><span class="nb">array</span><span class="o">&gt;</span></code> ヘッダのすべての関数が constexpr に <a href="https://wg21.link/P1023R0">(P1023R0)</a>, <a href="https://wg21.link/P1032R1">(P1032R1)</a><a class="headerlink" href="#array-constexpr-p1023r0-p1032r1" title="Permanent link">&para;</a></h3>
<p>C++17 の <code class="codehilite"><span class="o">&lt;</span><span class="nb">array</span><span class="o">&gt;</span></code> ヘッダでは、比較演算子、<code class="codehilite"><span class="n">swap</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">fill</span><span class="p">()</span></code> 以外のすべての関数が constexpr でした。C++20 ではさらに、array の比較演算の実装に使われている <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">equal</span><span class="p">()</span></code> と <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">lexicographical_compare</span><span class="p">()</span></code> が <a href="https://wg21.link/P0202R3">constexpr になった (P0202R3)</a> ことにともない、array の比較演算子を constexpr とし、また <code class="codehilite"><span class="n">swap</span><span class="p">()</span></code> と <code class="codehilite"><span class="n">fill</span><span class="p">()</span></code> についても constexpr にすることを決め、array ヘッダのすべての関数が constexpr で提供されます。</p>
<h3 id="chrono-zero-min-max-noexcept-p0972r0"><code class="codehilite"><span class="o">&lt;</span><span class="n">chrono</span><span class="o">&gt;</span></code> ヘッダの <code class="codehilite"><span class="n">zero</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">min</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">max</span><span class="p">()</span></code> 関数が noexcept に <a href="https://wg21.link/P0972R0">(P0972R0)</a><a class="headerlink" href="#chrono-zero-min-max-noexcept-p0972r0" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">chrono</span><span class="p">::</span><span class="n">duration_values</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">chrono</span><span class="p">::</span><span class="n">duration</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">chrono</span><span class="p">::</span><span class="n">time_point</span></code> などの <code class="codehilite"><span class="n">zero</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">min</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">max</span><span class="p">()</span></code> 関数に noexcept が付きます。</p>
<h3 id="pointer_traits-constexpr-p1006r1"><code class="codehilite"><span class="n">pointer_traits</span></code> が constexpr に <a href="https://wg21.link/P1006R1">(P1006R1)</a><a class="headerlink" href="#pointer_traits-constexpr-p1006r1" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> を constexpr にするのに必要なため、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">pointer_traits</span><span class="p">::</span><span class="n">pointer_to</span><span class="p">()</span></code> 関数が constrexpr になります。</p>
<h3 id="assume_aligned-p1007r3">ポインタのアライメントを最適化ヒントとしてコンパイラに伝える <code class="codehilite"><span class="n">assume_aligned</span><span class="p">()</span></code> 関数 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1007r3.pdf">(P1007R3)</a><a class="headerlink" href="#assume_aligned-p1007r3" title="Permanent link">&para;</a></h3>
<p>データのアドレスが 16 バイトなどのサイズにアライメントされている場合、コンパイラが SIMD を使った最適なコードを生成できる可能性があります。あるポインタの指すデータがアライメントされていることをコンパイラに伝える方法として、GCC や Clang では <code class="codehilite"><span class="n">__builtin_assume_aligned</span><span class="p">()</span></code> や <code class="codehilite"><span class="n">__attribute__</span><span class="p">((</span><span class="n">assume_aligned</span><span class="p">(</span><span class="n">alignment</span><span class="p">)))</span></code>, ICC では <code class="codehilite"><span class="n">__assume_aligned</span><span class="p">()</span></code> などの独自拡張がありますが、標準化された方法はありませんでした。C++20 では、これらの差異を吸収する次のような関数テンプレートが提供されます。
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span><span class="o">*</span> <span class="n">assume_aligned</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</pre></div>
実際には次のように使います。
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">Multiply</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">factor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">assume_aligned</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x が 64 バイトアライメントであることを伝える</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// ループが適宜最適化される</span>
    <span class="p">{</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="make-p1020r1">スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 <a href="https://wg21.link/P1020R1">(P1020R1)</a><a class="headerlink" href="#make-p1020r1" title="Permanent link">&para;</a></h3>
<p>実行時性能のために、<code class="codehilite"><span class="nb">float</span></code> や <code class="codehilite"><span class="n">unsigned</span> <span class="nb">char</span></code> など組み込み型の配列の値をデフォルト初期化させたい（ゼロ初期化しない）ケースがあります。しかし、<code class="codehilite"><span class="n">make_unique</span></code> や <code class="codehilite"><span class="n">make_shared</span></code>, <code class="codehilite"><span class="n">allocate_shared</span></code> でスマートポインタを作成した場合には値初期化が実行されます。C++20 では、値初期化をせずにデフォルト初期化でスマートポインタを作成する関数 <code class="codehilite"><span class="n">make_unique_default_init</span></code>, <code class="codehilite"><span class="n">make_shared_default_init</span></code>, <code class="codehilite"><span class="n">allocate_shared_default_init</span></code> が追加されました。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="c1">// 未初期化の変数を使う実験的なコード</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// デフォルト初期化</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">pv</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 値初期化 (0 初期化) </span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique_default_init</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// デフォルト初期化</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
出力例
<div class="codehilite"><pre><span></span><span class="mi">2</span><span class="p">.</span><span class="mi">20325</span><span class="n">e</span><span class="o">-</span><span class="mi">38</span>
<span class="mi">4</span><span class="p">.</span><span class="mi">11052</span><span class="n">e</span><span class="o">+</span><span class="mi">32</span>
<span class="mi">1</span><span class="p">.</span><span class="mi">3013</span><span class="n">e</span><span class="o">-</span><span class="mi">45</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">48626</span><span class="n">e</span><span class="o">-</span><span class="mi">38</span>
<span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">30415</span><span class="n">e</span><span class="o">-</span><span class="mi">38</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">51341</span><span class="n">e</span><span class="o">-</span><span class="mi">38</span>
<span class="mi">4</span><span class="p">.</span><span class="mi">63281</span><span class="n">e</span><span class="o">+</span><span class="mi">30</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">32703</span><span class="n">e</span><span class="o">+</span><span class="mi">17</span>
</pre></div></p>
<h3 id="key_type-p0919r3">非順序連想コンテナのルックアップ操作で、<code class="codehilite"><span class="k">key_type</span></code> と比較可能な型を変換せずに使えるように <a href="http://wg21.link/P0919r3">(P0919R3)</a><a class="headerlink" href="#key_type-p0919r3" title="Permanent link">&para;</a></h3>
<p>C++17 までの <code class="codehilite"><span class="n">unorderd_map</span></code> や <code class="codehilite"><span class="n">unordered_set</span></code> など非順序連想コンテナでは、<code class="codehilite"><span class="n">find</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">count</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">equal_range</span><span class="p">()</span></code> などルックアップを行うメンバ関数は引数に <code class="codehilite"><span class="k">key_type</span></code> をとり、例えば次のようなケースで <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">string</span></code> 型の一時オブジェクトが作成されて非効率でした。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトが作成される</span>
<span class="p">}</span>
</pre></div>

<p>C++20 では、非順序連想コンテナのテンプレートパラメータ <code class="codehilite"><span class="n">Hash</span></code> が <code class="codehilite"><span class="n">transparent_key_equal</span></code> タグを持つときに、<code class="codehilite"><span class="k">key_type</span></code> 以外の型を引数にとるメンバ関数テンプレートのオーバーロードが使用可能になり、一時オブジェクトの作成を回避できるようになります。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">string_hash</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">transparent_key_equal</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;&gt;</span><span class="p">;</span>  <span class="c1">// KeyEqual to use</span>
    <span class="k">using</span> <span class="n">hash_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// helper local type</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">string_hash</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトは作成されない</span>

    <span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="n">sv</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトは作成されない</span>
<span class="p">}</span>
</pre></div>

<h3 id="2-stdmidpoint-p0811r3">2 つの値の中点を計算する <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">midpoint</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/P0811R3">(P0811R3)</a><a class="headerlink" href="#2-stdmidpoint-p0811r3" title="Permanent link">&para;</a></h3>
<p>2 つの値 <code class="codehilite"><span class="n">a</span></code>, <code class="codehilite"><span class="n">b</span></code> の中点を計算する際に、単純な <code class="codehilite"><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span></code> という式ではオーバーフローを起こす可能性があります。C++20 で追加される <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">midpoint</span><span class="p">()</span></code> 関数では、整数に対して
<div class="codehilite"><pre><span></span><span class="k">constexpr</span> <span class="n">Integer</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">Integer</span> <span class="n">a</span><span class="p">,</span> <span class="n">Integer</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">U</span> <span class="o">=</span> <span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span> <span class="o">?</span> <span class="n">a</span><span class="o">-</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">:</span> <span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
のような実装が使われ、オーバーフローを回避できます。<code class="codehilite"><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span></code> が奇数になるケースの結果は <code class="codehilite"><span class="n">a</span></code> の方向に丸められます。<br />
浮動小数点数に対しては次のような実装が使われます。
<div class="codehilite"><pre><span></span><span class="n">Float</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">Float</span> <span class="n">a</span><span class="p">,</span> <span class="n">Float</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">isnormal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isnormal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span> <span class="o">+</span> <span class="mi">1</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// オーバーフロー</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">2</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">,</span> <span class="mi">1</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 1500000000</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 2</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 3</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="2-stdlerp-p0811r3">2 つの値の線形補間を計算する <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">lerp</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/P0811R3">(P0811R3)</a><a class="headerlink" href="#2-stdlerp-p0811r3" title="Permanent link">&para;</a></h3>
<p>2 点 <code class="codehilite"><span class="n">a</span></code>, <code class="codehilite"><span class="n">b</span></code> の間をパラメータ <code class="codehilite"><span class="n">t</span></code> によって線形補間する関数が提供されます。計算結果 <code class="codehilite"><span class="n">r</span></code> は <code class="codehilite"><span class="n">a</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span></code> によって求められますが、実装により <code class="codehilite"><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfinite</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></code> のとき</p>
<ul>
<li><code class="codehilite"><span class="n">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span></code></li>
<li><code class="codehilite"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">1</span></code> のとき <code class="codehilite"><span class="n">isfinite</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></code></li>
<li><code class="codehilite"><span class="n">isfinite</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span></code> のとき <code class="codehilite"><span class="n">r</span> <span class="o">==</span> <span class="n">a</span></code></li>
<li><code class="codehilite"><span class="n">isfinite</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">isnan</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span></code> のとき <code class="codehilite"><span class="sx">!isnan(r)</span></code></li>
</ul>
<p>また、<code class="codehilite"><span class="n">cmp</span><span class="p">(</span><span class="n">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">t2</span><span class="p">),</span> <span class="n">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">t1</span><span class="p">))</span> <span class="o">*</span> <span class="n">cmp</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">t1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cmp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span></code> (cmp は -1, 0, 1 を返す三方比較関数とする)<br />
であることが保証されます。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 3</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 10</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 12</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="version-p0754r2">実装固有の情報をまとめる <code class="codehilite"><span class="o">&lt;</span><span class="k">version</span><span class="o">&gt;</span></code> ヘッダを追加 <a href="https://wg21.link/P0754R2">(P0754R2)</a><a class="headerlink" href="#version-p0754r2" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="n">__cpp_lib_byte</span></code>, <code class="codehilite"><span class="n">__cpp_lib_void_t</span></code> のような標準ライブラリの機能テストマクロ、その他ライブラリのバージョンや実装固有の情報をまとめる目的の <code class="codehilite"><span class="o">&lt;</span><span class="k">version</span><span class="o">&gt;</span></code> ヘッダが追加されました。
例えば C++20 以前の MSVC の標準ライブラリでは、<code class="codehilite"><span class="o">&lt;</span><span class="n">yvals_core</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span></code> という独自ヘッダに標準ライブラリの機能テストマクロがまとめられていましたが、C++20 以降ではあらゆる実装において、<code class="codehilite"><span class="o">&lt;</span><span class="k">version</span><span class="o">&gt;</span></code> ヘッダを見ることで、こうした実装固有の情報にアクセスできるため利便性が高まります。</p>
<h3 id="is_nothrow_convertible-p0758r1">例外を投げない暗黙の変換が可能か調べる <code class="codehilite"><span class="n">is_nothrow_convertible</span></code> <a href="https://wg21.link/P0758R1">(P0758R1)</a><a class="headerlink" href="#is_nothrow_convertible-p0758r1" title="Permanent link">&para;</a></h3>
<p>型 <code class="codehilite"><span class="k">From</span></code> から型 <code class="codehilite"><span class="k">To</span></code> への暗黙の変換が可能であるかを調べる型特性クラス <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="k">class</span> <span class="k">From</span><span class="p">,</span> <span class="k">class</span> <span class="k">To</span><span class="o">&gt;</span></code> が C++11 から導入されましたが、その変換が <code class="codehilite"><span class="n">noexcept</span></code> でもあるかを調べられるバージョンは実装されていませんでした。
このことが原因で、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">decay_copy</span></code> の提案 (<a href="http://wg21.link/n3255">N3255</a>) において、適切な <code class="codehilite"><span class="n">noexcept</span></code> 例外仕様を移植性のある方法で定義できない問題 (<a href="http://wg21.link/lwg2040">LWG 2040</a>) が指摘されていました。
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> 
<span class="k">typename</span> <span class="n">decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">decay_copy</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="o">???</span> <span class="cm">/* is_nothrow_convertible&lt;T, T&gt;::value */</span><span class="p">);</span>
</pre></div>
C++20 からは、<code class="codehilite"><span class="n">noexcept</span></code> な暗黙の変換が可能であることを調べる新しい型特性クラス <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_nothrow_convertible</span><span class="o">&lt;</span><span class="k">class</span> <span class="k">From</span><span class="p">,</span> <span class="k">class</span> <span class="k">To</span><span class="o">&gt;</span></code> が実装されることで問題を解消できます。
既存の標準ライブラリ関数においても、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string</span></code> のメンバ関数テンプレートに、より適切な <code class="codehilite"><span class="n">noexcept</span></code> 例外仕様を定義するために活用されます。</p>
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">size_type</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">is_nothrow_convertible_v</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">basic_string_view</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span> <span class="n">Traits</span><span class="o">&gt;&gt;</span><span class="p">);</span>
</pre></div>

<h3 id="stdto_address-p0653r2">ポインタライクなオブジェクトからアドレスを取得する <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">to_address</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/P0653R2">(P0653R2)</a><a class="headerlink" href="#stdto_address-p0653r2" title="Permanent link">&para;</a></h3>
<p>ポインタライクなオブジェクトを引数にとり、それが表すのと同じアドレスを生ポインタで返す関数 <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">to_address</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></code> が追加されます。オブジェクトがポインタ型の場合はその値を返し、それ以外の場合、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">pointer_traits</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&gt;</span><span class="p">::</span><span class="n">to_address</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></code> の特殊化が定義されていて使えればその戻り値を、そうでない場合は <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">to_address</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">())</span></code> の戻り値を返します。</p>
<h3 id="complex-constexpr-p0415r1"><code class="codehilite"><span class="o">&lt;</span><span class="n">complex</span><span class="o">&gt;</span></code> ヘッダの関数の <code class="codehilite"><span class="n">constexpr</span></code> 対応を強化 <a href="https://wg21.link/P0415R1">(P0415R1)</a><a class="headerlink" href="#complex-constexpr-p0415r1" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="o">&lt;</span><span class="n">complex</span><span class="o">&gt;</span></code> ヘッダが提供する関数のうち、複素数の四則演算、ノルムの取得、共役複素数の取得など、<code class="codehilite"><span class="n">constexpr</span></code> 非対応の数学関数 (sqrt など) を使わずに実装できるものが <code class="codehilite"><span class="n">constexpr</span></code> 化されます。</p>
<h3 id="stdis_constant_evaluated-p0595r2">コンパイル時評価の文脈か実行時評価の文脈かを判別できる <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_constant_evaluated</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/P0595">(P0595R2)</a><a class="headerlink" href="#stdis_constant_evaluated-p0595r2" title="Permanent link">&para;</a></h3>
<p>C++17 までは、実行するコードを、コンパイル時評価か実行時評価かに応じて使い分ける方法はありませんでした。C++20 では、コンパイル時評価されている文脈では <code class="codehilite"><span class="k">true</span></code> を、それ以外の場合では <code class="codehilite"><span class="k">false</span></code> を返す <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_constant_evaluated</span><span class="p">()</span></code> 関数が <code class="codehilite"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">&gt;</span></code> ヘッダに追加されます。例えば標準ライブラリで <code class="codehilite"><span class="n">constexpr</span></code> 対応していないような数学関数を提供する際、コンパイル時評価では <code class="codehilite"><span class="n">constexpr</span></code> 版の実装を、実行時には非 <code class="codehilite"><span class="n">constexpr</span></code> の標準ライブラリの実装を提供するよう選択させることができます。なお、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_constant_evaluated</span><span class="p">()</span></code> を <code class="codehilite"><span class="k">if</span> <span class="nv">constexpr</span></code> の <code class="codehilite"><span class="p">(</span> <span class="p">)</span></code> 内や <code class="codehilite"><span class="n">static_assert</span></code> 内で使うと常に <code class="codehilite"><span class="k">true</span></code> に評価されてしまうので注意が必要です。基本的には <code class="codehilite"><span class="k">if</span> <span class="ss">(</span><span class="nv">std</span>::<span class="nv">is_constant_evaluated</span><span class="ss">())</span></code> と書きます。</p>
<p><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">float</span> <span class="nf">Sin_impl</span><span class="p">(</span><span class="kt">float</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">float</span> <span class="n">xn</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">?</span> <span class="mf">0.0f</span> <span class="o">:</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">xn</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">+</span> <span class="n">Sin_impl</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">xn</span> <span class="o">*</span> <span class="n">x2</span><span class="p">,</span> <span class="n">nf</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="kt">float</span> <span class="nf">Sin</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_constant_evaluated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Sin_impl</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">Pi</span> <span class="o">=</span> <span class="mf">3.14159265f</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span> <span class="c1">// コンパイル時計算    </span>
    <span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>  <span class="c1">// 実行時計算</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="mi">0</span><span class="p">.</span><span class="mi">7071068286895752</span>
<span class="mi">0</span><span class="p">.</span><span class="mi">7071067690849304</span>
</pre></div></p>
<h3 id="p0020r6">浮動小数点数型のアトミック操作を拡張 <a href="https://wg21.link/P0020R6">(P0020R6)</a><a class="headerlink" href="#p0020r6" title="Permanent link">&para;</a></h3>
<p><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="k">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> の <code class="codehilite"><span class="nb">float</span></code>, <code class="codehilite"><span class="n">double</span></code>, <code class="codehilite"><span class="n">long</span> <span class="n">double</span></code> 型の特殊化に、メンバ関数 <code class="codehilite"><span class="n">fetch_add</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">fetch_sub</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">operator</span><span class="o">+=</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">operator</span><span class="o">-=</span><span class="p">()</span></code> が追加されます。</p>
<h3 id="stdmemory_order-enum-class-p0439r0"><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">memory_order</span></code> を <code class="codehilite"><span class="k">enum</span> <span class="k">class</span></code> に変更 <a href="https://wg21.link/P0439R0">(P0439R0)</a><a class="headerlink" href="#stdmemory_order-enum-class-p0439r0" title="Permanent link">&para;</a></h3>
<p>C++17 まで <code class="codehilite"><span class="k">enum</span></code> で定義されていた <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">memory_order</span></code> を、モダンな C++ 文法と型安全のために、<code class="codehilite"><span class="k">enum</span> <span class="k">class</span></code> で定義する仕様に変更されます。これまでの表記は定数で提供されるようになるため、既存のソースコードは影響を受けません。また、バイナリ互換性のために、<code class="codehilite"><span class="k">enum</span> <span class="k">class</span></code> の基底型の選択は実装に任せられています。</p>
<div class="superfences-tabs">
<input name="__tabs_3" type="radio" id="__tab_3_0" checked="checked" />
<label for="__tab_3_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="k">enum</span> <span class="n">memory_order</span>
    <span class="p">{</span>
        <span class="n">memory_order_relaxed</span><span class="p">,</span>
        <span class="n">memory_order_consume</span><span class="p">,</span>
        <span class="n">memory_order_acquire</span><span class="p">,</span>
        <span class="n">memory_order_release</span><span class="p">,</span>
        <span class="n">memory_order_acq_rel</span><span class="p">,</span>
        <span class="n">memory_order_seq_cst</span>
    <span class="p">}</span> <span class="n">memory_order</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>
<input name="__tabs_3" type="radio" id="__tab_3_1" />
<label for="__tab_3_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">memory_order</span> <span class="cm">/* : unspecified */</span>
    <span class="p">{</span>
        <span class="n">relaxed</span><span class="p">,</span>
        <span class="n">consume</span><span class="p">,</span>
        <span class="n">acquire</span><span class="p">,</span>
        <span class="n">release</span><span class="p">,</span>
        <span class="n">acq_rel</span><span class="p">,</span>
        <span class="n">seq_cst</span>
    <span class="p">};</span>

    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_relaxed</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_consume</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">consume</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_acquire</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">acquire</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_release</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">release</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_acq_rel</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">acq_rel</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_seq_cst</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">seq_cst</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>
</div>
<h3 id="hash-p0809r0"><code class="codehilite"><span class="n">Hash</span></code> が同一の挙動をしない非順序連想コンテナどうしの比較が可能に <a href="https://wg21.link/P0809R0">(P0809R0)</a><a class="headerlink" href="#hash-p0809r0" title="Permanent link">&para;</a></h3>
<p>C++17 までは、非順序連想コンテナの <code class="codehilite"><span class="k">operator</span><span class="o">==</span></code>, <code class="codehilite"><span class="k">operator</span><span class="o">!=</span></code> について、「両者の <code class="codehilite"><span class="n">Hash</span></code> と <code class="codehilite"><span class="n">Pred</span></code> がそれぞれ同一の挙動をしない場合は未定義動作」と規格に記されていました。しかし、ランダムなソルトを使うハッシュ関数を持つコンテナ同士の比較もユースケースとして想定され、また、対応するための実装も難しくなかったことから、C++20 からはこのうち <code class="codehilite"><span class="n">Hash</span></code> に関する記述が削除されました。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">RandomizedHash</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">rnd</span><span class="p">;</span>

    <span class="n">RandomizedHash</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
        <span class="n">rnd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">rd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">s</span><span class="p">)</span> <span class="o">^</span> <span class="n">rnd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">RandomizedHash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">u1</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Three&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">RandomizedHash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">u2</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Three&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="c1">// それぞれ異なるハッシュ値を返す</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;abcde&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;u1: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">u1</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;u2: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">u2</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="c1">// C++17 までは未定義動作、C++20 から OK</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h3 id="p0463r1">実行環境のエンディアンを判別するための列挙定数を追加 <a href="https://wg21.link/P0463R1">(P0463R1)</a><a class="headerlink" href="#p0463r1" title="Permanent link">&para;</a></h3>
<p>これまでの C++ プログラムでは、ターゲットアーキテクチャのバイトオーダを判別する際にトリッキーなコードを書く必要がありました。C++20 からは、リトルエンディアンを表す <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">little</span></code>, ビッグエンディアンを表す <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">big</span></code>, 実行環境のエンディアンを表す <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">native</span></code> の 3 つの <code class="codehilite"><span class="n">endian</span></code> 型の列挙定数（値は実装に依存）が <code class="codehilite"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">&gt;</span></code> に定義され、<code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">native</span></code> をそれ以外の値と比較することで、実行環境のバイトオーダを判別できるようになります。現在の C++ コンパイラで、リトルエンディアンでもビッグエンディアンでもないミドルエンディアン（PDP エンディアンなど）をサポートしているものはありませんが、ミドルエンディアンの環境においては、<code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">native</span></code> は <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">big</span></code> でも <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">little</span></code> でもない値を持つことになっています。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">little</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Little-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">big</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Big-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Middle-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3 id="cv-stdremove_cvref-trait-p0550r2">型から cv 修飾と参照を除去する <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_cvref</span></code> trait <a href="https://wg21.link/P0550R2">(P0550R2)</a><a class="headerlink" href="#cv-stdremove_cvref-trait-p0550r2" title="Permanent link">&para;</a></h3>
<p>型から <code class="codehilite"><span class="n">const</span></code> や <code class="codehilite"><span class="k">volatile</span></code> の修飾および参照を除去したいだけで、配列からポインタ、関数型から関数ポインタへの変換については不要であっても、C++17 では <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span></code> と書くと長くなるため <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">decay</span></code> を使うというケースがよくありました。C++20 からは <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span></code> と同じ効果を持つ <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_cvref</span></code> trait と、そのヘルパー型 <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_cvref_t</span></code> が追加され、短く書けるようになります。<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span></code> のような順番の間違いを防ぐことにもつながります。</p>
<h3 id="stddecay-p0777r1">標準ライブラリでの不必要な <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">decay</span></code> の使用を回避 <a href="https://wg21.link/P0777R1">(P0777R1)</a><a class="headerlink" href="#stddecay-p0777r1" title="Permanent link">&para;</a></h3>
<p>C++17 の標準ライブラリの規格では <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">decay_t</span></code> がおよそ 40 箇所で使われていましたが、そのうち cv 修飾の除去や参照の除去だけで十分な箇所について、実装の意図をより明確にするため <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_reference_t</span></code> や、C++20 から導入される <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_cvref_t</span></code> に置き換えられます。具体的には、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">apply</span></code> や、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">optional</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">variant</span></code> の一部のメンバ関数などで置き換えが発生します。</p>
<h3 id="numbers-p0631r8">数学定数を提供する <code class="codehilite"><span class="o">&lt;</span><span class="n">numbers</span><span class="o">&gt;</span></code> ヘッダ <a href="https://wg21.link/P0631R8">(P0631R8)</a><a class="headerlink" href="#numbers-p0631r8" title="Permanent link">&para;</a></h3>
<p>これまで C++ の標準ライブラリには数学定数が用意されていませんでした（<code class="codehilite"><span class="n">M_PI</span></code> などは拡張）。C++20 からは数学定数をまとめた <code class="codehilite"><span class="o">&lt;</span><span class="n">numbers</span><span class="o">&gt;</span></code> ヘッダが追加され、13 種類の数学定数の変数テンプレート宣言と、それらの <code class="codehilite"><span class="n">double</span></code> 型への特殊化の定義が提供されます。<br />
変数テンプレートは、標準ライブラリコンセプト <code class="codehilite"><span class="n">floating_point</span></code> を使って、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">numbers</span></code> 名前空間に次のように宣言されます。
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">floating_point</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mf">3.141592653589793238462643383279502884</span><span class="n">L</span><span class="p">;</span>
</pre></div>
合わせて <code class="codehilite"><span class="n">double</span></code> 型への特殊化の定義が次のような実装で提供されます。
<div class="codehilite"><pre><span></span><span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
C++20 で追加される数学定数の一覧は次のとおりです。</p>
<table>
<thead>
<tr>
<th>定数名</th>
<th>説明</th>
<th>binary128 に充分な精度を持つ値</th>
</tr>
</thead>
<tbody>
<tr>
<td>e_v</td>
<td>e</td>
<td>2.718281828459045235360287471352662498L</td>
</tr>
<tr>
<td>log2e_v</td>
<td>2 を底とする e の対数</td>
<td>1.442695040888963407359924681001892137L</td>
</tr>
<tr>
<td>log10e_v</td>
<td>10 を底とする e の対数</td>
<td>0.434294481903251827651128918916605082L</td>
</tr>
<tr>
<td>pi_v</td>
<td>円周率 (π)</td>
<td>3.141592653589793238462643383279502884L</td>
</tr>
<tr>
<td>inv_pi_v</td>
<td>1/π</td>
<td>0.318309886183790671537767526745028724L</td>
</tr>
<tr>
<td>inv_sqrtpi_v</td>
<td>1/√π</td>
<td>0.564189583547756286948079451560772586L</td>
</tr>
<tr>
<td>ln2_v</td>
<td>2 の自然対数</td>
<td>0.693147180559945309417232121458176568L</td>
</tr>
<tr>
<td>ln10_v</td>
<td>10 の自然対数</td>
<td>2.302585092994045684017991454684364208L</td>
</tr>
<tr>
<td>sqrt2_v</td>
<td>√2</td>
<td>1.414213562373095048801688724209698078L</td>
</tr>
<tr>
<td>sqrt3_v</td>
<td>√3</td>
<td>1.732050807568877293527446341505872366L</td>
</tr>
<tr>
<td>inv_sqrt3_v</td>
<td>1/√3</td>
<td>0.577350269189625764509148780501957456L</td>
</tr>
<tr>
<td>egamma_v</td>
<td>オイラーの定数</td>
<td>0.577215664901532860606512090082402431L</td>
</tr>
<tr>
<td>phi_v</td>
<td>黄金数 (φ)</td>
<td>1.618033988749894848204586834365638117L</td>
</tr>
</tbody>
</table>
<p>コードで使用する際は、<code class="codehilite"><span class="k">using</span></code> 宣言によって記述を短くできます。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numbers&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">numbers</span><span class="o">::</span><span class="n">pi_v</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span>  <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pi_v</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h3 id="basic_stringreserve-capacity-p0966r1"><code class="codehilite"><span class="n">basic_string</span><span class="p">::</span><span class="n">reserve</span><span class="p">()</span></code> が capacity を縮小しないように <a href="https://wg21.link/P0966R1">(P0966R1)</a><a class="headerlink" href="#basic_stringreserve-capacity-p0966r1" title="Permanent link">&para;</a></h3>
<p>C++17 では、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string</span><span class="p">::</span><span class="n">reserve</span><span class="p">(</span><span class="n">size_type</span><span class="p">)</span></code> に現在の <code class="codehilite"><span class="n">capacity</span><span class="p">()</span></code> よりも小さい値が渡された際、shrink-to-fit を実行することが許可されていたため、注意深く使わないとメモリの再配置を頻繁に引き起こし、実行時性能を低下させることがありました。また、デフォルト引数として <code class="codehilite"><span class="mi">0</span></code> が定義されており、<code class="codehilite"><span class="n">s</span><span class="p">.</span><span class="n">reserve</span><span class="p">()</span></code> と <code class="codehilite"><span class="n">s</span><span class="p">.</span><span class="n">shrink_to_fit</span><span class="p">()</span></code> で機能が重複するという問題や、shrink-to-fit を実行せずデフォルト引数も無い <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">::</span><span class="n">reserve</span><span class="p">(</span><span class="n">size_type</span><span class="p">)</span></code> との一貫性がないという問題がありました。C++20 からの新しい仕様では <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> 側に合わせ、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string</span><span class="p">::</span><span class="n">reserve</span><span class="p">(</span><span class="n">size_type</span><span class="p">)</span></code> に現在の <code class="codehilite"><span class="n">capacity</span><span class="p">()</span></code> よりも小さい値が渡された際には何もしないことが保証され、デフォルト引数も廃止（互換性のために deprecated 指定の <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string</span><span class="p">:</span><span class="n">reserve</span><span class="p">(</span><span class="n">void</span><span class="p">)</span></code> オーバーロードが追加）となり、これらの問題が解決されます。</p>
<h3 id="constains-p0458r2">連想コンテナに <code class="codehilite"><span class="n">constains</span><span class="p">()</span></code> メンバ関数を追加 <a href="https://wg21.link/P0458R2">(P0458R2)</a><a class="headerlink" href="#constains-p0458r2" title="Permanent link">&para;</a></h3>
<p>ある要素が連想コンテナに含まれているか調べるための C++17 までのイディオムは、直感的でなく初心者にとっても明快ではありませんでした。C++20 からは、要素の存在をチェックする <code class="codehilite"><span class="k">contains</span><span class="p">(</span><span class="k">key</span><span class="p">)</span></code> メンバ関数が <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="k">map</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">multimap</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="k">set</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">multiset</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">unordered_map</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">unordered_multimap</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">unordered_set</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">unordered_multiset</span></code> に追加されます。</p>
<div class="superfences-tabs">
<input name="__tabs_4" type="radio" id="__tab_4_0" checked="checked" />
<label for="__tab_4_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="mi">200</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">201</span><span class="p">,</span> <span class="s">&quot;Created&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">202</span><span class="p">,</span> <span class="s">&quot;Accepted&quot;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">!=</span> <span class="n">table</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;key exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div>
<input name="__tabs_4" type="radio" id="__tab_4_1" />
<label for="__tab_4_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="mi">200</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">201</span><span class="p">,</span> <span class="s">&quot;Created&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">202</span><span class="p">,</span> <span class="s">&quot;Accepted&quot;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">200</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;key exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div>
</div>
<h3 id="stderase-stderase_if-p1209r0">コンテナから指定した要素を削除する操作に一貫して使える <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">erase</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">erase_if</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/p1209r0">(P1209R0)</a><a class="headerlink" href="#stderase-stderase_if-p1209r0" title="Permanent link">&para;</a></h3>
<p>コンテナから特定の要素を削除するという処理は、コンテナの種類によって最適な書き方が異なります。<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">unordered_map</span></code> ではイテレータを使って先頭から要素を削除していき、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">list</span></code> ではメンバ関数の <code class="codehilite"><span class="n">remove</span><span class="p">()</span></code> や <code class="codehilite"><span class="n">remove_if</span><span class="p">()</span></code> を使い、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> では <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">remove_if</span><span class="p">()</span></code> と <code class="codehilite"><span class="n">erase</span><span class="p">()</span></code> メンバ関数を組み合わせます。このようにコンテナの特性に応じてコードを書き分けるのは大変だったため、C++20 ではすべてのコンテナ向けに適切な実装を提供する、一貫して使える非メンバ関数 <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">erase</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">erase_if</span><span class="p">()</span></code> が追加されます。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">92</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">li</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">92</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;aa&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;bb&quot;</span><span class="p">,</span> <span class="mi">14</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;dd&quot;</span><span class="p">,</span> <span class="mi">5</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;ee&quot;</span><span class="p">,</span> <span class="mi">92</span> <span class="p">}</span> <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span> <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase_if</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../.." title="Home" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  前
                </span>
                Home
              </span>
            </div>
          </a>
        
        
          <a href="../cppx/" title="C++23 以降に向けた提案" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  次
                </span>
                C++23 以降に向けた提案
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            To the extent possible under law, Ryo Suzuki has waived all copyright and related or neighboring rights to C++ の歩き方 | CppMap. Third party copyrights are property of their respective owners.
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://twitter.com/Reputeless" class="md-footer-social__link fa fa-twitter"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.39abc4af.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
          
            
              
                <script src="../../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../../assets/javascripts/lunr/lunr.ja.js"></script>
              
            
          
          
            <script src="../../assets/javascripts/lunr/lunr.multi.js"></script>
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>