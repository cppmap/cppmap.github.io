



<!doctype html>
<html lang="ja" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="C++20 の新しい言語機能と標準ライブラリ機能の解説">
      
      
        <link rel="canonical" href="https://cppmap.github.io/standardization/cpp20/">
      
      
        <meta name="author" content="Ryo Suzuki">
      
      
        <meta name="lang:clipboard.copy" content="クリップボードへコピー">
      
        <meta name="lang:clipboard.copied" content="コピーしました">
      
        <meta name="lang:search.language" content="en, ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="何も見つかりませんでした">
      
        <meta name="lang:search.result.one" content="1件見つかりました">
      
        <meta name="lang:search.result.other" content="#件見つかりました">
      
        <meta name="lang:search.tokenizer" content="[\s　、。，．がのをにへとでやかもる「」『』]+">
      
      <link rel="shortcut icon" href="../../assets/images/logo.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.2.0">
    
    
      
        <title>C++20 の新機能 - C++ の歩き方 | CppMap</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.750b69bd.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="../../cppmap_styles.css">
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#c20" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://cppmap.github.io/" title="C++ の歩き方 | CppMap" class="md-header-nav__button md-logo">
          
            <i class="md-icon">donut_small</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              C++ の歩き方 | CppMap
            </span>
            <span class="md-header-nav__topic">
              C++20 の新機能
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="検索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            検索キーワードを入力してください
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/cppmap/cppmap.docs" title="リポジトリへ" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    cppmap/cppmap.docs
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." title="Home" class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="./" title="C++ 規格" class="md-tabs__link md-tabs__link--active">
          C++ 規格
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../articles/comment-tricks/" title="記事" class="md-tabs__link">
          記事
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../learn/books/" title="学習" class="md-tabs__link">
          学習
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../libraries/boost/" title="ライブラリ" class="md-tabs__link">
          ライブラリ
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../tools/onlinecompilers/" title="ツール" class="md-tabs__link">
          ツール
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../contribution/contributors/" title="貢献" class="md-tabs__link">
          貢献
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://cppmap.github.io/" title="C++ の歩き方 | CppMap" class="md-nav__button md-logo">
      
        <i class="md-icon">donut_small</i>
      
    </a>
    C++ の歩き方 | CppMap
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/cppmap/cppmap.docs" title="リポジトリへ" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    cppmap/cppmap.docs
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      C++ 規格
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        C++ 規格
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        C++20 の新機能
      </label>
    
    <a href="./" title="C++20 の新機能" class="md-nav__link md-nav__link--active">
      C++20 の新機能
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目次</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" title="言語機能" class="md-nav__link">
    言語機能
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0683r1" title="ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)" class="md-nav__link">
    ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0704r1" title="メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)" class="md-nav__link">
    メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p1236r1" title="符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)" class="md-nav__link">
    符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8-bit-2" title="（参考）符号付き 8-bit 整数の 2 進表現" class="md-nav__link">
    （参考）符号付き 8-bit 整数の 2 進表現
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-no_unique_address-p0840r2" title="メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)" class="md-nav__link">
    メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename-p0634r3" title="型名であることが明らかな文脈で typename を省略可能に (P0634R3)" class="md-nav__link">
    型名であることが明らかな文脈で typename を省略可能に (P0634R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1064r0" title="定数式での仮想関数呼び出しが可能に (P1064R0)" class="md-nav__link">
    定数式での仮想関数呼び出しが可能に (P1064R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_id-dynamic_cast-constexpr-p1327r1" title="type_id と dynamic_cast が constexpr に (P1327R1)" class="md-nav__link">
    type_id と dynamic_cast が constexpr に (P1327R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1330r0" title="定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)" class="md-nav__link">
    定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try-catch-p1002r1" title="定数式の文脈では try-catch を無視するように (P1002R1)" class="md-nav__link">
    定数式の文脈では try-catch を無視するように (P1002R1)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="標準ライブラリ" class="md-nav__link">
    標準ライブラリ
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0457r2" title="文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)" class="md-nav__link">
    文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operatorbasic_istream-chart-chartn-p0487r1" title="operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)" class="md-nav__link">
    operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p0600r1" title="戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)" class="md-nav__link">
    戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-constexpr-p1023r0-p1032r1" title="&lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)" class="md-nav__link">
    &lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chrono-zero-min-max-noexcept-p0972r0" title="&lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)" class="md-nav__link">
    &lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointer_traits-constexpr-p1006r1" title="pointer_traits が constexpr に (P1006R1)" class="md-nav__link">
    pointer_traits が constexpr に (P1006R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assume_aligned-p1007r3" title="ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)" class="md-nav__link">
    ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make-p1020r1" title="スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)" class="md-nav__link">
    スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_type-p0919r3" title="非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)" class="md-nav__link">
    非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0920r2" title="非順序連想コンテナのルックアップ操作に、計算済みハッシュ値を渡せるように (P0920R2)" class="md-nav__link">
    非順序連想コンテナのルックアップ操作に、計算済みハッシュ値を渡せるように (P0920R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdmidpoint-p0811r3" title="2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)" class="md-nav__link">
    2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdlerp-p0811r3" title="2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)" class="md-nav__link">
    2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-p0754r2" title="実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)" class="md-nav__link">
    実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_nothrow_convertible-p0758r1" title="例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)" class="md-nav__link">
    例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdto_address-p0653r2" title="ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)" class="md-nav__link">
    ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-constexpr-p0415r1" title="&lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)" class="md-nav__link">
    &lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_constant_evaluated-p0595r2" title="コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)" class="md-nav__link">
    コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0020r6" title="浮動小数点数型のアトミック操作を拡張 (P0020R6)" class="md-nav__link">
    浮動小数点数型のアトミック操作を拡張 (P0020R6)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmemory_order-enum-class-p0439r0" title="std::memory_order を enum class に変更 (P0439R0)" class="md-nav__link">
    std::memory_order を enum class に変更 (P0439R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-p0809r0" title="Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)" class="md-nav__link">
    Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0463r1" title="実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)" class="md-nav__link">
    実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../cppx/" title="C++23 以降に向けた提案" class="md-nav__link">
      C++23 以降に向けた提案
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../meetings/" title="標準化会議" class="md-nav__link">
      標準化会議
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../status/" title="処理系の対応状況" class="md-nav__link">
      処理系の対応状況
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../working-drafts/" title="C++ 規格" class="md-nav__link">
      C++ 規格
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      記事
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        記事
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/comment-tricks/" title="コメントアウトのトリック" class="md-nav__link">
      コメントアウトのトリック
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/it-compiles/" title="なぜかコンパイルできる" class="md-nav__link">
      なぜかコンパイルできる
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/it-does-not-compile/" title="なぜかコンパイルできない" class="md-nav__link">
      なぜかコンパイルできない
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/how-to-read-keywords/" title="予約語の読みと名前の由来" class="md-nav__link">
      予約語の読みと名前の由来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/how-to-read-libraries/" title="標準ライブラリの読みと名前の由来" class="md-nav__link">
      標準ライブラリの読みと名前の由来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../articles/ieee754-arithmetic/" title="IEEE 754 演算のルール" class="md-nav__link">
      IEEE 754 演算のルール
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      学習
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        学習
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/books/" title="書籍" class="md-nav__link">
      書籍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/online-resources/" title="オンライン資料" class="md-nav__link">
      オンライン資料
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/studymeetings/" title="国内の勉強会" class="md-nav__link">
      国内の勉強会
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../learn/communities/" title="コミュニティ" class="md-nav__link">
      コミュニティ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      ライブラリ
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        ライブラリ
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/boost/" title="Boost" class="md-nav__link">
      Boost
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/containers/" title="コンテナ" class="md-nav__link">
      コンテナ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/text-data/" title="テキストデータ" class="md-nav__link">
      テキストデータ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/multi-threading/" title="並行・並列" class="md-nav__link">
      並行・並列
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../libraries/testing/" title="テストフレームワーク" class="md-nav__link">
      テストフレームワーク
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      ツール
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        ツール
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/onlinecompilers/" title="オンラインコンパイラ" class="md-nav__link">
      オンラインコンパイラ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tools/package-manager/" title="パッケージマネージャ" class="md-nav__link">
      パッケージマネージャ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      貢献
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        貢献
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../contribution/contributors/" title="コントリビュータ" class="md-nav__link">
      コントリビュータ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目次</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" title="言語機能" class="md-nav__link">
    言語機能
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0683r1" title="ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)" class="md-nav__link">
    ビットフィールドにデフォルトの初期値を設定可能に (P0683R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0704r1" title="メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)" class="md-nav__link">
    メンバポインタ演算子の仕様を一貫性のために修正 (P0704R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-p1236r1" title="符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)" class="md-nav__link">
    符号付き整数型の負数表現を 2 の補数と規定 (P1236R1)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8-bit-2" title="（参考）符号付き 8-bit 整数の 2 進表現" class="md-nav__link">
    （参考）符号付き 8-bit 整数の 2 進表現
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0-no_unique_address-p0840r2" title="メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)" class="md-nav__link">
    メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる [[no_unique_address]] 属性を追加 (P0840R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename-p0634r3" title="型名であることが明らかな文脈で typename を省略可能に (P0634R3)" class="md-nav__link">
    型名であることが明らかな文脈で typename を省略可能に (P0634R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1064r0" title="定数式での仮想関数呼び出しが可能に (P1064R0)" class="md-nav__link">
    定数式での仮想関数呼び出しが可能に (P1064R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_id-dynamic_cast-constexpr-p1327r1" title="type_id と dynamic_cast が constexpr に (P1327R1)" class="md-nav__link">
    type_id と dynamic_cast が constexpr に (P1327R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p1330r0" title="定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)" class="md-nav__link">
    定数式において共用体のアクティブメンバの切り替えが可能に (P1330R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#try-catch-p1002r1" title="定数式の文脈では try-catch を無視するように (P1002R1)" class="md-nav__link">
    定数式の文脈では try-catch を無視するように (P1002R1)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="標準ライブラリ" class="md-nav__link">
    標準ライブラリ
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#p0457r2" title="文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)" class="md-nav__link">
    文字列の先頭や末尾が、ある文字列と一致するか判定 (P0457R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operatorbasic_istream-chart-chartn-p0487r1" title="operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)" class="md-nav__link">
    operator&gt;&gt;(basic_istream&amp;, charT*) の第二引数を charT(&amp;)[N] に変更して安全に (P0487R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodiscard-p0600r1" title="戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)" class="md-nav__link">
    戻り値の無視が不具合をもたらす関数に [[nodiscard]] を付与 (P0600R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array-constexpr-p1023r0-p1032r1" title="&lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)" class="md-nav__link">
    &lt;array&gt; ヘッダのすべての関数が constexpr に (P1023R0), (P1032R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chrono-zero-min-max-noexcept-p0972r0" title="&lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)" class="md-nav__link">
    &lt;chrono&gt; ヘッダの zero(), min(), max() 関数が noexcept に (P0972R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointer_traits-constexpr-p1006r1" title="pointer_traits が constexpr に (P1006R1)" class="md-nav__link">
    pointer_traits が constexpr に (P1006R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assume_aligned-p1007r3" title="ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)" class="md-nav__link">
    ポインタのアライメントを最適化ヒントとしてコンパイラに伝える assume_aligned() 関数 (P1007R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make-p1020r1" title="スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)" class="md-nav__link">
    スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 (P1020R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key_type-p0919r3" title="非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)" class="md-nav__link">
    非順序連想コンテナのルックアップ操作で、key_type と比較可能な型を変換せずに使えるように (P0919R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0920r2" title="非順序連想コンテナのルックアップ操作に、計算済みハッシュ値を渡せるように (P0920R2)" class="md-nav__link">
    非順序連想コンテナのルックアップ操作に、計算済みハッシュ値を渡せるように (P0920R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdmidpoint-p0811r3" title="2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)" class="md-nav__link">
    2 つの値の中点を計算する std::midpoint() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-stdlerp-p0811r3" title="2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)" class="md-nav__link">
    2 つの値の線形補間を計算する std::lerp() 関数 (P0811R3)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-p0754r2" title="実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)" class="md-nav__link">
    実装固有の情報をまとめる &lt;version&gt; ヘッダを追加 (P0754R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#is_nothrow_convertible-p0758r1" title="例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)" class="md-nav__link">
    例外を投げない暗黙の変換が可能か調べる is_nothrow_convertible (P0758R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdto_address-p0653r2" title="ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)" class="md-nav__link">
    ポインタライクなオブジェクトからアドレスを取得する std::to_address() 関数 (P0653R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-constexpr-p0415r1" title="&lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)" class="md-nav__link">
    &lt;complex&gt; ヘッダの関数の constexpr 対応を強化 (P0415R1)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_constant_evaluated-p0595r2" title="コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)" class="md-nav__link">
    コンパイル時評価の文脈か実行時評価の文脈かを判別できる std::is_constant_evaluated() 関数 (P0595R2)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0020r6" title="浮動小数点数型のアトミック操作を拡張 (P0020R6)" class="md-nav__link">
    浮動小数点数型のアトミック操作を拡張 (P0020R6)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmemory_order-enum-class-p0439r0" title="std::memory_order を enum class に変更 (P0439R0)" class="md-nav__link">
    std::memory_order を enum class に変更 (P0439R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-p0809r0" title="Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)" class="md-nav__link">
    Hash が同一の挙動をしない非順序連想コンテナどうしの比較が可能に (P0809R0)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#p0463r1" title="実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)" class="md-nav__link">
    実行環境のエンディアンを判別するための列挙定数を追加 (P0463R1)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="c20">C++20 の新機能</h1>
<p>現在、執筆作業中です（完成度 約 25%）。<br />
一覧は <a href="https://cppmap.github.io/standardization/status/">処理系の対応状況</a> から C++20 のページを参照してください。</p>
<h2 id="_1">言語機能</h2>
<h3 id="p0683r1">ビットフィールドにデフォルトの初期値を設定可能に <a href="http://wg21.link/p0683r1">(P0683R1)</a></h3>
<p><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">Terrain</span>
<span class="p">{</span>
    <span class="n">Open</span><span class="p">,</span> <span class="n">Forest</span><span class="p">,</span> <span class="n">Hill</span><span class="p">,</span> <span class="n">Mountain</span><span class="p">,</span> <span class="n">Desert</span><span class="p">,</span> <span class="n">Tundra</span><span class="p">,</span> <span class="n">River</span><span class="p">,</span> <span class="n">Ocean</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Tile</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">height</span> <span class="p">:</span> <span class="mi">4</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// デフォルト値を 1 に</span>
    <span class="n">Terrain</span> <span class="nl">terrain</span> <span class="p">:</span> <span class="mi">3</span> <span class="o">=</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Open</span><span class="p">;</span> <span class="c1">// デフォルト値を明示的に Terrain::Open に</span>
    <span class="kt">bool</span> <span class="nl">passable</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// デフォルト値を true に</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="n">Tile</span> <span class="n">tile1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tile1</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile1</span><span class="p">.</span><span class="n">terrain</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tile1</span><span class="p">.</span><span class="n">passable</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">Tile</span> <span class="n">tile2</span><span class="p">{</span> <span class="mi">15</span><span class="p">,</span> <span class="n">Terrain</span><span class="o">::</span><span class="n">Mountain</span><span class="p">,</span> <span class="nb">false</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tile2</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile2</span><span class="p">.</span><span class="n">terrain</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tile2</span><span class="p">.</span><span class="n">passable</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">true</span>
<span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="k">false</span>
</pre></div></p>
<h3 id="p0704r1">メンバポインタ演算子の仕様を一貫性のために修正 <a href="http://wg21.link/p0704r1">(P0704R1)</a></h3>
<p>C++17 までのメンバポインタ演算子 <code class="codehilite"><span class="p">.</span><span class="o">*</span></code> は「右辺値オブジェクトから、左辺値参照修飾されたメンバ関数ポインタに使うことは不適格」という規格文面になっていました。そのため、同じ意味をもつ次の 2 つのプログラムで後者だけ不適格とされ、一貫性がありませんでした。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Text</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_data</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Text</span><span class="p">{</span> <span class="s">&quot;Hello&quot;</span> <span class="p">}.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">Text</span><span class="p">{</span> <span class="s">&quot;Hello&quot;</span> <span class="p">}.</span><span class="o">*&amp;</span><span class="n">Text</span><span class="o">::</span><span class="n">get</span><span class="p">)()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// C++17 までは不適格、C++20 から OK</span>
<span class="p">}</span>
</pre></div>
C++20 では「右辺値オブジェクトから、左辺値参照修飾された "非 const" メンバ関数ポインタに使うことは不適格」と文面を修正し、後者もコンパイルできるようになります。</p>
<h3 id="2-p1236r1">符号付き整数型の負数表現を 2 の補数と規定 <a href="http://wg21.link/p1236r1">(P1236R1)</a></h3>
<p>ほぼすべての現代的なコンピュータで、符号付き整数型の負数は 2 の補数で表現されます。しかし、C++ では負数の表現方法について規格で定めていなかったため、（現実的ではありませんが）2 の補数以外で負数表現を実装する余地も残されていました。C++20 からは 2 の補数のみを許可するよう規格文言が修正されました。<br />
近年のアーキテクチャで 2 の補数以外を使う例は、1 の補数を使う Unisys 2200 があります。また過去には符号と絶対値で表現するアーキテクチャもありました。これらはモダンな C++ を開発環境として使用しないので、この規格変更による影響は無いと考えられます。</p>
<h4 id="8-bit-2">（参考）符号付き 8-bit 整数の 2 進表現</h4>
<table>
<thead>
<tr>
<th>10 進表現</th>
<th>2 の補数</th>
<th>1 の補数</th>
<th>符号と絶対値</th>
</tr>
</thead>
<tbody>
<tr>
<td>127</td>
<td>01111111</td>
<td>01111111</td>
<td>01111111</td>
</tr>
<tr>
<td>126</td>
<td>01111110</td>
<td>01111110</td>
<td>01111110</td>
</tr>
<tr>
<td>125</td>
<td>01111101</td>
<td>01111101</td>
<td>01111101</td>
</tr>
<tr>
<td>2</td>
<td>00000010</td>
<td>00000010</td>
<td>00000010</td>
</tr>
<tr>
<td>1</td>
<td>00000001</td>
<td>00000001</td>
<td>00000001</td>
</tr>
<tr>
<td>0</td>
<td>00000000</td>
<td>00000000</td>
<td>00000000</td>
</tr>
<tr>
<td>-0</td>
<td></td>
<td>11111111</td>
<td>10000000</td>
</tr>
<tr>
<td>-1</td>
<td>11111111</td>
<td>11111110</td>
<td>10000001</td>
</tr>
<tr>
<td>-2</td>
<td>11111110</td>
<td>11111101</td>
<td>10000010</td>
</tr>
<tr>
<td>-126</td>
<td>10000010</td>
<td>10000001</td>
<td>11111110</td>
</tr>
<tr>
<td>-127</td>
<td>10000001</td>
<td>10000000</td>
<td>11111111</td>
</tr>
<tr>
<td>-128</td>
<td>10000000</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="0-no_unique_address-p0840r2">メンバのオブジェクトが空のクラスの場合にメモリ消費を 0 にできる <code class="codehilite"><span class="o">[</span><span class="n">[no_unique_address</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を追加 <a href="http://wg21.link/p0840r2">(P0840R2)</a></h3>
<p>アロケータなどをクラスのメンバとして保持するとき、それがステートレスな空のクラスであってもオブジェクトのアドレスを一意に用意しないといけないため、サイズを 0 にできずメモリ消費が無駄に増えてしまう問題がありました。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4 より大きい</span>
<span class="p">}</span>
</pre></div>
これを回避するために「空の基底クラスは最適化によってサイズ 0 にしてよい」という仕様を利用した Empty Base Optimization (EBO) というテクニックがあり、標準ライブラリでも　<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span></code> や <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> などに使われています。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">X</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Empty</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</pre></div>
しかし、これらのクラスで継承による EBO を実装するとコードが複雑になるという欠点がありました。C++20 ではメンバの宣言に <code class="codehilite"><span class="o">[</span><span class="n">[no_unique_address</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を付けることで、継承を使わなくてもコンパイラが EBO と同じような最適化をできるようになり、従来の継承による EBO を使っていたコードを、より単純なコードに置き換えられます。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Empty</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">no_unique_address</span><span class="p">]]</span> <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="typename-p0634r3">型名であることが明らかな文脈で <code class="codehilite"><span class="n">typename</span></code> を省略可能に <a href="https://wg21.link/P0634R3">(P0634R3)</a></h3>
<p>C++17 で依存名が型である場合に <code class="codehilite"><span class="n">typename</span></code> を付けないのは、派生クラス定義時の基底クラスの指定と、初期化子リストでの基底クラスの指定のみでした（厳密にはこの 2 つには <code class="codehilite"><span class="n">typename</span></code> を付けられません）。C++20 では、型名しか使えないさらにいくつかの文脈で <code class="codehilite"><span class="n">typename</span></code> が省略可能になります。次のサンプルコードの左右タブで比較できます。</p>
<div class="superfences-tabs">
<input name="__tabs_1" type="radio" id="__tab_1_0" checked="checked" />
<label for="__tab_1_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">S</span> <span class="p">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="c1">// 派生クラス定義時の基底クラスの指定</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>

    <span class="n">S</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 初期化子リストでの基底クラスの指定</span>

    <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">pointer</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">min_size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">MaxSize</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>
<input name="__tabs_1" type="radio" id="__tab_1_1" />
<label for="__tab_1_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;</span> <span class="c1">// OK</span>
<span class="k">struct</span> <span class="nl">S</span> <span class="p">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="c1">// 派生クラス定義時の基底クラスの指定</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="n">S</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 初期化子リストでの基底クラスの指定</span>

    <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">T</span><span class="o">::</span><span class="n">pointer</span><span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">auto</span> <span class="nf">min_size</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// OK</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">MaxSize</span><span class="p">();</span> <span class="c1">// OK</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>
</div>
<h3 id="p1064r0">定数式での仮想関数呼び出しが可能に <a href="https://wg21.link/P1064">(P1064R0)</a></h3>
<p>コンパイル時に決定可能であれば、参照やポインタを通した仮想関数の呼び出しを <code class="codehilite"><span class="n">constexpr</span></code> にできるようになります。<code class="codehilite"><span class="n">constexpr</span></code> 修飾された仮想関数を非 <code class="codehilite"><span class="n">constexpr</span></code> 関数でオーバーライドすることや、その逆も可能です。</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">GetVersion</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">version</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">Cpp20</span> <span class="n">cpp20</span><span class="p">;</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetVersion</span><span class="p">(</span><span class="n">cpp17</span><span class="p">)</span> <span class="o">==</span> <span class="mi">17</span><span class="p">);</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetVersion</span><span class="p">(</span><span class="n">cpp20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h3 id="type_id-dynamic_cast-constexpr-p1327r1"><code class="codehilite"><span class="n">type_id</span></code> と <code class="codehilite"><span class="n">dynamic_cast</span></code> が constexpr に <a href="https://wg21.link/P1327">(P1327R1)</a></h3>
<p><code class="codehilite"><span class="n">dynamic_cast</span></code> と <code class="codehilite"><span class="n">type_id</span></code> が、例外を投げるケースを除いて <code class="codehilite"><span class="n">constexpr</span></code> になります。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">*</span> <span class="n">pCpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cpptype</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">pCpp</span><span class="p">);</span>

    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">refCpp</span> <span class="o">=</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp17</span><span class="o">&amp;</span> <span class="n">redCpp2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpp17</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">refCpp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>次のように例外を投げるケースでは <code class="codehilite"><span class="n">constexpr</span></code> にできずコンパイルエラーになります。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp17</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Cpp20</span> <span class="p">:</span> <span class="n">Cpp</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Cpp</span><span class="o">*</span> <span class="n">pCpp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cpptype</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">pCpp</span><span class="p">);</span> <span class="c1">//コンパイルエラー: 例外 std::bad_typeid を投げるため constexpr 不可</span>

    <span class="k">constexpr</span> <span class="k">static</span> <span class="n">Cpp17</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp</span><span class="o">&amp;</span> <span class="n">refCpp</span> <span class="o">=</span> <span class="n">cpp17</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">const</span> <span class="n">Cpp20</span><span class="o">&amp;</span> <span class="n">redCpp2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpp20</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">refCpp</span><span class="p">);</span> <span class="c1">// コンパイルエラー: 例外 std::bad_cast を投げるため constexpr 不可</span>
<span class="p">}</span>
</pre></div>

<h3 id="p1330r0">定数式において共用体のアクティブメンバの切り替えが可能に <a href="https://wg21.link/P1330">(P1330R0)</a></h3>
<p>共用体のアクティブメンバとは、最後に初期化または値を代入したメンバのことです。C++17 では共用体の初期化やアクティブメンバへのアクセスを定数式で行えましたが、アクティブメンバの切り替えはできませんでした。定数式でのアクティブメンバの切り替えが可能になると、共用体によって実装される <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">string</span></code> や <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">optional</span></code> などの標準ライブラリクラスのメンバ関数の <code class="codehilite"><span class="n">constexpr</span></code> 対応を拡充できます。非アクティブメンバへのアクセスは未定義動作なので、定数式で行うとコンパイルエラーになります。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>

<span class="k">union</span> <span class="n">Value</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">Value</span> <span class="nf">GetFloat</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Value</span><span class="p">{</span> <span class="n">x</span> <span class="p">};</span> <span class="c1">// value.f がアクティブメンバ</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">Value</span> <span class="nf">GetUint</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Value</span> <span class="n">value</span> <span class="o">=</span> <span class="n">GetFloat</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span> <span class="c1">// value.f がアクティブメンバ</span>
    <span class="n">value</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// value.i がアクティブメンバに</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">GetUint</span><span class="p">(</span><span class="mi">123</span><span class="p">).</span><span class="n">i</span> <span class="o">==</span> <span class="mi">123</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h3 id="try-catch-p1002r1">定数式の文脈では <code class="codehilite"><span class="n">try</span><span class="o">-</span><span class="n">catch</span></code> を無視するように <a href="https://wg21.link/P1002">(P1002R1)</a></h3>
<p>これまで <code class="codehilite"><span class="n">constexpr</span></code> 関数の中には <code class="codehilite"><span class="n">try</span><span class="o">-</span><span class="n">catch</span></code> ブロックを書くことができませんでした。しかし、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> 等のコンテナを <code class="codehilite"><span class="n">constexpr</span></code> 対応するにあたっては、この制限が障壁となるため、C++20 では <code class="codehilite"><span class="n">constexpr</span></code> 関数の中の <code class="codehilite"><span class="n">try</span><span class="o">-</span><span class="n">catch</span></code> は、定数式として評価されるときには無視するよう仕様が改められます。定数式の評価中に例外を投げるようであればコンパイルエラーになります。<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> などを <code class="codehilite"><span class="n">constexpr</span></code> 対応させるための措置であり、将来の C++ におけるコンパイル時例外処理の実現を否定するものではありません。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt; </span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt; </span><span class="cp"></span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">AddU8</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">{};</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">DoubleU8</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">AddU8</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">except</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">DoubleU8</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span> <span class="o">==</span> <span class="mi">246</span><span class="p">);</span> <span class="c1">// OK: 例外を投げずに定数式として評価可能</span>

    <span class="c1">//static_assert(DoubleU8(200) &gt; 0); // コンパイルエラー: 定数式として評価される constexpr 関数内で例外を投げるため</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;result: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">DoubleU8</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// OK: 実行時に評価される関数で例外が発生する</span>
<span class="p">}</span>
</pre></div>

<h2 id="_2">標準ライブラリ</h2>
<h3 id="p0457r2">文字列の先頭や末尾が、ある文字列と一致するか判定 <a href="https://wg21.link/P0457R2">(P0457R2)</a></h3>
<p><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string</span></code> と <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string_view</span></code> に、<code class="codehilite"><span class="n">starts_with</span><span class="p">()</span></code> と <code class="codehilite"><span class="n">ends_with</span><span class="p">()</span></code> メンバ関数が追加されます。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">HasPNGExtension</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">filePath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 文字列が &quot;.png&quot; で終わるなら true, それ以外は false を返す</span>
    <span class="k">return</span> <span class="n">filePath</span><span class="p">.</span><span class="n">ends_with</span><span class="p">(</span><span class="s">&quot;.png&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;picture.png&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;photo.jpg&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">HasPNGExtension</span><span class="p">(</span><span class="s">&quot;music.mp3&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="k">true</span>
<span class="k">false</span>
<span class="k">false</span>
</pre></div></p>
<h3 id="operatorbasic_istream-chart-chartn-p0487r1"><code class="codehilite"><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">charT</span><span class="o">*</span><span class="p">)</span></code> の第二引数を <code class="codehilite"><span class="n">charT</span><span class="p">(</span><span class="o">&amp;</span><span class="p">)</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="w"></span></code> に変更して安全に <a href="https://wg21.link/P0487R1">(P0487R1)</a></h3>
<p>C++17 までの <code class="codehilite"><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">charT</span><span class="o">*</span><span class="p">)</span></code> は、関数にバッファのサイズが渡されないため、次のようなプログラムでバッファオーバーフローへの対策が必要でした。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="c1">// std::cin &gt;&gt; buffer; // 危険: バッファオーバーフローの可能性</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// OK: バッファオーバーフロー対策</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
C++20 では引数を次のように変更し、関数がバッファオーバーフローの対策を実装するようになります。
<div class="codehilite"><pre><span></span><span class="c1">// C++17 まで</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span><span class="o">&gt;</span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">charT</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>

<span class="c1">// C++20 から</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">charT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">traits</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">basic_istream</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">charT</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)[</span><span class="n">N</span><span class="p">]);</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// OK: C++20 ではバッファオーバーフローを防げる</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
この変更に伴い、C++17 までは有効だった次のようなプログラムが、C++20 からコンパイルエラーになります。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// C++20 からはコンパイルエラー</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="nodiscard-p0600r1">戻り値の無視が不具合をもたらす関数に <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> を付与 <a href="https://wg21.link/P0600R1">(P0600R1)</a></h3>
<p>C++17 で導入された <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を標準ライブラリで活用するようになります。C++20 では付与基準を「戻り値の無視がトラブルやメモリリークなどの重大なエラーを引き起こす C++ の関数」とし、<code class="codehilite"><span class="n">async</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">launder</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">allocate</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">empty</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">operator</span> <span class="k">new</span><span class="p">()</span></code> が対象となっています。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>

    <span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// C++20 では警告</span>

    <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// C++20 では警告</span>
<span class="p">}</span>
</pre></div>
MSVC の標準ライブラリでは Visual Studio 2017 15.6 以降、規格の範囲を超えてより多くの関数（<a href="https://devblogs.microsoft.com/cppblog/c17-progress-in-vs-2017-15-5-and-15-6/">2,500 個以上</a>）に <code class="codehilite"><span class="o">[</span><span class="n">[nodiscard</span><span class="o">]</span><span class="err">]</span><span class="w"></span></code> 属性を使っています。その結果、<a href="https://bugs.chromium.org/p/webrtc/issues/detail?id=8463">Chromium のソースに無意味な std::move() が見つかる</a>など、既存のコードベースのバグの発見に役立っています。</p>
<h3 id="array-constexpr-p1023r0-p1032r1"><code class="codehilite"><span class="o">&lt;</span><span class="nb">array</span><span class="o">&gt;</span></code> ヘッダのすべての関数が constexpr に <a href="https://wg21.link/P1023R0">(P1023R0)</a>, <a href="https://wg21.link/P1032R1">(P1032R1)</a></h3>
<p>C++17 の <code class="codehilite"><span class="o">&lt;</span><span class="nb">array</span><span class="o">&gt;</span></code> ヘッダでは、比較演算子、<code class="codehilite"><span class="n">swap</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">fill</span><span class="p">()</span></code> 以外のすべての関数が constexpr でした。C++20 ではさらに、array の比較演算の実装に使われている <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">equal</span><span class="p">()</span></code> と <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">lexicographical_compare</span><span class="p">()</span></code> が <a href="https://wg21.link/P0202R3">constexpr になった (P0202R3)</a> ことにともない、array の比較演算子を constexpr とし、また <code class="codehilite"><span class="n">swap</span><span class="p">()</span></code> と <code class="codehilite"><span class="n">fill</span><span class="p">()</span></code> についても constexpr にすることを決め、array ヘッダのすべての関数が constexpr で提供されます。</p>
<h3 id="chrono-zero-min-max-noexcept-p0972r0"><code class="codehilite"><span class="o">&lt;</span><span class="n">chrono</span><span class="o">&gt;</span></code> ヘッダの <code class="codehilite"><span class="n">zero</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">min</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">max</span><span class="p">()</span></code> 関数が noexcept に <a href="https://wg21.link/P0972R0">(P0972R0)</a></h3>
<p><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">chrono</span><span class="p">::</span><span class="n">duration_values</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">chrono</span><span class="p">::</span><span class="n">duration</span></code>, <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">chrono</span><span class="p">::</span><span class="n">time_point</span></code> などの <code class="codehilite"><span class="n">zero</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">min</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">max</span><span class="p">()</span></code> 関数に noexcept が付きます。</p>
<h3 id="pointer_traits-constexpr-p1006r1"><code class="codehilite"><span class="n">pointer_traits</span></code> が constexpr に <a href="https://wg21.link/P1006R1">(P1006R1)</a></h3>
<p><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">vector</span></code> を constexpr にするのに必要なため、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">pointer_traits</span><span class="p">::</span><span class="n">pointer_to</span><span class="p">()</span></code> 関数が constrexpr になります。</p>
<h3 id="assume_aligned-p1007r3">ポインタのアライメントを最適化ヒントとしてコンパイラに伝える <code class="codehilite"><span class="n">assume_aligned</span><span class="p">()</span></code> 関数 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1007r3.pdf">(P1007R3)</a></h3>
<p>データのアドレスが 16 バイトなどのサイズにアライメントされている場合、コンパイラが SIMD を使った最適なコードを生成できる可能性があります。あるポインタの指すデータがアライメントされていることをコンパイラに伝える方法として、GCC や Clang では <code class="codehilite"><span class="n">__builtin_assume_aligned</span><span class="p">()</span></code> や <code class="codehilite"><span class="n">__attribute__</span><span class="p">((</span><span class="n">assume_aligned</span><span class="p">(</span><span class="n">alignment</span><span class="p">)))</span></code>, ICC では <code class="codehilite"><span class="n">__assume_aligned</span><span class="p">()</span></code> などの独自拡張がありますが、標準化された方法はありませんでした。C++20 では、これらの差異を吸収する次のような関数テンプレートが提供されます。
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span><span class="o">*</span> <span class="n">assume_aligned</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</pre></div>
実際には次のように使います。
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">Multiply</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">factor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">assume_aligned</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x が 64 バイトアライメントであることを伝える</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// ループが適宜最適化される</span>
    <span class="p">{</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="make-p1020r1">スマートポインタの作成時に値をデフォルト初期化する make 関数を追加 <a href="https://wg21.link/P1020R1">(P1020R1)</a></h3>
<p>実行時性能のために、<code class="codehilite"><span class="nb">float</span></code> や <code class="codehilite"><span class="n">unsigned</span> <span class="nb">char</span></code> など組み込み型の配列の値をデフォルト初期化させたい（ゼロ初期化しない）ケースがあります。しかし、<code class="codehilite"><span class="n">make_unique</span></code> や <code class="codehilite"><span class="n">make_shared</span></code>, <code class="codehilite"><span class="n">allocate_shared</span></code> でスマートポインタを作成した場合には値初期化が実行されます。C++20 では、値初期化をせずにデフォルト初期化でスマートポインタを作成する関数 <code class="codehilite"><span class="n">make_unique_default_init</span></code>, <code class="codehilite"><span class="n">make_shared_default_init</span></code>, <code class="codehilite"><span class="n">allocate_shared_default_init</span></code> が追加されました。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="c1">// 未初期化の変数を使う実験的なコード</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// デフォルト初期化</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">pv</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 値初期化 (0 初期化) </span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique_default_init</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// デフォルト初期化</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
出力例
<div class="codehilite"><pre><span></span><span class="mi">2</span><span class="p">.</span><span class="mi">20325</span><span class="n">e</span><span class="o">-</span><span class="mi">38</span>
<span class="mi">4</span><span class="p">.</span><span class="mi">11052</span><span class="n">e</span><span class="o">+</span><span class="mi">32</span>
<span class="mi">1</span><span class="p">.</span><span class="mi">3013</span><span class="n">e</span><span class="o">-</span><span class="mi">45</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">48626</span><span class="n">e</span><span class="o">-</span><span class="mi">38</span>
<span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">0</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">30415</span><span class="n">e</span><span class="o">-</span><span class="mi">38</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">51341</span><span class="n">e</span><span class="o">-</span><span class="mi">38</span>
<span class="mi">4</span><span class="p">.</span><span class="mi">63281</span><span class="n">e</span><span class="o">+</span><span class="mi">30</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">32703</span><span class="n">e</span><span class="o">+</span><span class="mi">17</span>
</pre></div></p>
<h3 id="key_type-p0919r3">非順序連想コンテナのルックアップ操作で、<code class="codehilite"><span class="k">key_type</span></code> と比較可能な型を変換せずに使えるように <a href="http://wg21.link/P0919r3">(P0919R3)</a></h3>
<p>C++17 までの <code class="codehilite"><span class="n">unorderd_map</span></code> や <code class="codehilite"><span class="n">unordered_set</span></code> など非順序連想コンテナでは、<code class="codehilite"><span class="n">find</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">count</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">equal_range</span><span class="p">()</span></code> などルックアップを行うメンバ関数は引数に <code class="codehilite"><span class="k">key_type</span></code> をとり、例えば次のようなケースで <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">string</span></code> 型の一時オブジェクトが作成されて非効率でした。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトが作成される</span>
<span class="p">}</span>
</pre></div>

<p>C++20 では、非順序連想コンテナのテンプレートパラメータ <code class="codehilite"><span class="n">Hash</span></code> が <code class="codehilite"><span class="n">transparent_key_equal</span></code> タグを持つときに、<code class="codehilite"><span class="k">key_type</span></code> 以外の型を引数にとるメンバ関数テンプレートのオーバーロードが使用可能になり、一時オブジェクトの作成を回避できるようになります。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">string_hash</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">transparent_key_equal</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;&gt;</span><span class="p">;</span>  <span class="c1">// KeyEqual to use</span>
    <span class="k">using</span> <span class="n">hash_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// helper local type</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">txt</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hash_type</span><span class="p">{}(</span><span class="n">txt</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">string_hash</span><span class="o">&gt;</span> <span class="n">table</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトは作成されない</span>

    <span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="n">sv</span><span class="p">);</span> <span class="c1">// std::string 型の一時オブジェクトは作成されない</span>
<span class="p">}</span>
</pre></div>

<h3 id="p0920r2">非順序連想コンテナのルックアップ操作に、計算済みハッシュ値を渡せるように <a href="https://wg21.link/P0920R2">(P0920R2)</a></h3>
<p>同じ種類の非順序連想コンテナを複数扱い、同じキーを用いたルックアップ操作をそれらのコンテナに対して行うようなケースでは、キーのハッシュ値の計算を毎回行うのは冗長です。C++20 ではメンバ関数 <code class="codehilite"><span class="n">find</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">count</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">contains</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">equal_range</span><span class="p">()</span></code> に、計算済みのハッシュ値を渡せるオーバーロードが追加されます。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">maps</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;key&quot;</span><span class="p">;</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">maps</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">key</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">map</span> <span class="p">:</span> <span class="n">maps</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="2-stdmidpoint-p0811r3">2 つの値の中点を計算する <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">midpoint</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/P0811R3">(P0811R3)</a></h3>
<p>2 つの値 <code class="codehilite"><span class="n">a</span></code>, <code class="codehilite"><span class="n">b</span></code> の中点を計算する際に、単純な <code class="codehilite"><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span></code> という式ではオーバーフローを起こす可能性があります。C++20 で追加される <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">midpoint</span><span class="p">()</span></code> 関数では、整数に対して
<div class="codehilite"><pre><span></span><span class="k">constexpr</span> <span class="n">Integer</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">Integer</span> <span class="n">a</span><span class="p">,</span> <span class="n">Integer</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">U</span> <span class="o">=</span> <span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span> <span class="o">?</span> <span class="n">a</span><span class="o">-</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">:</span> <span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
のような実装が使われ、オーバーフローを回避できます。<code class="codehilite"><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span></code> が奇数になるケースの結果は <code class="codehilite"><span class="n">a</span></code> の方向に丸められます。<br />
浮動小数点数に対しては次のような実装が使われます。
<div class="codehilite"><pre><span></span><span class="n">Float</span> <span class="nf">midpoint</span><span class="p">(</span><span class="n">Float</span> <span class="n">a</span><span class="p">,</span> <span class="n">Float</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">isnormal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isnormal</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span> <span class="o">+</span> <span class="mi">1</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// オーバーフロー</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">2</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">,</span> <span class="mi">1</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="err">&#39;</span><span class="mo">000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 1500000000</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 2</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">midpoint</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 3</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="2-stdlerp-p0811r3">2 つの値の線形補間を計算する <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">lerp</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/P0811R3">(P0811R3)</a></h3>
<p>2 点 <code class="codehilite"><span class="n">a</span></code>, <code class="codehilite"><span class="n">b</span></code> の間をパラメータ <code class="codehilite"><span class="n">t</span></code> によって線形補間する関数が提供されます。計算結果 <code class="codehilite"><span class="n">r</span></code> は <code class="codehilite"><span class="n">a</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span></code> によって求められますが、実装により <code class="codehilite"><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfinite</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></code> のとき</p>
<ul>
<li><code class="codehilite"><span class="n">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span></code></li>
<li><code class="codehilite"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">1</span></code> のとき <code class="codehilite"><span class="n">isfinite</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></code></li>
<li><code class="codehilite"><span class="n">isfinite</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span></code> のとき <code class="codehilite"><span class="n">r</span> <span class="o">==</span> <span class="n">a</span></code></li>
<li><code class="codehilite"><span class="n">isfinite</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">isnan</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span></code> のとき <code class="codehilite"><span class="sx">!isnan(r)</span></code></li>
</ul>
<p>また、<code class="codehilite"><span class="n">cmp</span><span class="p">(</span><span class="n">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">t2</span><span class="p">),</span> <span class="n">lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">t1</span><span class="p">))</span> <span class="o">*</span> <span class="n">cmp</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">t1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cmp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span></code> (cmp は -1, 0, 1 を返す三方比較関数とする)<br />
であることが保証されます。
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 0</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 3</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 10</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">lerp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 12</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="version-p0754r2">実装固有の情報をまとめる <code class="codehilite"><span class="o">&lt;</span><span class="k">version</span><span class="o">&gt;</span></code> ヘッダを追加 <a href="https://wg21.link/P0754R2">(P0754R2)</a></h3>
<p><code class="codehilite"><span class="n">__cpp_lib_byte</span></code>, <code class="codehilite"><span class="n">__cpp_lib_void_t</span></code> のような標準ライブラリの機能テストマクロ、その他ライブラリのバージョンや実装固有の情報をまとめる目的の <code class="codehilite"><span class="o">&lt;</span><span class="k">version</span><span class="o">&gt;</span></code> ヘッダが追加されました。
例えば C++20 以前の MSVC の標準ライブラリでは、<code class="codehilite"><span class="o">&lt;</span><span class="n">yvals_core</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span></code> という独自ヘッダに標準ライブラリの機能テストマクロがまとめられていましたが、C++20 以降ではあらゆる実装において、<code class="codehilite"><span class="o">&lt;</span><span class="k">version</span><span class="o">&gt;</span></code> ヘッダを見ることで、こうした実装固有の情報にアクセスできるため利便性が高まります。</p>
<h3 id="is_nothrow_convertible-p0758r1">例外を投げない暗黙の変換が可能か調べる <code class="codehilite"><span class="n">is_nothrow_convertible</span></code> <a href="https://wg21.link/P0758R1">(P0758R1)</a></h3>
<p>型 <code class="codehilite"><span class="k">From</span></code> から型 <code class="codehilite"><span class="k">To</span></code> への暗黙の変換が可能であるかを調べる型特性クラス <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="k">class</span> <span class="k">From</span><span class="p">,</span> <span class="k">class</span> <span class="k">To</span><span class="o">&gt;</span></code> が C++11 から導入されましたが、その変換が <code class="codehilite"><span class="n">noexcept</span></code> でもあるかを調べられるバージョンは実装されていませんでした。
このことが原因で、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">decay_copy</span></code> の提案 (<a href="http://wg21.link/n3255">N3255</a>) において、適切な <code class="codehilite"><span class="n">noexcept</span></code> 例外仕様を移植性のある方法で定義できない問題 (<a href="http://wg21.link/lwg2040">LWG 2040</a>) が指摘されていました。
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> 
<span class="k">typename</span> <span class="n">decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">decay_copy</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="o">???</span> <span class="cm">/* is_nothrow_convertible&lt;T, T&gt;::value */</span><span class="p">);</span>
</pre></div>
C++20 からは、<code class="codehilite"><span class="n">noexcept</span></code> な暗黙の変換が可能であることを調べる新しい型特性クラス <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_nothrow_convertible</span><span class="o">&lt;</span><span class="k">class</span> <span class="k">From</span><span class="p">,</span> <span class="k">class</span> <span class="k">To</span><span class="o">&gt;</span></code> が実装されることで問題を解消できます。
既存の標準ライブラリ関数においても、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">basic_string</span></code> のメンバ関数テンプレートに、より適切な <code class="codehilite"><span class="n">noexcept</span></code> 例外仕様を定義するために活用されます。</p>
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">size_type</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">is_nothrow_convertible_v</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">basic_string_view</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span> <span class="n">Traits</span><span class="o">&gt;&gt;</span><span class="p">);</span>
</pre></div>

<h3 id="stdto_address-p0653r2">ポインタライクなオブジェクトからアドレスを取得する <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">to_address</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/P0653R2">(P0653R2)</a></h3>
<p>ポインタライクなオブジェクトを引数にとり、それが表すのと同じアドレスを生ポインタで返す関数 <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">to_address</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></code> が追加されます。オブジェクトがポインタ型の場合はその値を返し、それ以外の場合、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">pointer_traits</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&gt;</span><span class="p">::</span><span class="n">to_address</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></code> の特殊化が定義されていて使えればその戻り値を、そうでない場合は <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">to_address</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">())</span></code> の戻り値を返します。</p>
<h3 id="complex-constexpr-p0415r1"><code class="codehilite"><span class="o">&lt;</span><span class="n">complex</span><span class="o">&gt;</span></code> ヘッダの関数の <code class="codehilite"><span class="n">constexpr</span></code> 対応を強化 <a href="https://wg21.link/P0415R1">(P0415R1)</a></h3>
<p><code class="codehilite"><span class="o">&lt;</span><span class="n">complex</span><span class="o">&gt;</span></code> ヘッダが提供する関数のうち、複素数の四則演算、ノルムの取得、共役複素数の取得など、<code class="codehilite"><span class="n">constexpr</span></code> 非対応の数学関数 (sqrt など) を使わずに実装できるものが <code class="codehilite"><span class="n">constexpr</span></code> 化されます。</p>
<h3 id="stdis_constant_evaluated-p0595r2">コンパイル時評価の文脈か実行時評価の文脈かを判別できる <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_constant_evaluated</span><span class="p">()</span></code> 関数 <a href="https://wg21.link/P0595">(P0595R2)</a></h3>
<p>C++17 までは、実行するコードを、コンパイル時評価か実行時評価かに応じて使い分ける方法はありませんでした。C++20 では、コンパイル時評価されている文脈では <code class="codehilite"><span class="k">true</span></code> を、それ以外の場合では <code class="codehilite"><span class="k">false</span></code> を返す <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_constant_evaluated</span><span class="p">()</span></code> 関数が <code class="codehilite"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">&gt;</span></code> ヘッダに追加されます。例えば標準ライブラリで <code class="codehilite"><span class="n">constexpr</span></code> 対応していないような数学関数を提供する際、コンパイル時評価では <code class="codehilite"><span class="n">constexpr</span></code> 版の実装を、実行時には非 <code class="codehilite"><span class="n">constexpr</span></code> の標準ライブラリの実装を提供するよう選択させることができます。なお、<code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">is_constant_evaluated</span><span class="p">()</span></code> を <code class="codehilite"><span class="k">if</span> <span class="nv">constexpr</span></code> の <code class="codehilite"><span class="p">(</span> <span class="p">)</span></code> 内や <code class="codehilite"><span class="n">static_assert</span></code> 内で使うと常に <code class="codehilite"><span class="k">true</span></code> に評価されてしまうので注意が必要です。基本的には <code class="codehilite"><span class="k">if</span> <span class="ss">(</span><span class="nv">std</span>::<span class="nv">is_constant_evaluated</span><span class="ss">())</span></code> と書きます。</p>
<p><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="k">constexpr</span> <span class="kt">float</span> <span class="nf">Sin_impl</span><span class="p">(</span><span class="kt">float</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">float</span> <span class="n">xn</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">?</span> <span class="mf">0.0f</span> <span class="o">:</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">xn</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">+</span> <span class="n">Sin_impl</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">xn</span> <span class="o">*</span> <span class="n">x2</span><span class="p">,</span> <span class="n">nf</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="kt">float</span> <span class="nf">Sin</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_constant_evaluated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Sin_impl</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">Pi</span> <span class="o">=</span> <span class="mf">3.14159265f</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span> <span class="c1">// コンパイル時計算    </span>
    <span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>  <span class="c1">// 実行時計算</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<div class="codehilite"><pre><span></span><span class="mi">0</span><span class="p">.</span><span class="mi">7071068286895752</span>
<span class="mi">0</span><span class="p">.</span><span class="mi">7071067690849304</span>
</pre></div></p>
<h3 id="p0020r6">浮動小数点数型のアトミック操作を拡張 <a href="https://wg21.link/P0020R6">(P0020R6)</a></h3>
<p><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="k">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> の <code class="codehilite"><span class="nb">float</span></code>, <code class="codehilite"><span class="n">double</span></code>, <code class="codehilite"><span class="n">long</span> <span class="n">double</span></code> 型の特殊化に、メンバ関数 <code class="codehilite"><span class="n">fetch_add</span><span class="p">()</span></code>, <code class="codehilite"><span class="n">fetch_sub</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">operator</span><span class="o">+=</span><span class="p">()</span></code>, <code class="codehilite"><span class="k">operator</span><span class="o">-=</span><span class="p">()</span></code> が追加されます。</p>
<h3 id="stdmemory_order-enum-class-p0439r0"><code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">memory_order</span></code> を <code class="codehilite"><span class="k">enum</span> <span class="k">class</span></code> に変更 <a href="https://wg21.link/P0439R0">(P0439R0)</a></h3>
<p>C++17 まで <code class="codehilite"><span class="k">enum</span></code> で定義されていた <code class="codehilite"><span class="n">std</span><span class="p">::</span><span class="n">memory_order</span></code> を、モダンな C++ 文法と型安全のために、<code class="codehilite"><span class="k">enum</span> <span class="k">class</span></code> で定義する仕様に変更されます。これまでの表記は定数で提供されるようになるため、既存のソースコードは影響を受けません。また、バイナリ互換性のために、<code class="codehilite"><span class="k">enum</span> <span class="k">class</span></code> の基底型の選択は実装に任せられています。</p>
<div class="superfences-tabs">
<input name="__tabs_2" type="radio" id="__tab_2_0" checked="checked" />
<label for="__tab_2_0">C++17</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="k">enum</span> <span class="n">memory_order</span>
    <span class="p">{</span>
        <span class="n">memory_order_relaxed</span><span class="p">,</span>
        <span class="n">memory_order_consume</span><span class="p">,</span>
        <span class="n">memory_order_acquire</span><span class="p">,</span>
        <span class="n">memory_order_release</span><span class="p">,</span>
        <span class="n">memory_order_acq_rel</span><span class="p">,</span>
        <span class="n">memory_order_seq_cst</span>
    <span class="p">}</span> <span class="n">memory_order</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>
<input name="__tabs_2" type="radio" id="__tab_2_1" />
<label for="__tab_2_1">C++20</label>
<div class="superfences-content"><div class="codehilite"><pre><span></span><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">memory_order</span> <span class="cm">/* : unspecified */</span>
    <span class="p">{</span>
        <span class="n">relaxed</span><span class="p">,</span>
        <span class="n">consume</span><span class="p">,</span>
        <span class="n">acquire</span><span class="p">,</span>
        <span class="n">release</span><span class="p">,</span>
        <span class="n">acq_rel</span><span class="p">,</span>
        <span class="n">seq_cst</span>
    <span class="p">};</span>

    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_relaxed</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_consume</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">consume</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_acquire</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">acquire</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_release</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">release</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_acq_rel</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">acq_rel</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">memory_order</span> <span class="n">memory_order_seq_cst</span> <span class="o">=</span> <span class="n">memory_order</span><span class="o">::</span><span class="n">seq_cst</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>
</div>
<h3 id="hash-p0809r0"><code class="codehilite"><span class="n">Hash</span></code> が同一の挙動をしない非順序連想コンテナどうしの比較が可能に <a href="https://wg21.link/P0809R0">(P0809R0)</a></h3>
<p>C++17 までは、非順序連想コンテナの <code class="codehilite"><span class="k">operator</span><span class="o">==</span></code>, <code class="codehilite"><span class="k">operator</span><span class="o">!=</span></code> について、「両者の <code class="codehilite"><span class="n">Hash</span></code> と <code class="codehilite"><span class="n">Pred</span></code> がそれぞれ同一の挙動をしない場合は未定義動作」と規格に記されていました。しかし、ランダムなソルトを使うハッシュ関数を持つコンテナ同士の比較もユースケースとして想定され、また、対応するための実装も難しくなかったことから、C++20 からはこのうち <code class="codehilite"><span class="n">Hash</span></code> に関する記述が削除されました。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">RandomizedHash</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">rnd</span><span class="p">;</span>

    <span class="n">RandomizedHash</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
        <span class="n">rnd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">rd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">s</span><span class="p">)</span> <span class="o">^</span> <span class="n">rnd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">RandomizedHash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">u1</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Three&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">RandomizedHash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">u2</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="s">&quot;Three&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="c1">// それぞれ異なるハッシュ値を返す</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;abcde&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;u1: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">u1</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;u2: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">u2</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>

    <span class="c1">// C++17 までは未定義動作、C++20 から OK</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h3 id="p0463r1">実行環境のエンディアンを判別するための列挙定数を追加 <a href="https://wg21.link/P0463R1">(P0463R1)</a></h3>
<p>これまでの C++ プログラムでは、ターゲットアーキテクチャのバイトオーダを判別する際にトリッキーなコードを書く必要がありました。C++20 からは、リトルエンディアンを表す <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">little</span></code>, ビッグエンディアンを表す <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">big</span></code>, 実行環境のエンディアンを表す <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">native</span></code> の 3 つの <code class="codehilite"><span class="n">endian</span></code> 型の列挙定数（値は実装に依存）が <code class="codehilite"><span class="o">&lt;</span><span class="n">type_traits</span><span class="o">&gt;</span></code> に定義され、<code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">native</span></code> をそれ以外の値と比較することで、実行環境のバイトオーダを判別できるようになります。現在の C++ コンパイラで、リトルエンディアンでもビッグエンディアンでもないミドルエンディアン（PDP エンディアンなど）をサポートしているものはありませんが、ミドルエンディアンの環境においては、<code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">native</span></code> は <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">big</span></code> でも <code class="codehilite"><span class="n">endian</span><span class="p">::</span><span class="n">little</span></code> でもない値を持つことになっています。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">little</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Little-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">big</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Big-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Middle-endian</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../.." title="Home" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  前
                </span>
                Home
              </span>
            </div>
          </a>
        
        
          <a href="../cppx/" title="C++23 以降に向けた提案" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  次
                </span>
                C++23 以降に向けた提案
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            To the extent possible under law, Ryo Suzuki has waived all copyright and related or neighboring rights to C++ の歩き方 | CppMap. Third party copyrights are property of their respective owners.
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://twitter.com/Reputeless" class="md-footer-social__link fa fa-twitter"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.39abc4af.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
          
            
              
                <script src="../../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../../assets/javascripts/lunr/lunr.ja.js"></script>
              
            
          
          
            <script src="../../assets/javascripts/lunr/lunr.multi.js"></script>
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>